We have accomplished a lot in the previous chapter! Let's recap – we
started with a blank canvas, added a few pages of content, styled
everything to look pretty, dropped in a picture of tomster, added links
between our pages and amazingly, everything worked together flawlessly!

But do we _really_ know that everything is actually working? Sure, we
clicked around a bit to confirm that things look as expected. But do we
feel confident that we checked _every_ page after the most recent change
that we made?

After all, most of us have experienced (or heard horror stories about)
making a Small Tweak™ in one area of the app and inadvertently breaking
_everything else_ when we weren't looking.

Maybe we can write a checklist somewhere for things to check after
making changes to our site. But surely, this will get out of hand
quickly as we add more features to our app? It is also going to get old
real quick – repetitive tasks like that are best left to robots.

Hmm, robots. That's an idea. What if we can write this checklist and
just get the computer to check everything for us?

Well, we just invented the idea of _automated testing_! Okay, maybe we
were not the first to come up with the concept, but we independently
discovered it so we still deserve some credits.

Once we are done patting ourselves on the back, go ahead and run the
following command in the terminal:

```
ember generate acceptance-test super-rentals
```

This is called a "generator" command in Ember CLI. They automatically
create files for us based on Ember's conventions and populating them
with the appropiate boilerplate content, similar to how `ember new`
created the skeleton app for us. It typically follows the pattern `ember
generate <type> <name>`, where `<type>` is the kind of thing we are
generating, and `<name>` is what we want to call it.

In this case, we generated an _acceptance test_ called `super-rentals`,
which was created for us at `tests/acceptance/super-rentals-test.js`.
Generators aren't required; we could have created the file ourselves
which would accomplish the same thing, but they certainly save us a lot
of typing. Go ahead and take a peek of the file and see for youself.

> Zoey says: Want to save even more typing? `ember generate ...` can be
> shortened into `ember g ...`. That's 7 fewer characters!

Acceptance tests are one of the few types of automated testing at our
disposal in Ember. We will learn about the other types later, but what
makes acceptance tests unique is that they test our app from the user's
perspective – they are an automated version of the "click around and see
if it works" testing we did earlier, which is exactly what we need.

Let's open the generated test file and replace the boilerplate test with
our own:

<-- TODO: show diff -->
```
import { module, test } from 'qunit';
import { click, visit, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from 'ember-qunit';

 module('Acceptance | super rentals', function(hooks) {
  setupApplicationTest(hooks);

   test('visiting /', async function(assert) {
    await visit('/');

     assert.equal(currentURL(), '/');
    assert.dom('h2').containsText('Welcome to Super Rentals!');

     assert.dom('.jumbo a.button').containsText('About Us');
    await click('.jumbo a.button');

     assert.equal(currentURL(), '/about');
  });
});
```

First, we instruct the test robot to navigate to the `/` URL of our app
using the `visit` _test helper_ provided by Ember. This is akin to us
typing `http://localhost:4200/` in the browser's address bar and hitting
the <ENTER> key.

Because the page is going to take some time to load, this is known as an
_async_ (short for _asynchronous_) step, so we will need to tell the
test robot to wait up using the `await` keyword in JavaScript. That way,
it will know to wait until the page finishes loading completely before
moving on to the next step.

This is almost always the behavior you want, so you will almost always
use `await` and `visit` as a pair. This applies to other kinds of
simulated interaction too, such as clicking on a button or a link, as
they all takes time to complete. Even though sometimes these actions may
seem imperceptibly fast to us, we have to remember that our test robot
have really really fast hands, as we will see in a moment.

After navigating to the `/` URL and waiting for things to settle, we
checked that URL matches what we expect, using the `currentURL` test
helper and the `equal` _assertion_. This is how we encode our checklist
into code – by specifying, or _asserting_ how things should behave, we
can be notified when our app does not behave like we expect.

Next, we confirmed that there should be a `<h1>` tag on the page that
contains the text "Welcome to Super Rentals!". Knowing this is true
means that we can be quite certain that the correct template is being
rendered and without errors.

Then, we looked for a link with the text `About Us`, located using the
_CSS selector_ `.jumbo a.button`. This is the same syntax we used in our
stylesheet, which means "look inside the tag with the `jumbo` class, for
and `<a>` tag with the `button` class". This matches up with the HTML
structure in our template.

Once its existance is confirmed, we told the test robot to click on this
link. As mentioned above, this is a user interaction, so it needs to be
`await`-ed.

Finally, we asserted that clicking on the link should bring us to the
`/about` URL.

> Zoey says: Here, we are writing the tests in a framework called QUnit,
> which is where `module`, `test` and `assert` comes from. We also had
> additional helpers like `click`, `visit` and `currentURL` provided by
> the `@ember/test-helpers` package. You tell what came from which
> package based on the `import` paths at the top of the file. Knowing
> this will be helpful when you need to search for documentation on the
> Internet or ask for help.

We can put our automated test into motion by running the _test server_,
using the `ember test --server` command, or `ember t -s` for short. It
is like the development server, but for our tests. It may automatically
open a browser window and take you to the test UI, or you can open
`http://localhost:7357/` yourself.

If you watch really carefully, you can see our test robot roam around
our app and clicking links:

<-- TODO: animated gif -->

It happens really quickly though, blink and you might miss it. In fact,
I had to slow this animation down by a hundred times just so you can see
it in action. I told you the robot has really really fast hands!

As much as I enjoy watching this, the important thing is that the test
we wrote has _passed_, meaning everything is working exactly as we
expect and so the test UI is all green and happy. If you want, you can
go to `index.hbs`, delete the `<LinkTo>` component and see what things
look like when we have a _failing test_.

<!-- TODO: animated gif -->

Don't forget to put it back when you are done!

Let's practice what we learned by adding tests for the remaining pages:

<-- TODO: show diff -->
```
import { module, test } from 'qunit';
import { click, visit, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from 'ember-qunit';

 module('Acceptance | super rentals', function(hooks) {
  setupApplicationTest(hooks);

   test('visiting /', async function(assert) {
    await visit('/');

    assert.equal(currentURL(), '/');
    assert.dom('h2').containsText('Welcome to Super Rentals!');

    assert.dom('.jumbo a.button').containsText('About Us');
    await click('.jumbo a.button');

    assert.equal(currentURL(), '/about');
  });

   test('visiting /about', async function(assert) {
    await visit('/about');

     assert.equal(currentURL(), '/about');
    assert.dom('h2').containsText('About Super Rentals');

     assert.dom('.jumbo a.button').containsText('Contact Us');
    await click('.jumbo a.button');

     assert.equal(currentURL(), '/getting-in-touch');
  });

   test('visiting /getting-in-touch', async function(assert) {
    await visit('/getting-in-touch');

     assert.equal(currentURL(), '/getting-in-touch');
    assert.dom('h2').containsText('Contact Us');

     assert.dom('a.button').containsText('About');
    await click('.jumbo a.button');

     assert.equal(currentURL(), '/about');
  });
});
```

As with the development server, the test UI should automatically reload
and rerun the entire test suite as you save the files. It is recommended
that you keep this page open as you develop your app, that way, you will
get immediate feedback if you accidentally broke something.

For the rest of the tutorial, we will continue to add more automated
tests as we develop new features. Testing is optional, they don't affect
the functionality your app, they just protect it from _regressions_,
which is just a fancy way of saying accidental breakages.

If you are in a hurry, you can skip over the testing sections in this
tutorial and still be able to follow everything else, but don't you
think it's super satisfying – _oddly satisfying_ – to watch a robot
click on things really really fast?
