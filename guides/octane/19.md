At this point, a big part of our template is devoted to the `<img>` tag's `src` attribute, which is getting pretty long. One alternative is to move this computation into a JavaScript instead.

From within our JavaScript class, we have access to our component's arguments using the `this.args.*` API. Using that, we can create a new getter to compute the map's URL and reference that from the template instead.

<div class="cta">
  <div class="cta-note">
    <div class="cta-note-body">
      <div class="cta-note-heading">Zoey says...</div>
      <div class="cta-note-message">
        `this.args` is an API provided by the `@glimmer/component` Glimmer component superclass. You may come across other components superclasses, such "classic" components in legacy codebases, that provides a different API for accessing component arguments from JavaScript code.
      </div>
    </div>
    <img src="/images/mascots/zoey.png" role="presentation" alt="Ember Mascot">
  </div>
</div>

```js {data-filename="app/components/map.js" data-diff="+4,+7,+8,+9,+10,+11,+12,+13,+14,+15,+16"}
import Component from '@glimmer/component';
import ENV from 'super-rentals/config/environment';

const MAPBOX_API = 'https://api.mapbox.com/styles/v1/mapbox/streets-v11/static';

export default class MapComponent extends Component {
  get src() {
    let { lng, lat, width, height, zoom } = this.args;

    let coordinates = `${lng},${lat},${zoom}`;
    let dimensions  = `${width}x${height}`;
    let accessToken = `access_token=${this.token}`;

    return `${MAPBOX_API}/${coordinates}/${dimensions}@2x?${accessToken}`;
  }

  get token() {
    return encodeURIComponent(ENV.MAPBOX_ACCESS_TOKEN);
  }
}
```

```handlebars {data-filename="app/components/map.hbs" data-diff="-5,+6"}
<div class="map">
  <img
    alt="Map image at coordinates {{@lat}},{{@lng}}"
    ...attributes
    src="https://api.mapbox.com/styles/v1/mapbox/streets-v11/static/{{@lng}},{{@lat}},{{@zoom}}/{{@width}}x{{@height}}@2x?access_token={{this.token}}"
    src={{this.src}}
    width={{@width}} height={{@height}}
  >
</div>
```

Much nicer! And all of our tests still pass!

Note that we did not mark our getter as `@Tracked`. Unlike instance variables, getters cannot be "assigned" a new value directly, so it does not make sense for Ember to monitor them for changes.

That being said, the values _produced_ by getters can certainly change. In our case, the value produced by our `src` getter depends on the values of `lat`, `lng`, `width`, `height` and `zoom` from `this.args`. Whenever these *[dependencies](TODO: link to dependencies)* get updated, we would certainly expect `{{this.src}}` from our template to be updated accordingly.

Ember does this by automatically tracking any variables that were accessed while computing a getter's value. As long as the dependencies themselves are marked as `@Tracked`, Ember will know exactly when to invalidate and re-render any templates that may potentially contain any "stale" (outdated) getter values.

Since all arguments are implicitly marked as `@Tracked` by the Glimmer component superclass that we inherited from, everything Just Works&trade;.

Just to be sure, we can add a test for this behavior:

```js {data-filename="tests/integration/components/map-test.js}
import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import { render, find } from '@ember/test-helpers';
import hbs from 'htmlbars-inline-precompile';
import ENV from 'super-rentals/config/environment';

module('Integration | Component | map', function(hooks) {
  setupRenderingTest(hooks);

  // ...snip...

  test('it updates the `src` attribute when the arguments change', async function(assert) {
    this.setProperties({
      lat: 37.7749,
      lng: -122.4194,
      zoom: 10,
      width: 150,
      height: 120,
    });

    await render(hbs`<Map
      @lat={{this.lat}}
      @lng={{this.lng}}
      @zoom={{this.zoom}}
      @width={{this.width}}
      @height={{this.height}}
    />`);

    let img = find('.map img');

    assert.ok(img.src.includes('-122.4194,37.7749,10'), 'the src should include the lng,lat,zoom parameter');
    assert.ok(img.src.includes('150x120@2x'), 'the src should include the width,height and @2x parameter');

    this.setProperties({
      width: 300,
      height: 200,
      zoom: 12,
    });

    assert.ok(img.src.includes('-122.4194,37.7749,12'), 'the src should include the lng,lat,zoom parameter');
    assert.ok(img.src.includes('300x200@2x'), 'the src should include the width,height and @2x parameter');

    this.setProperties({
      lat: 47.6062,
      lng: -122.3321,
    });

    assert.ok(img.src.includes('-122.3321,47.6062'), 'the src should include the lng,lat,zoom parameter');
    assert.ok(img.src.includes('300x200@2x'), 'the src should include the width,height and @2x parameter');
  });

  // ...snip...
});
```

Using the special `this.setProperties` testing API, we can pass arbitrary values into our component.

Note that the value of `this` here does _not_ refer to the component instance. We are not directly accessing or modifying the component's internal states (that would be extremely rude!).

Instead, they refer to a special  *[test context](TODO: link to test context)* object, which we have access to inside the `render` helper. This provides a "bridge" for us to pass dynamic values, in the form of arguments, into our invocation of the component. This allows us to update these values as needed from the test function.
