In the last chapter, we got a light introduction to _components_ when
using `<LinkTo>` to connect our pages. To recap, we said they are
Ember's way for creating _custom tags_ to suppliment the built-in HTML
tags from the browser. Here, we are going to create our own components!

During the course of developing an app, it is pretty common to reuse the
same UI element across different parts of the app. For example, we have
been using the same "jumbo" header in all three pages so far. Every page
we worked on follow the same basic structure:

```hbs
<div class="jumbo">
  <div class="right tomster"></div>
  <!-- page specific content -->
</div>
```

Since it was not a lot of code, it may not seem like a big deal to
duplicate it on each page. However, if our designer wanted us to make a
change to the header, we would have to find and update every single copy
of this code. As our app gets bigger, this will become even more of
problem.

Components are the perfect solution to this. In its most basic form, a
component is just a piece of template that can be referred to by name.
Let's start by creating a new file at `app/components/jumbo.hbs` with
markup for the "jumbo" header:

```handlebars {data-filename="app/components/jumbo.hbs"}
<div class="jumbo">
  <div class="right tomster"></div>
  {{yield}}
</div>
```

That's it, we have created our first component! We can now _invoke_ this
component anywhere in our app, using `<Jumbo>` as the tag name.

> Zoey says: Remember, when invoking components, we need to capitalize
> their names so Ember can tell them apart from regular HTML elements.
> So, use `jumbo.hbs` becomes `<Jumbo>` and `super-awesome.hbs` becomes
> `<SuperAwesome>`.

When invoking a component, Ember will replace that with the content
found in the component's template. Just like regular HTML tags, it is
pretty common to want to pass _content_ to components, such as
`<Jumbo>some content</Jumbo>`. The `{{yield}}` keyword will be replaced
with the content passed into the component.

Let's try it out by editing the index template:

```handlebars {data-filename="app/templates/index.hbs" data-diff="-1,-2,+3,-7,+8"}
<div class="jumbo">
  <div class="right tomster"></div>
<Jumbo>
  <h2>Welcome to Super Rentals!</h2>
  <p>We hope you find exactly what you're looking for in a place to stay.</p>
  <LinkTo @route="about" class="button">About Us</LinkTo>
</div>
</Jumbo>
```

After saving the changes, your page should automatically reload, and,
_voil√†_... nothing changed? Except, that's exactly what we wanted this
time! We successfully _refactored_ our index template to using the
`<Jumbo>` component, and everything still worked as expected. All the
tests are still passing!

Let's do the same for our other two pages as well.

```handlebars {data-filename="app/templates/about.hbs" data-diff="-1,-2,+3,-11,+12"}
<div class="jumbo">
  <div class="right tomster"></div>
<Jumbo>
  <h1>About Super Rentals</h1>
  <p>
    The Super Rentals website is a delightful project created to explore Ember.
    By building a property rental site, we can simultaneously imagine traveling
    AND building Ember applications.
  </p>
  <LinkTo @route="contact" class="button">Contact Us</LinkTo>
</div>
</Jumbo>
```

```handlebars {data-filename="app/templates/contact.hbs" data-diff="-1,-2,+3,-19,+20"}
<div class="jumbo">
  <div class="right tomster"></div>
<Jumbo>
  <h2>Contact Us</h2>
  <p>
    Super Rentals Representatives would love to help you<br>
    choose a destination or answer any questions you may have.
  </p>
  <address>
    Super Rentals HQ
    <p>
      1212 Test Address Avenue<br>
      Testington, OR 97233
    </p>
    <a href="tel:503.555.1212">+1 (503) 555-1212</a><br>
    <a href="mailto:superrentalsrep@emberjs.com">superrentalsrep@emberjs.com</a>
  </address>
  <LinkTo @route="about" class="button">About</LinkTo>
</div>
</Jumbo>
```

After saving, everything should look exactly the same as before, and all
the tests should still pass. Very nice!

While it may not save you a lot of characters in this case, it made the
template slightly easier to read by _encapsulating_ the implementation
of the "jumbo" header in its own component, allowing the reader to focus
on things that are unique to that page. Plus, now we will just have to
change a single place if we ever want to modify the header. Feel free
to give that a try!

Before we move on to the next component, let's write an automated test
for our `<Jumbo>` component. Run this command in your terminal:

```
ember generate component-test jumbo
```

Here, we used the generator to generate a _component test_. They allow
us to render and test a single component at a time. This is in contrast
to the acceptance tests we wrote earlier, which has to navigate and
render entire pages worth of content.

Let's replace the boilerplate generated for us with our own test:

```js {data-filename="tests/integration/components/jumbo.js" data-diff="+9,+10,+11,+12,+13,+14,+15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32"}
import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import { render } from '@ember/test-helpers';
import hbs from 'htmlbars-inline-precompile';

module('Integration | Component | jumbo', function(hooks) {
  setupRenderingTest(hooks);

  test('it renders the content inside a jumbo header with a tomster', async function(assert) {
    await render(hbs`<Jumbo>Hello World</Jumbo>`);

    assert.dom('.jumbo').exists();
    assert.dom('.jumbo').containsText('Hello World');
    assert.dom('.jumbo .tomster').exists();
  });
  test('it renders', async function(assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.set('myAction', function(val) { ... });

    await render(hbs`<Jumbo />`);

    assert.equal(this.element.textContent.trim(), '');

    // Template block usage:
    await render(hbs`
      <Jumbo>
        template block text
      </Jumbo>
    `);

    assert.equal(this.element.textContent.trim(), 'template block text');
  });
});
```

Instead of navigating to a URL, we start the test by rendering our
`<Jumbo>` component on the test page. This is useful, because it may
otherwise require a lot of setup and interaction just to get to a page
where your component is used. Component tests allows us to skip all of
that and focus exclusively on testing the component by itself.

Just like `visit` and `click`, `render` is also an async step, so we
need to pair it with the `await` keyword.

Other than that, the rest of the test is very similar to how we wrote
our acceptance tests in the previous chapter.

Make sure the test is passing by checking the tests UI in the browser.
