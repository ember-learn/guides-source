So far, we've been hard-coding everything into our `<Rental>` component. But that's probably not very sustainable, since eventually, we want our data to come from a server instead of hard-coded values. Let's go ahead and move some of those values out of the component in preparation for that.

If we take a look at our routes file, we'll notice that they currently serve just static pages (with hard-coded content). However, we want to start working towards routes that can fetch some data from the server, and then render that data dynamically in their respective templates.

First off, we're going to need a place that will let us load data from our index route. In order to load data here, we'll need to create a *[route file](TODO: link to route file)*, which we can create at `app/routes/index.js`.

Inside of this new route, we'll add the following content:

<!-- TODO: format diff -->

```
import Route from '@ember/routing/route';

 export default class IndexRoute extends Route {
  async model() {
    return {
      title: 'Grand Old Mansion',
      owner: 'Veruca Salt',
      city: 'San Francisco',
      location: {
        lat: 37.7749,
        lng: -122.4194,
      },
      category: 'Estate',
      type: 'Standalone',
      bedrooms: 15,
      image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',
      description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',
    };
  }
}
```

There's a lot happening here that we haven't seen before, so let's walk through this. First, we're importing the *[Route class](TODO: link to Route class)* into the file. This class is used to define individual routes.

<!-- TODO: format diff -->

```
import Route from '@ember/routing/route'
```

Then, since we need to create our _own_ route here for the index route, we are extending the Route class and defining our own `IndexRoute` class, which we are also exporting so that the rest of the application can use it.

<!-- TODO: format diff -->

```
export default class IndexRoute extends Route
```

So far, so good. But what's happening inside of this route? Well, we have a line that reads like a function: `async model()` that we haven't seen before. Well, this isn't _just_ a function, it's the *[model hook](TODO: link to model hook)*! The model hook is responsible for fetching and preparing any data that you need for your route. *[Hooks](TODO: link to hooks) are a bit more special than just a regular methods, because Ember will automatically call them for us at certain times in our app. In the case of the model hook, Ember will automatically call this for us in order to load the model onto a route.

We'll notice that our model hook returns an object that holds some data. The object that is returned from this function is our route's *[model](TODO: link to model)*. The model hook lives in this file because it is the route handler's responsibility to load the model.

At the moment, we are hard-coding the data but, usually, this is where we'd fetch data from a server. We'll get to that bit a later on. This is why the `model` hook is an `async` function; fetching data is usually an asynchronous operation.

So, now that we've got some data to return from our `model` hook, let's use this data in our template. In our route template, we can access the model that we just returned from the hook as `this.model`.

Let's try modifying our template to use our model data. We'll just the model's `title` to our `index.hbs` template to see if it works first.

<!-- TODO: format diff -->

```
<h1>{{this.model.title}}</h1>

<div class="list-filter">
  <ul class="results">
  <li><Rental /></li>
  <li><Rental /></li>
  <li><Rental /></li>
  </ul>
</div>
```

If we look at our page in the browser, we should see our model data reflected as a new header.

<!-- TODO: screenshot? -->

Awesome! Looking good.

<!-- TODO: Update the below cta note when https://github.com/emberjs/rfcs/pull/523 is merged. We don't want mention the `this` being the controller here and should just be able to explain `@model` here instead. -->

<div class="cta">
  <div class="cta-note">
    <div class="cta-note-body">
      <div class="cta-note-heading">Zoey says...</div>
      <div class="cta-note-message">
        The `this` in `this.model` does _not_ refer to the route object. You _cannot_ add instance variables or getters on the route and have access to them here. It's a good idea to keep your route template simple and minimal &mdash; if you need to add state or getters, just add a component!
      </div>
    </div>
    <img src="/images/mascots/zoey.png" role="presentation" alt="Ember Mascot">
  </div>
</div>

Ok, now that we know that we have a model to use at our disposal, let's remove some of the hard-coding that we did earlier! Instead of explicitly hard-coding the rental information into our `<Rental>` component we can rely on the model and use the data on _that_ object to populate our component.

Let's try it out. First, let's pass in our model to our `<Rental>` component. Remember that we're invoking our component from `index.hbs`, so we'll need to look there to make this change.

<!-- TODO: format diff -->

```
<div class="list-filter">
  <ul class="results">
    <li><Rental @rental={{this.model}} /></li>
    <li><Rental @rental={{this.model}} /></li>
    <li><Rental @rental={{this.model}} /></li>
  </ul>
</div>
```

Once we pass in `this.model` &mdash; our "Grand Old Mansion" model object &mdash; into the `<Rental>` component as the `{{@rental}}` argument into our `<Rental>` component, we will have access to it in our component!

<!-- TODO: format diff -->

```
@rental={{this.model}}
```

Since we passed it in as `@rental`, we'll need to invoke that in order to get any values from off of it. Now, we can replace our hardcoded values in this component by using the values that live on our `@rental` model.

<!-- TODO: format diff -->

```
<article class="rental">
  <Rental::Image
    src={{@rental.image}}
    alt="A picture of {{@rental.title}}"
  />

  <div class="details">
    <h3>{{@rental.title}}</h3>
    <div class="detail owner">
      <span>Owner:</span> {{@rental.owner}}
    </div>
    <div class="detail type">
      <span>Type:</span> {{@rental.type}}
    </div>
    <div class="detail location">
      <span>Location:</span> {{@rental.city}}
    </div>
    <div class="detail bedrooms">
      <span>Number of bedrooms:</span> {{@rental.bedrooms}}
    </div>
  </div>

  <Map
    @lat={{@rental.location.lat}}
    @lng={{@rental.location.lng}}
    @zoom="9"
    @width="150"
    @height="150"
    alt="A map of {{@rental.title}}"
  />
</article>
```

Now, we have one last thing to do: update the tests to reflect this change. Before we render our component, we'll want to set some properties on our test so that we can get access this rental data from the test.

```
test('it renders information about a rental property', async function(assert) {
  this.setProperties({
    rental: {
      title: 'Grand Old Mansion',
      owner: 'Veruca Salt',
      city: 'San Francisco',
      location: {
        lat: 37.7749,
        lng: -122.4194,
      },
      category: 'Estate',
      type: 'Standalone',
      bedrooms: 15,
      image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',
      description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',
    }
  });

  await render(hbs`<Rental @rental={{this.rental}} />`);

  // more test assertions here...
});
```

Notice that we also need to update the `<Rental>` component that we invoked in the `render` function to also have a `@rental` argument passed into it. If we run our tests now, they should all pass!
