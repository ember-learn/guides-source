So far, we've been hard-coding everything into our `<Rental>` component. But that's probably not very sustainable, since eventually, we want our data to come from a server instead. Let's go ahead and move some of those hard-coded values out of the component in preparation for that.

We want to start working towards a place where we can eventually fetch data from the server, and then render the requested data as dynamic content from the templates. In order to do that, we will need a place where we can write the code for fetching data and loading them into the routes.

In Ember, *[route files](TODO: link to route files)* are the place to do that. We haven't needed them yet, because all our routes are essentially just rendering static pages up until this point, but we are about to change that.

Let's start by creating a route file for the index route. We will create a new file at `app/routes/index.js` with the following content:

<!-- TODO: format diff -->

```
import Route from '@ember/routing/route';

export default class IndexRoute extends Route {
  async model() {
    return {
      title: 'Grand Old Mansion',
      owner: 'Veruca Salt',
      city: 'San Francisco',
      location: {
        lat: 37.7749,
        lng: -122.4194,
      },
      category: 'Estate',
      type: 'Standalone',
      bedrooms: 15,
      image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',
      description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',
    };
  }
}
```

There's a lot happening here that we haven't seen before, so let's walk through this. First, we're importing the *[`Route` class](TODO: link to Route class)* into the file. This class is used as a starting point for adding functionality to a route, such as loading data.

<!-- TODO: format diff -->

```
import Route from '@ember/routing/route';
```

Then, since we are extending the `Route` class into our _own_ `IndexRoute`, which we are also exporting so that the rest of the application can use it.

<!-- TODO: format diff -->

```
export default class IndexRoute extends Route {
  // ...snip...
}
```

So far, so good. But what's happening inside of this route class? We implemented an *[async method](TODO: link to async method)* called `model()`. This method is also known as the *[model hook](TODO: link to model hook)*.

The model hook is responsible for fetching and preparing any data that you need for your route. Ember will automatically call this hook for when entering a route, so that you can have an opportunity to do what you need to get the data you need. The object returned from this hook is known as the *[model](TODO: link to model)* for the route (surprise!).

Usually, this is where we'd fetch data from a server. Since fetching data is usually an asynchronous operation, the model hook is marked as `async`. This gives us the option of using the `await` keyword to wait for the data fetching operations to finish.

We'll get to that bit later on. At the moment, we are just returning the same hard-coding model data, extracted from the `<Rental>` component, but in a JavaScript object (also known as *[POJO](TODO: link to POJO)*) format.

So, now that we've prepared some model data for our route, let's use it in our template. In route templates, we can access the model for the route as `this.model`. In our case, that would contain the POJO returned from our model hook.

To test that this is working, let's modify our template and try to render the `title` property from our model:

<!-- TODO: format diff -->

```
<h1>{{this.model.title}}</h1>

<div class="rentals">
  <ul class="results">
    <li><Rental /></li>
    <li><Rental /></li>
    <li><Rental /></li>
  </ul>
</div>
```

If we look at our page in the browser, we should see our model data reflected as a new header.

<!-- TODO: screenshot? -->

Awesome! Looking good.

<!-- TODO: Update the below cta note when https://github.com/emberjs/rfcs/pull/523 is merged. We don't want mention the `this` being the controller here and should just be able to explain `@model` here instead. -->

<div class="cta">
  <div class="cta-note">
    <div class="cta-note-body">
      <div class="cta-note-heading">Zoey says...</div>
      <div class="cta-note-message">
      The `this` in `this.model` does _not_ refer to the route object. You _cannot_ add instance variables or getters on the route class and have access to them here. It's a good idea to keep your route template simple and minimal â€” if you need to add state or getters, just add a component and call it from your route template!
      </div>
    </div>
    <img src="/images/mascots/zoey.png" role="presentation" alt="Ember Mascot">
  </div>
</div>

Ok, now that we know that we have a model to use at our disposal, let's remove some of the hard-coding that we did earlier! Instead of explicitly hard-coding the rental information into our `<Rental>` component, we can pass the model object to our component instead.

Let's try it out. First, let's pass in our model to our `<Rental>` component as the `@rental` argument. We will also remove the extraneous `<h1>` tag we added earlier, no that we know things are working:

<!-- TODO: format diff -->

```
<div class="rentals">
  <ul class="results">
    <li><Rental @rental={{this.model}} /></li>
    <li><Rental @rental={{this.model}} /></li>
    <li><Rental @rental={{this.model}} /></li>
  </ul>
</div>
```

Once we pass in `this.model` &mdash; our "Grand Old Mansion" model object &mdash; into the `<Rental>` component as the `{{@rental}}` argument into our `<Rental>` component, we will have access to it in our component!

<!-- TODO: format diff -->

```
@rental={{this.model}}
```

Since we passed it in as `@rental`, we'll need to invoke that in order to get any values from off of it. Now, we can replace our hard-coded values in this component by using the values that live on our `@rental` model.

<!-- TODO: format diff -->

```
<article class="rental">
  <Rental::Image
    src={{@rental.image}}
    alt="A picture of {{@rental.title}}"
  />

  <div class="details">
    <h3>{{@rental.title}}</h3>
    <div class="detail owner">
      <span>Owner:</span> {{@rental.owner}}
    </div>
    <div class="detail type">
      <span>Type:</span> {{@rental.type}}
    </div>
    <div class="detail location">
      <span>Location:</span> {{@rental.city}}
    </div>
    <div class="detail bedrooms">
      <span>Number of bedrooms:</span> {{@rental.bedrooms}}
    </div>
  </div>

  <Map
    @lat={{@rental.location.lat}}
    @lng={{@rental.location.lng}}
    @zoom="9"
    @width="150"
    @height="150"
    alt="A map of {{@rental.title}}"
  />
</article>
```

Now, we have one last thing to do: update the tests to reflect this change. Before we render our component, we'll want to set some properties on our test so that we can get access this rental data from the test.

```
test('it renders information about a rental property', async function(assert) {
  this.setProperties({
    rental: {
      title: 'Grand Old Mansion',
      owner: 'Veruca Salt',
      city: 'San Francisco',
      location: {
        lat: 37.7749,
        lng: -122.4194,
      },
      category: 'Estate',
      type: 'Standalone',
      bedrooms: 15,
      image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',
      description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',
    }
  });

  await render(hbs`<Rental @rental={{this.rental}} />`);

  // more test assertions here...
});
```

Notice that we also need to update the `<Rental>` component that we invoked in the `render` function to also have a `@rental` argument passed into it. If we run our tests now, they should all pass!
