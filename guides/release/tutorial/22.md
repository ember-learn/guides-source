Now that we are fetching real data from our "server", let's add a new feature: dedicated pages for each of our rentals.

It would be great for our individual rental pages to be available through predictable URLs like `/rentals/grand-old-mansion`. Also, since these pages are dedicated to individual rentals, we can show more detailed information about each property on this page. It would also be nice to be able to have a way to bookmark a rental property, and share direct links to each individual rental listing so that our users can come back to these pages later on, after they are done browsing.

But first things first: we need to add a route for this new page. We can do that by adding a `rental` route to the router.

<!-- TODO: format diff -->

```
Router.map(function() {
  this.route('rental', { path: '/rentals/:rental_id' });
  this.route('about');
  this.route('contact', { path: '/getting-in-touch' });
});
```

Notice that we are doing something a little different here. Instead of using the default path (`/rental`), we're specifying a custom path. Not only are using a custom path, but we're also passing in a `:rental_id`, which is what we call a *[dynamic segment](TODO: link to dynamic segment)*. When these routes are evaluated, the `rental_id` will be substituted with the `id` of the individual rental property that we are trying to navigate to.

Now that we have this route in place, we can update our `<Rental>` component to actually _link_ to each of our detailed rental properties!

<!-- TODO: show diff -->

```
<h3>
  <LinkTo @route="rental" @model={{@rental}}>
    {{@rental.title}}
  </LinkTo>
</h3>
```

Since we know that we're linking to the `rental` route that we just created, we also know that this route requires a dynamic segment. Thus, we need to pass in a `@model` argument so that the `<LinkTo>` component can generate the appropriate URL for that model.

Let's see this in action. If we go back to our browser and refresh the page, we'll should see our links, and they should all link to the correct URLs.

<!-- TODO: screenshot? -->

Wait a second &mdash; we have links, but they are all pointing to `/rentals/undefined`. Yikes! This is because `<LinkTo>` tries to use the `id` property from our model in order to replace the dynamic segment and generate the URL.

So what's the problem here? Well, our model doesn't actually have an `id` property! So _of course_ the `<LinkTo>` component isn't going to be able to find it and use it to generate the URL. Oops!

Thankfully, we can fix this pretty easily. As it turns out, the data that is returned by our server &mdash; the JSON data that lives in our `public/api` folder &mdash; actually does have an `id` attribute on it. We can double check this by going to `http://localhost:4200/api/rentals.json`.

<!-- TODO: screenshot? -->

If we look at the JSON data here, we can see that the `id` is include right alongside the `attributes` key. So we have access to this data; the only trouble is that we're not including it in our model! Let's change our model hook in the `index` route so that it includes the `id`.

<!-- TODO format diff -->

```
async model() {
    let response = await fetch('/api/rentals.json');
    let { data } = await response.json();

    return data.map(model => {
      let { id, attributes } = model;
      let type;

      if (COMMUNITY_CATEGORIES.includes(attributes.category)) {
        type = 'Community';
      } else {
        type = 'Standalone';
      }

      return { id, type, ...attributes };
    });
  }
```

Now that we've included our model's `id`, we should see the correct URLs to each rental property on our index page after refreshing the page.

<!-- TODO: screenshot? -->

Alright, we have just one more step left here: updating the tests. We can add an `id` to the rental that we defined in our test using `setProperties` and add an assertion for the expected URL, too.

<!-- TODO format diff -->

```
import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import { render } from '@ember/test-helpers';
import hbs from 'htmlbars-inline-precompile';

module('Integration | Component | rental', function(hooks) {
  setupRenderingTest(hooks);

  test('it renders information about a rental property', async function(assert) {
    this.setProperties({
      rental: {
        id: 'grand-old-mansion',
        title: 'Grand Old Mansion',
        owner: 'Veruca Salt',
        city: 'San Francisco',
        location: {
          lat: 37.7749,
          lng: -122.4194,
        },
        category: 'Estate',
        type: 'Standalone',
        bedrooms: 15,
        image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',
        description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',
      }
    });

    await render(hbs`<Rental @rental={{this.rental}} />`);

    assert.dom('article').hasClass('rental');
    assert.dom('article h3').containsText('Grand Old Mansion');
    assert.dom('article h3 a').hasAttribute('href', '/rentals/grand-old-mansion');
    assert.dom('article .detail.owner').containsText('Veruca Salt');
    assert.dom('article .detail.type').containsText('Standalone');
    assert.dom('article .detail.location').containsText('San Francisco');
    assert.dom('article .detail.bedrooms').containsText('15');
    assert.dom('article .image').exists();
    assert.dom('article .map').exists();
  });
});
```

Awesome! However, there is one more point to mention here: by default, a component test (like the one that we have here) does not set up the router. Usually, this is what you'd want, since for more components, you likely aren't going need the router to test what you want. But in this specific case, we have a `<LinkTo>` in our component that is relying on the router to generate its URLs.

In this situation, we essentially need to _specifically_ opt-in to explicitly use our router in our component test. We can do this by calling `setupRouter()` in our `beforeEach` hook, which will set up the router before each test.

```
module('Integration | Component | rental', function(hooks) {
  setupRenderingTest(hooks);

  hooks.beforeEach(function() {
    this.owner.setupRouter();
  });

  test('it renders information about a rental property', async function(assert) {
    // test here...
  }
}
```

<div class="cta">
  <div class="cta-note">
    <div class="cta-note-body">
      <div class="cta-note-heading">Zoey says...</div>
      <div class="cta-note-message">
        As its name implies, the `beforeEach` hook runs _once_ before each `test` function is executed. This hook is the ideal place to setup anything that might be needed by all test cases in the file. On the other hand, if you need to do any cleanup after your tests, there is an `afterEach` hook!
      </div>
    </div>
    <img src="/images/mascots/zoey.png" role="presentation" alt="Ember Mascot">
  </div>
</div>


Setting up our router before each test function is executed will allow us to properly test that the URLs generated by `<LinkTo>` are exactly what we expect them to be. Awesome! We're making such great progress.
