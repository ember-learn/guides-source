Now that we've added some features, it's time to do some clean up again!

Awhile back, we added the `rental` route. If memory serves us well, we didn't do anything too fancy when we added that new route; we just copy-pasted it from the `index` route. That was fine to do as a starting point, but we definitely don't want that to end up in our final product! We need to *[DRY](TODO: link to DRY)* up our code and eliminate this duplication. Duplicated code is something to avoid for many reasons, including the fact that duplications make it much harder to maintain a code base in the long run, since it requires us to make multiple modifications in various different files for the same exact conceptual change. So, if we wanted to change something about how our routes worked, we'd have to change it in _both_ the `index` and `rental` routes. We can see another example of the limitations of duplications in our code in the way that our endpoints are structured. Our server's API endpoints all follow the JSON:API format, so if we were to continue duplicating our code for every new route that we made, we'd have to copy this format for every single new route!  

Fortunately, we're not going to do any of that. As it turns out, there's a much better solution here: we can use Ember Data! [Ember Data](https://github.com/emberjs/data) is a library that helps manage data in Ember applications. It comes with a lot of useful features that make it easy to manage the data of an app, as well as *[application state](TODO: link to some definition of application state)*.

There's a lot to learn about Ember Data, but let's start by uncovering features of it that are actually quite useful to our immediate problem. Ember Data provides something called an *[adapter](TODO: link to adapter)* API. Provided that our server uses a _consistent_ format across all of its endpoints, we can actually write an adapter to deal with the mapping between our model and the server endpoint where the model's data comes from. If at some point, our server's endpoint formatting becomes a bit inconsistent, we still don't have to worry! We can write a per-model adapter, too.

As it turns out, JSON:API just happens to be Ember Data's default adapter. Since our server also follows the same formatting convention, this is great news for us! However, there are two slight differences between how our server works and some of the assumptions that Ember Data makes. Ember Data expects to find the endpoints `/rentals` for our `index` route, and `/rentals/:rental_id` for our `rental` route. However, our server doesn't quite match up with these assumptions; it serves the `index` route at `/api/rentals.json`, and the `/rental` route at `/api/rentals/:rental_id.json`. Our server's endpoints _almost_ match up with what Ember Data expects the endpoints to be! Now it is much more obvious what the two _slight_ differences are:
  * Our model URLS have an extra `/api` _namespace_ prefix on them.
  * Our model URLS have a `.json` extension at the end of them.

In this case, Ember Data's default assumptions don't work perfectly for us. However, it is also pretty easy to customize Ember Data to work for our needs. We can do that by adding an *[application adapter](TODO: link to application adapter)*, which is where we can put our code to customize our URLs.

<!-- TODO: format diff for app/adapters/application.js -->

```
import JSONAPIAdapter from '@ember-data/adapter/json-api';

 export default class ApplicationAdapter extends JSONAPIAdapter {
  namespace = 'api';

   buildURL(...args) {
    return `${super.buildURL(...args)}.json`;
  }
}
```

The `JSONAPIAdapter` that we are importing and subsequently subclassing from here is the default adapter used by Ember Data for all *[resources](TODO: link to resources)* (or models) in our app. Adding a namespace to an adapter is pretty common across Ember apps, so Ember Data has an API to do just that. It allows us to prefix our endpoint paths with a namespace by setting the `namespace` property on the adapter. In our case, we set our `namespace = 'api'`.

Adding the `.json` extension is a bit less common, and doesn't have a declarative configuration API of its own. So we can just override Ember Data's [`buildURL`](https://api.emberjs.com/ember-data/3.12/classes/JSONAPIAdapter/methods/buildURL?anchor=buildURL) method to add one of our own. Inside of `buildURL`, we will call `super.buildURL(...args)` to ensure that we get the default implementation of Ember Data's _own_ `buildURL` method. The main thing that we're doing here is overriding the method to ensure that we append `.json` to the end of Ember Data's _built_ URL.

Now that we have our adapter, the next step is to create a `rental` model class! This will be fun.

<!-- TODO: format diff for model -->

```
import Model, { attr } from '@ember-data/model';

const COMMUNITY_CATEGORIES = [
  'Condo',
  'Townhouse',
  'Apartment'
];

export default class RentalModel extends Model {
  @attr() title;
  @attr() owner;
  @attr() city;
  @attr() location;
  @attr() category;
  @attr() image;
  @attr() bedrooms;
  @attr() description;

  get type() {
    if (COMMUNITY_CATEGORIES.includes(this.category)) {
      return 'Community';
    } else {
      return 'Standalone';
    }
  }
}
```

<!-- TODO: track emberjs/data#6328 and remove the () -->

The model holds the data for a resource; we can think of it as a wrapper object around the data of a resource, which makes it much easier for us to interact with that resource. In this case, an instance of the `RentalModel` class will hold the data for an individual rental property. Inside of our class, we are declaring the attributes on this model by using the `@attr` decorator. These attributes can be accessed from off of an instance of a rental property using dot notation: for example, `someRental.title` or `someRental.location.lat`.

Now that we have a class, we should be able to add a `type` getter to it, which is where we can put the logic of determining whether the model is of type `'Community'` or `'Standalone'`. Getters can be accessed just like any other "real" attribute through dot notation:  `someRental.type`. Furthermore, the `@attr` decorator also implies that the property is `@tracked`, which means that we don't need to explicitly state that it is a trackable property. A *[trackable property](TODO: link to trackable property)* is any property that may change over time or may cause the DOM to update in response to those changes. In our case, because `@attr` is an implied trackable property, whenever `@attr() category` is updated, the return value of the `type` getter will be too.

Now that we've added a new file for our model, let's add a *[model test](TODO: link to model test)*, too.

<!-- TODO: format diff for test -->

```
import { module, test } from 'qunit';
import { setupTest } from 'ember-qunit';

module('Unit | Model | rental', function(hooks) {
  setupTest(hooks);

  test('it has the right type', function(assert) {
    let store = this.owner.lookup('service:store');
    let rental = store.createRecord('rental', {
      id: 'grand-old-mansion',
      title: 'Grand Old Mansion',
      owner: 'Veruca Salt',
      city: 'San Francisco',
      location: {
        lat: 37.7749,
        lng: -122.4194,
      },
      category: 'Estate',
      bedrooms: 15,
      image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',
      description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',
    });

    assert.equal(rental.type, 'Standalone');

    rental.category = 'Condo';
    assert.equal(rental.type, 'Community');

    rental.category = 'Townhouse';
    assert.equal(rental.type, 'Community');

    rental.category = 'Apartment';
    assert.equal(rental.type, 'Community');

    rental.category = 'Estate';
    assert.equal(rental.type, 'Standalone');
  });
});
```

This model test is also known as a *[unit test](TODO: link to unit test)*. Unlike any of the other tests that we've written thus far, this test doesn't actually _render_ anything. It just instantiates the rental model object and tests the model directly, manipulating its attributes and asserting their value.

Alright, now that we have a model set up and have added an adapter, what can we do with it? Some refactoring and clean up, of course! Let's use our model and adapter changes to clean up our routes.

<!-- TODO: format diff -->

```app/routes/rental.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class RentalRoute extends Route {
  @service store;

  async model(params) {
    return this.store.find('rental', params.rental_id);
  }
}
```

```app/routes/index.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class IndexRoute extends Route {
  @service store;

  async model() {
    return this.store.findAll('rental');
  }
}
```

Awesome! We were able to delete a whole bunch of duplicated code, and our tests all still pass.

<!-- TODO: screenshot of tests? -->

Ember Data provides us with a *[store](TODO: link to store)*, which is what we can use to find our models once they have been fetched from the server. If we want access to the store, we need to `inject` the store as a service, when we are doing in both of our routes. The `@service store` is then available to us as `this.store` in our route.

The store acts as a kind of intermediary between our app and the server; it does many important things, including caching the response that is fetched from the server. If we request some data that we had _already_ fetched from the server in the past, Ember Data's store ensures that we can just access it immediately, without having to fetch it again unnecessarily and wait for the server to respond. Instead, the store will just return that model data immediately! But, if we don't already have that response cached in our store, then the storer will go off and fetch it from the server, all the while taking into account our adapter's configuration (it will also cache it for us for the next time that we try to fetch it). Pretty nice, right?

As we mentioned earlier, Ember Data offers many, many features (like managing the _relationships_ between our different models!) and there's a lot we can learn about it. But for the scope of this tutorial, we'll cover just a little bit. You can keep learning more about it in the Ember Data *[documentation](https://api.emberjs.com/ember-data/release/modules/@ember-data%2Fadapter)*, if you'd like!
