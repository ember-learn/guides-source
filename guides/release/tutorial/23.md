Ok, now that we have our `rental` route, let's finish up our `rental` page. The first step to doing this is making our route actually _do_ something. We added the route, but we haven't actually implemented it. So let's do that first.

We'll notice that the model hook in our `RentalRoute` is _almost_ the same as our `IndexRoute`. There is one major difference between these two routes, and we can see difference that reflected here.

<!-- TODO: format diff -->

```
import Route from '@ember/routing/route';

const COMMUNITY_CATEGORIES = [
  'Condo',
  'Townhouse',
  'Apartment'
];

export default class RentalRoute extends Route {
  async model(params) {
    let response = await fetch(`/api/rentals/${params.rental_id}.json`);
    let { data } = await response.json();

    let { id, attributes } = data;
    let type;

    if (COMMUNITY_CATEGORIES.includes(attributes.category)) {
      type = 'Community';
    } else {
      type = 'Standalone';
    }

    return { id, type, ...attributes };
  }
}
```

Unlike the `IndexRoute`, we have a `params` object being passed into our hook. This is because we need to fetch our data from the `/api/rentals/${id}.json` endpoint, _not_ the `/api/rentals.json` endpoint we were previously using. We already know that the individual rental endpoints fetch a single rental object, rather than an array of them, and that the route uses a `/:rental_id` dynamic segment to figure out which rental object we're trying to fetch from the server.

But how does the dynamic segment get to actually get to the `fetch` function? Well, we have to pass it into the function. Conveniently, we have access to the value of the `/:rental_id` dynamic segment through the `params` object. This is why we have a `params` argument in our model hook here. It is being passed through to this hook, and we use the `params.rental_id` attribute to figure out what data we want to `fetch`.

Other than these minor differences though, the rest of the route is pretty much the same to what we had in our index route.

Next, let's make a `<Rental::Detailed>` component.

<!-- TODO: format diff -->

```
<Jumbo>
  <h2>{{@rental.title}}</h2>
  <p>Nice find! This looks like a nice place to stay near {{@rental.city}}.</p>
  <a href="#" target="_blank" rel="external,nofollow,noopener,noreferrer" class="share button">
    Share on Twitter
  </a>
</Jumbo>

 <article class="rental detailed">
  <Rental::Image
    src={{@rental.image}}
    alt="A picture of {{@rental.title}}"
  />

   <div class="details">
    <h3>About {{@rental.title}}</h3>

     <div class="detail owner">
      <span>Owner:</span> {{@rental.owner}}
    </div>
    <div class="detail type">
      <span>Type:</span> {{@rental.type}} – {{@rental.category}}
    </div>
    <div class="detail location">
      <span>Location:</span> {{@rental.city}}
    </div>
    <div class="detail bedrooms">
      <span>Number of bedrooms:</span> {{@rental.bedrooms}}
    </div>
    <div class="detail description">
      <p>{{@rental.description}}</p>
    </div>
  </div>

   <Map
    @lat={{@rental.location.lat}}
    @lng={{@rental.location.lng}}
    @zoom="12"
    @width="894"
    @height="600"
    alt="A map of {{@rental.title}}"
    class="large"
  />
</article>
```

This component is similar to our `<Rental>` component, except for the following differences.
* It shows a banner with a share button on the top.
* It shows a bigger image by default, with some additional detailed information.
* It shows a bigger map.
* It shows a description.

For the most part, it basically is just a different arrangement of components that we've built for ourselves already. Hooray &mdash; we're making use of reusable components!

Soon, we'll implement that "Share on Twitter" button since it doesn't actually do anything just yet. But for now, we'll just put in some markup as a placeholder for it so that it looks right.

Until then, let's add the `rental` template to actually _invoke_ our `<Rental::Detailed>` component.

<!-- TODO: format diff -->

``
<Rental::Detailed @rental={{this.model}} />
```

Now that we have this template in place, we can add some tests for this new component of ours.

```
import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import { render } from '@ember/test-helpers';
import hbs from 'htmlbars-inline-precompile';

 module('Integration | Component | rental/detailed', function(hooks) {
  setupRenderingTest(hooks);

   hooks.beforeEach(function() {
    this.setProperties({
      rental: {
        id: 'grand-old-mansion',
        title: 'Grand Old Mansion',
        owner: 'Veruca Salt',
        city: 'San Francisco',
        location: {
          lat: 37.7749,
          lng: -122.4194,
        },
        category: 'Estate',
        type: 'Standalone',
        bedrooms: 15,
        image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',
        description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',
      }
    });
  });

   test('it renders a header with a share button', async function(assert) {
    await render(hbs`<Rental::Detailed @rental={{this.rental}} />`);

    assert.dom('.jumbo').exists();
    assert.dom('.jumbo h2').containsText('Grand Old Mansion');
    assert.dom('.jumbo p').containsText('a nice place to stay near San Francisco');
    assert.dom('.jumbo a.button').containsText('Share on Twitter');
  });

   test('it renders detailed information about a rental property', async function(assert) {
    await render(hbs`<Rental::Detailed @rental={{this.rental}} />`);

    assert.dom('article').hasClass('rental');
    assert.dom('article h3').containsText('About Grand Old Mansion');
    assert.dom('article .detail.owner').containsText('Veruca Salt');
    assert.dom('article .detail.type').containsText('Standalone – Estate');
    assert.dom('article .detail.location').containsText('San Francisco');
    assert.dom('article .detail.bedrooms').containsText('15');
    assert.dom('article .image').exists();
    assert.dom('article .map').exists();
  });
});
```

We can again use the `beforeEach` hook that we learned about earlier, which allows us to have two tests that each focus on a different, single aspect of the component, while also sharing some boilerplate code! This feels similar to other tests that we've already written &mdash; hopefully it feels easy, too!

Finally, let's write some additional acceptance tests for this new behavior in our app.

<!-- TODO: format diff -->

```
test('visiting /rentals/grand-old-mansion', async function(assert) {
 await visit('/rentals/grand-old-mansion');

 assert.equal(currentURL(), '/rentals/grand-old-mansion');
 assert.dom('nav').exists();
 assert.dom('h1').containsText('SuperRentals');
 assert.dom('h2').containsText('Grand Old Mansion');
 assert.dom('.rental.detailed').exists();
});

test('viewing the details of a rental property', async function(assert) {
 await visit('/');

 assert.dom('.rental').exists({ count: 3 });

 await click('.rental:first-of-type a');

 assert.equal(currentURL(), '/rentals/grand-old-mansion');
});
```

And if we run our tests now...

<!-- TODO: screenshot? -->

...they all pass! Great work!
