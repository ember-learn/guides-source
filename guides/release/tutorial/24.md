Since we've been doing some clean up and *[abstraction](TODO: link to abstraction)* of logic with reusable components, let's build a new feature. As promised, we will now work on implementing the share button!

In order to be able to share on Twitter, we'll need to make use of the Twitter [Web Intent API](https://developer.twitter.com/en/docs/twitter-for-websites/tweet-button/guides/web-intent.html). Conveniently, this API doesn't require us to procure any API keys; all we need to do is link to `https://twitter.com/intent/tweet`. This link will open a new page and prompt the user to compose a new tweet. The API also supports us pre-populating the tweet with some text, a hashtag suggestion, or even a link, all through the use of special query params. Of course, our user will still have the ability to edit the tweet, change its content, and they can also decide to just not tweet it at all. For our app, it probably makes the most sense for our share button to automatically share the current page's URL.

Now that we have a better understanding of the scope of this feature, let's get to work and generate a `share-button` component.

```shell
ember generate component share-button -gc
```

Let's start with the template that was generated for this component. We already have some markup for the share button in the `<Rental::Detailed>` component we made earlier, so let's just copy that over into our new `<ShareButton>` component.

<!-- TODO: format diff -->

```
<a
  ...attributes
  href={{this.shareURL}}
  target="_blank"
  rel="external,nofollow,noopener,noreferrer"
  class="share button"
>{{yield}}</a>
```

Notice that we also added `...attributes` to our `<a>` tag here. As [we learned earlier](TODO: link to chapter 18 map component) when working on our `<Map>` component, the order in which `...attributes` is executed by the component's invoker is very important. We don't want to allow anyone to override `href`, `target`, or `rel` from outside of this component, so we explicitly define those after `...attributes`.

But what happens to the `class` attribute? Well, as it turns out, the `class` attribute is the one exception to how these component attributes are overridden! While all other HTML attributes follow the "last-write wins" rule, the `class` attributes are all merged together instead. There is a good reason for this: the component can specify whatever classes that _it_ needs, while the invoker of the component can add any extra classes that _it_ needs.

We also have a `{{yield}}` inside of our `<a>` tag so that we can specify the text for the link in the `<Rental::Detailed>` component that invokes this `<ShareButton>`. Whew! Let's look at the JavaScript class next.

<!-- TODO: format diff -->

```
import Component from '@glimmer/component';
import { inject as service } from '@ember/service';

const TWEET_INTENT = 'https://twitter.com/intent/tweet';

export default class ShareButtonComponent extends Component {
  @service router;

  get currentURL() {
    let base = window.location.origin;
    return new URL(this.router.currentURL, base);
  }

  get shareURL() {
    let url = new URL(TWEET_INTENT);
    let { searchParams } = url;

    searchParams.set('url', this.currentURL);

    if (this.args.text) {
      searchParams.set('text', this.args.text);
    }

    if (this.args.hashtags) {
      searchParams.set('hashtags', this.args.hashtags);
    }

    if (this.args.via) {
      searchParams.set('via', this.args.via);
    }

    return url;
  }
}
```

In order for our share button to share the current page's URL, we first need to figure out what the URL for the current page actually _is_! At first, we might assume that we could just use the browser's [Location object](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) to do this, which we could access as `window.location.href`. However, this will posit a problem when it comes to testing: our "current page"'s URL will end up looking like  `http://localhost:7357/294138383687594/tests/index.html`. Or, the URL could be different each time we run our tests! Another issue with using `window.location.href` directly is that that we can't simply [replace](https://developer.mozilla.org/en-US/docs/Web/API/Location/replace) the Location object with a different object; if we read the documentation on `replace()` we'll see that the browser won't actually let us even do that! This means that, if we wanted the Location object to return something different from our tests, we'd be out of luck. Seems bad!

Rather than working within the limitations of the Location object, we can use the *[router service](TODO: link to router service)*, instead! In Ember, a service acts like a global variable, similar to `window.location.href`. The major difference between a service and other global variables is that a service is scoped to your app and can be easily replaced in your tests. We'll see an example of this in a bit. In our `ShareButtonComponent`, we're using the router service by adding `@service router;` to our component. Adding this line *[injects](TODO: link to injects)* the service into the component, which is available to us via the `router` instance variable.

We use the router service in our `currentURL` getter function, where we call `this.router.currentURL`, which gives us the current URL (according to Ember). However, the router service only gives us a portion of the path (for example, `/` or `/about`); it does not give us the _full_ path. So, we need to specify the "base" of the URL using `window.location.origin`. Once we have the base path, we can use the the browser's *[URL API](TODO: Link to URL API)* to build up the current URL using the `currentURL` from the router service.

Then, inside of the `shareURL` getter, we can use the return value of the `currentURL` getter to construct the shareable URL, which is expected by the Twitter Web Intent API. We use the URL API here again to set search params. Conveniently, the browser's URL API also handles escaping and joining of query params that are added to it, like `?` or `&` which are both commonly-used when constructing URLs.

Finally, we'll add a bunch of tests for this new component and its behavior.

<!-- TODO: format diff -->

```
import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import Service from '@ember/service';
import { render, find } from '@ember/test-helpers';
import hbs from 'htmlbars-inline-precompile';

class MockRouterService extends Service {
  get currentURL() {
    return '/foo/bar/baz?some=page#anchor';
  }
}

module('Integration | Component | share-button', function(hooks) {
  setupRenderingTest(hooks);

  hooks.beforeEach(function() {
    this.owner.register('service:router', MockRouterService);

     this.getShareURL = () => {
      let { href } = find('a');
      return new URL(href);
    };

     this.getShareParam = param => {
      let { searchParams } = this.getShareURL();
      return searchParams.get(param);
    };
  });

  test('basic usage', async function(assert) {
    await render(hbs`<ShareButton>Tweet this!</ShareButton>`);

    assert.dom('a').exists();
    assert.dom('a').hasAttribute('target', '_blank');
    assert.dom('a').hasAttribute('rel', 'external,nofollow,noopener,noreferrer');
    assert.dom('a').hasAttribute('href');
    assert.dom('a').hasClass('share');
    assert.dom('a').hasClass('button');
    assert.dom('a').containsText('Tweet this!');

    let currentURL = new URL('/foo/bar/baz?some=page#anchor', window.location.origin);
    let { origin, pathname } = this.getShareURL();

    assert.equal(origin, 'https://twitter.com');
    assert.equal(pathname, '/intent/tweet');
    assert.equal(this.getShareParam('url'), currentURL.toString());
  });

  test('it supports passing @text', async function(assert) {
    await render(hbs`<ShareButton @text="Hello Twitter!">Tweet this!</ShareButton>`);
    assert.equal(this.getShareParam('text'), 'Hello Twitter!');
  });

  test('it supports passing @hashtags', async function(assert) {
    await render(hbs`<ShareButton @hashtags="foo,bar,baz">Tweet this!</ShareButton>`);
    assert.equal(this.getShareParam('hashtags'), 'foo,bar,baz');
  });

  test('it supports passing @via', async function(assert) {
    await render(hbs`<ShareButton @via="emberjs">Tweet this!</ShareButton>`);
    assert.equal(this.getShareParam('via'), 'emberjs');
  });

  test('it supports adding extra classes', async function(assert) {
    await render(hbs`<ShareButton class="extra things">Tweet this!</ShareButton>`);

    assert.dom('a').hasClass('share');
    assert.dom('a').hasClass('button');
    assert.dom('a').hasClass('extra');
    assert.dom('a').hasClass('things');
  });

  test('the target, rel and href attributes cannot be overriden', async function(assert) {
    await render(hbs`<ShareButton targe="_self" rel="" href="/">Not a Tweet!</ShareButton>`);

    assert.dom('a').hasAttribute('target', '_blank');
    assert.dom('a').hasAttribute('rel', 'external,nofollow,noopener,noreferrer');
    assert.equal(this.getShareURL().origin, 'https://twitter.com');
  });
});
```

There are a few things happening in these newly-added tests. First, we created a "mock" router service that implements a `currentURL` getter (which always returns the same "mocked" value). Inside of the test itself, we register the mock router service with `this.owner.register('service:router`, MockRouterService);`. By registering our `MockRouterService` in our test, we're actually setting `MockRouterService` as the _value_ of the router service (`@service router;`) on our component. In other words, we're explicitly overriding the value of the router service in our test file to be the mock service, which we know will only ever return the one value that we hard-coded into it. As far as the component knows, we are currently on the page `/foo/bar/baz?some=page#anchor`. Explicitly setting our service in this way for our tests allows us to confidently say that our component works as expected.

We also want to test the behavior of the `shareURL` getter &mdash; like the value of `href`, or the `hashtag` and `text` in the URL params &mdash; so we have added some custom test helpers in the `beforeEach` that we can share and reuse throughout our tests. There are also two tests to ensures that additional `class`es can be added to the component, but the _other_ attributes (like the value of `href`) cannot be overridden. If, in the future, someone accidentally changes the order in which `...attributes` is invoked on the component, one of these tests should fail!

Alright, that was a lot we just did! Let's tie it all together by actually _using_ our component! We just need to update our `<Rental::Detailed>` component to use `<ShareButton>` instead of the hard-coded `<a>` tag we had in there earlier.

<!-- TODO: format diff -->

```
<ShareButton
    @text="Check out {{@rental.title}} on Super Rentals!"
    @hashtags="vacation,travel,authentic,blessed,superrentals"
    @via="emberjs"
  >
  Share on Twitter
</ShareButton>
```

Now, if we head to our browser, we can try it out.

<!-- TODO: screenshot? -->

Awesome, it works!

<div class="cta">
  <div class="cta-note">
    <div class="cta-note-body">
      <div class="cta-note-heading">Zoey says...</div>
      <div class="cta-note-message">
        Feel free to try the tweet button! However, keep in mind that your followers cannot access your local server at `http://localhost:4200/`. Don't worry though, at the end of the tutorial, we will deploy the app the the Internet so you can show everyone what you made!
      </div>
    </div>
    <img src="/images/mascots/zoey.png" role="presentation" alt="Ember Mascot">
  </div>
</div>
