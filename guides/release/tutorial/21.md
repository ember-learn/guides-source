Now that we have things in place, let's do the fun part of removing all our hard-coded values from the model hook and actually fetch some data from the server! In a production app, the data that we'd fetch would most likely come from an `api` route. Since we don't have a server available to us right now &mdash; and to avoid setting up a new one just for this tutorial &mdash; let's just put all of the data that we potentially will want to fetch into a separate folder.

But where will the data come from? Well, you can download [this](TODO: link to wherever this file will be hosted) `data.zip` file and add it to a `public/api` folder. If you've downloaded everything correctly, your `public` directory should now look like this:

```
public
├── api
│   ├── rentals
│   │   ├── downtown-charm.json
│   │   ├── grand-old-mansion.json
│   │   └── urban-living.json
│   └── rentals.json
├── assets
│   └── images
│       └── teaching-tomster.png
└── robots.txt
```

Once you've put this data into your `public` folder, you can verify that everything is working correctly by navigating to `http://localhost:4200/api/rentals.json`.

<!-- TODO: screenshot? -->

Awesome! The JSON data that we just downloaded is showing up now in our rental properties.

Now, let's turn our attention to our model hook again. We need to change it so that we actually fetch the "fake server" data in our `public/api` folder.

<!-- TODO: format diff -->

```
import Route from '@ember/routing/route';
export default class IndexRoute extends Route {
  async model() {
    let response = await fetch('/api/rentals.json');
    let { data } = await response.json();
  }
}
```

What's happening here? Well, first off, we're using something called `fetch`. What's that? Well, it's part of the browser's *[Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)*, which is what we will use to request that JSON data from our fake server's API (in `public/api`).

However, just like the model hook was an async function, fetching data from the server is also an asynchronous operation, which is why we are pairing the call to `fetch` with the `await` keyword. Whenever we use the Fetch API, we can assume that it will return a *[response object](TODO: link to response object)* back to us. Once we have this object, we can convert it back into whatever format we need; in our case, we want it to be JSON format, so we can use the `response.json()` method to transform the response object accordingly.

Transforming the response into JSON format is _also_ an asynchronous operation, so we'll just use the `await` keyword here, too. Before we go any further with our model hook, let's pause for a second to look at the `public/api/rentals.json` file. This data follows the *[JSON:API](TODO: link to JSON:API)* format, which is _slightly_ different than the hard-coded data that we were returning from the model hook before.

There are a few key differences between our previous hard-coded data and the JSON:API format that we should note here.

<!-- TODO: format diff -->

```
{
  "data": [
    {
      "type": "rentals",
      "id": "grand-old-mansion",
      "attributes": {
        "title": "Grand Old Mansion",
        "owner": "Veruca Salt",
        "city": "San Francisco",
        "location": {
          "lat": 37.7749,
          "lng": -122.4194
        },
        "category": "Estate",
        "bedrooms": 15,
        "image": "https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg",
        "description": "This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests."
      }
    },
    {
      ...
    },
    {
      ...
    }
  ]
}
```

First off, the JSON:API format returns an array under the `"data"` key, rather than a single object. If we think about this, though, it makes sense; we now want to show a whole list of rental properties that are coming from our server, not just one. This array is also nested differently; it lives inside of a `data` key.

This format also has a slightly different format for the rental properties themselves. Every data object has a `type` and `id`, which we don't intend to use in our template (yet!). For now, the only data we really need is nested within the `attributes` key.

There's one more key difference here, which perhaps only those with very sharp eyes will be able to catch: the data coming from the server is missing the `type` attribute, which previously existed on our hard-coded model object. The `type` attribute could either be `"Standalone"` or `"Community"`, depending on the type of rental property.

This is slightly annoying because we actually do use the `type` attribute in our `<Rental>` component...but not to worry, we'll figure out a much nicer way to consume this format later on. For now, let's fix this issue by just dealing with this difference in formats ourselves. For now, we can handle it all in our model hook; we'll fetch this data from the server, add in the `type` attribute manually, and then return it from the model hook. That way, the rest of our app won't have any idea that these difference exist, and we'll be able to fix the formatting before any of our models are ever rendered by our components. Perfect!

<!-- TODO: format diff -->

```
import Route from '@ember/routing/route';

const COMMUNITY_CATEGORIES = [
  'Condo',
  'Townhouse',
  'Apartment'
];

export default class IndexRoute extends Route {
  async model() {
    let response = await fetch('/api/rentals.json');
    let { data } = await response.json();

    return data.map(model => {
      let { attributes } = model;
      let type;

      if (COMMUNITY_CATEGORIES.includes(attributes.category)) {
        type = 'Community';
      } else {
        type = 'Standalone';
      }

      return { type, ...attributes };
    });
  }
}
```

Awesome! Now we're in business. The last change we'll need to make is to our `index.hbs` route template, where we invoke our `<Rental>` components. Previously, we were passing in `@rental` as `this.model` to our components. However, `this.model` is no longer a single object, but rather, an array! So, we'll need to change this template to account for that.

Let's see how.

<!-- TODO: format diff -->

```
<div class="list-filter">
  <ul class="results">
    {{#each this.model as |rental|}}
      <li><Rental @rental={{rental}} /></li>
    {{/each}}
  </ul>
</div>
```

We can use the `{{#each}}...{{/each}}` syntax to iterate and loop through the array returned by the model hook. For each iteration through the array &mdash; for each item in the array &mdash; we will render the block that is passed to it once. In our case, the block is our `<Rental>` component, surrounded by `<li>` tags.

Inside of the block we have access to the item of the _current_ iteration with the `{{rental}}` variable. But why `rental`? Well, because we named it that! This variable comes from the `as |rental|` declaration of the `each` loop. We could have just as easily called it something else, like `as |property|`, in which case we would have to access the current item through the `{{property}}` variable.

Now, let's go over to our browser and see what our index route looks like with this change.

<!-- TODO: screenshot? -->

Hooray! Finally we're seeing different rental properties in our list. And we got to play with `fetch` and write a loop. Pretty productive, if you ask me.
