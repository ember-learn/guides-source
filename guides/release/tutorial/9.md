In the last chapter, we got a light introduction to *[components](TODO: link to components)* when using `<LinkTo>` to connect our pages. To recap, we said they are Ember's way for creating *[custom tags](TODO: link to custom tags)* to supplement the built-in HTML tags from the browser. Now, we are going to create our own components!

During the course of developing an app, it is pretty common to reuse the same UI element across different parts of the app. For example, we have been using the same "jumbo" header in all three pages so far. On ever page we worked to follow the same basic structure:

```hbs
<div class="jumbo">
  <div class="right tomster"></div>
  <!-- page specific content -->
</div>
```

Since it was not a lot of code, it may not seem like a big deal to duplicate this structure on each page. However, if our designer wanted us to make a change to the header, we would have to find and update every single copy of this code. As our app gets bigger, this will become even more of problem.

Components are the perfect solution to this. In its most basic form, a component is just a piece of template that can be referred to by name. Let's start by creating a new file at `app/components/jumbo.hbs` with markup for the "jumbo" header:

```handlebars {data-filename="app/components/jumbo.hbs"}
<div class="jumbo">
  <div class="right tomster"></div>
  {{yield}}
</div>
```

That's it, we have created our first component! We can now *[invoke](TODO: link to invoke)* this component anywhere in our app, using `<Jumbo>` as the tag name.

<div class="cta">
  <div class="cta-note">
    <div class="cta-note-body">
      <div class="cta-note-heading">Zoey says...</div>
      <div class="cta-note-message">
        Remember, when invoking components, we need to capitalize their names so Ember can tell them apart from regular HTML elements. The `jumbo.hbs` template corresponds to the `<Jumbo>` tag, just like `super-awesome.hbs` corresponds to `<SuperAwesome>`.
      </div>
    </div>
    <img src="/images/mascots/zoey.png" role="presentation" alt="Ember Mascot">
  </div>
</div>

When invoking a component, Ember will replace the component tag with the content found in the component's template. Just like regular HTML tags, it is pretty common to want to pass *[content](TODO: link to content)* to components, such as `<Jumbo>some content</Jumbo>`. We can use the `{{yield}}` keyword to do this, which will be replaced with any content that was passed into the component.

Let's try it out by editing the index template:

```handlebars {data-filename="app/templates/index.hbs" data-diff="-1,-2,+3,-7,+8"}
<div class="jumbo">
  <div class="right tomster"></div>
  <Jumbo>
    <h2>Welcome to Super Rentals!</h2>
    <p>We hope you find exactly what you're looking for in a place to stay.</p>
    <LinkTo @route="about" class="button">About Us</LinkTo>
  </Jumbo>
</div>
```

After saving the changes, your page should automatically reload, and, _voil√†_... nothing changed? Well, that's exactly what we wanted to happen this time! We successfully *[refactored](TODO: link to refactored)* our index template to use the `<Jumbo>` component, and everything still works as expected. All the tests are still passing!

<!-- TODO: screenshot of running tests? -->

Let's do the same for our other two pages as well.

```handlebars {data-filename="app/templates/about.hbs" data-diff="-1,-2,+3,-11,+12"}
<div class="jumbo">
  <div class="right tomster"></div>
  <Jumbo>
    <h1>About Super Rentals</h1>
    <p>
      The Super Rentals website is a delightful project created to explore Ember.
      By building a property rental site, we can simultaneously imagine traveling AND building Ember applications.
    </p>
    <LinkTo @route="contact" class="button">Contact Us</LinkTo>
  </Jumbo>
</div>
```

```handlebars {data-filename="app/templates/contact.hbs" data-diff="-1,-2,+3,-19,+20"}
<div class="jumbo">
  <div class="right tomster"></div>
  <Jumbo>
    <h2>Contact Us</h2>
    <p>
      Super Rentals Representatives would love to help you<br>
      choose a destination or answer any questions you may have.
    </p>
    <address>
      Super Rentals HQ
      <p>
        1212 Test Address Avenue<br>
        Testington, OR 97233
      </p>
      <a href="tel:503.555.1212">+1 (503) 555-1212</a><br>
      <a href="mailto:superrentalsrep@emberjs.com">superrentalsrep@emberjs.com</a>
    </address>
    <LinkTo @route="about" class="button">About</LinkTo>
  </Jumbo>
</div>
```

After saving, everything should look exactly the same as before, and all the tests should still pass. Very nice!

<!-- TODO: screenshot of the page? -->

While it may not save you a lot of characters in this case, it made the template slightly easier to read by *[encapsulating](TODO: link to encapsulating)* the implementation of the "jumbo" header into its own component, which allowed the reader to focus on things that are unique to just that page. Now, if we need to make a change to the header, we will just have to make it in a single place. Feel free to give that a try!

Before we move on to the next component, let's write an automated test for our `<Jumbo>` component. Run this command in your terminal:

```shell
ember generate component-test jumbo
```

Here, we used the generator to generate a *[component test](TODO: link to component test)*. These are used to render and test a single component at a time. This is in contrast to the acceptance tests that we wrote earlier, which have to navigate and render entire pages worth of content.

Let's replace the boilerplate code that was generated for us with our own test:

```js {data-filename="tests/integration/components/jumbo.js" data-diff="+9,+10,+11,+12,+13,+14,+15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32"}
import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import { render } from '@ember/test-helpers';
import hbs from 'htmlbars-inline-precompile';

module('Integration | Component | jumbo', function(hooks) {
  setupRenderingTest(hooks);

  test('it renders the content inside a jumbo header with a tomster', async function(assert) {
    await render(hbs`<Jumbo>Hello World</Jumbo>`);

    assert.dom('.jumbo').exists();
    assert.dom('.jumbo').containsText('Hello World');
    assert.dom('.jumbo .tomster').exists();
  });

  test('it renders', async function(assert) {
    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.set('myAction', function(val) { ... });

    await render(hbs`<Jumbo />`);

    assert.equal(this.element.textContent.trim(), '');

    // Template block usage:
    await render(hbs`
      <Jumbo>
        template block text
      </Jumbo>
    `);

    assert.equal(this.element.textContent.trim(), 'template block text');
  });
});
```

Instead of navigating to a URL, we start the test by rendering our `<Jumbo>` component on the test page. This is useful because it may otherwise require a lot of setup and interaction just to get to a page where your component is used. Component tests allows us to skip all of that and focus exclusively on testing the component by itself.

Just like `visit` and `click`, which we used earlier, `render` is also an async step, so we need to pair it with the `await` keyword. Other than that, the rest of the test is very similar to the acceptance tests we wrote we in the previous chapter. Make sure the test is passing by checking the tests UI in the browser.

<!-- TODO: screenshot of the tests? -->
