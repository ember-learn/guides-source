**Note:** üöß This section is under construction! üèóÔ∏è The content here may not be fully up to date!

These directions are for converting an _existing_ Ember app to TypeScript. If you are starting a new app, you can use the directions in [Getting Started].

## Enable TypeScript Features

### A Bit of a Hack

Since `ember-cli` _currently_ has no flag to convert your project to TypeScript, we're going to use a bit of a hack and _temporarily_ install the legacy `ember-cli-typescript` addon to complete most of the migration:

```shell
ember install ember-cli-typescript@latest
```

The `ember-cli-typescript` addon will install _most_ of the necessary packages and create or update _most_ of the necessary files as described in [Getting Started].

You can then immediately remove the `ember-cli-typescript` dependency and follow the rest of this guide.

### Manually Enable TypeScript Transpilation

To enable TypeScript transpilation in your app, simply add the corresponding configuration for Babel to your `ember-cli-build.js` file.

```javascript {data-filename="ember-cli-build.js" data-diff="+2"}
const app = new EmberApp(defaults, {
  'ember-cli-babel': { enableTypeScriptTransform: true },
});
```

### Manually Add `lint:types` Script

To easily check types with the command line, add the `lint:types` script as shown [here][lint-types].

[lint-types]: https://github.com/ember-cli/editor-output/blob/stackblitz-app-output-typescript/package.json

The default `lint` script generated by Ember CLI will include the `lint:types` script automatically.

### Manually Force Blueprint Generators to Use TypeScript

With the following configuration, project files will be generated with `.ts` extensions instead of `.js`:

```javascript {data-filename=".ember-cli" data-diff="-2,+3"}
{
  "isTypeScriptProject": false,
  "isTypeScriptProject": true,
}
```

### Manually Set Up `@typescript-eslint`

```shell
npm add --save-dev @typescript-eslint/eslint-plugin @typescript-eslint/parser
```

Then, update your `.eslintrc.js` to include the [current output from the Ember CLI blueprints][eslintrc]. You might consider using ESLint [overrides] configuration to separately configure your JavaScript and TypeScript files during the migration.

[eslintrc]: https://github.com/ember-cli/editor-output/blob/stackblitz-app-output-typescript/.eslintrc.js
[overrides]: https://eslint.org/docs/latest/use/configure/configuration-files#configuration-based-on-glob-patterns

## Migrate Existing Code to TypeScript

Once you have set up TypeScript following the guides above, you can begin to migrate your files incrementally by changing their extensions from `.js` to `.ts`. Fortunately, TypeScript allows for gradual typing. This means that you can use TypeScript and JavaScript files interchangeably, so you can convert your app piecemeal.

Some specific tips for success on the technical front:

### Strictness

Use the [_strictest_ strictness][strictness] settings that our typings allow. While it may be tempting to start with the _loosest_ strictness settings and then to tighten them down as you go, this will actually mean that "getting your app type-checking" will become a repeated process‚Äîgetting it type-checking with every new strictness setting you enable‚Äîrather than something you do just once.

[strictness]: ../../additional-resources/faq/#toc_strictness

### Gradual Typing Hacks

Many of your files might reference types in other files that haven't been converted yet. There are several strategies you can employ to avoid a chain-reaction resulting in having to convert your entire app at once:

TypeScript [declaration files][dts] (`.d.ts`)‚ÄîThese files are a way to document TypeScript types for JavaScript files without converting them. One downside of declaration files, however, is that they can easily get out-of-sync with the corresponding JavaScript file, so we only recommend this option as a temporary step.

[dts]: https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html

JSDoc and `allowJs`‚ÄîAnother way to document TypeScript types for JavaScript files without converting them is to add [JSDoc type hints][JSDoc] to the files and enable the [`allowJs`][allowJs] compiler option in your `tsconfig.json`. While the JSDoc type syntax can be a bit cumbersome, it is much more likely to stay in sync. You can even type-check your JavaScript files using JSDoc and the [`@ts-check`][ts-check] directive.

[JSDoc]: https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#handbook-content
[allowJs]: https://www.typescriptlang.org/tsconfig/#allowJs
[ts-check]: https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html#ts-check

The [`unknown`][unknown] type‚ÄîYou can sometimes get pretty far just by annotating types as `unknown`.

[unknown]: https://www.typescriptlang.org/docs/handbook/2/functions.html

The [`any`][any] type‚ÄîOpt out of type checking for a value by annotating it as `any`.

[any]: https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any

The [`@ts-expect-error`][ts-expect-error] directive‚ÄîA better strategy than `any`, however, is to mark offending parts of your code with a `@ts-expect-error` directive. This comment will ignore a type-checking error and allow the TypeScript compiler to assume that the value is of the type `any`. If the code stops triggering the error, TypeScript will let you know.

[ts-expect-error]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html

\(Experienced TypeScript users may already be familiar with `@ts-ignore`. The difference is that `@ts-ignore` won't let you know when the code stops triggering the error. You can use ESLint to [disallow `@ts-ignore`][ban-ts-comment] in favor of `@ts-expect-error`. If you really want to dig into it, the TypeScript team provided guidelines about when to choose one over the other [here][ts-ignore-vs-expect].)

[ban-ts-comment]: https://typescript-eslint.io/rules/ban-ts-comment/
[ts-ignore-vs-expect]: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html?ref=blog.skylight.io#ts-ignore-or-ts-expect-error

### Outer Leaves First

A good approach is to start at your outer "leaf" modules (the ones that don't import anything else from your app, only Ember or third-party types) and then work your way "inward" (toward the modules with many internal imports). Often the highest-value modules are your Ember Data models and any core services that are used everywhere else in the app‚Äìand those are also the ones that tend to have the most cascading effects (having to update _tons_ of other places in your app) when you type them later in the process.

[getting started]: ../application-development/getting-started/
