{"data":{"type":"contents","id":"models/pushing-records-into-the-store","attributes":{"content":"One way to think about the store is as a cache of all of the records\nthat have been loaded by your application. If a route or a controller in\nyour app asks for a record, the store can return it immediately if it is\nin the cache. Otherwise, the store must ask the adapter to load it,\nwhich usually means a trip over the network to retrieve it from the\nserver.\n\nInstead of waiting for the app to request a record, however, you can\npush records into the store's cache ahead of time.\n\nThis is useful if you have a good sense of what records the user\nwill need next. When they click on a link, instead of waiting for a\nnetwork request to finish, Ember.js can render the new template\nimmediately. It feels instantaneous.\n\nAnother use case for pushing in records is if your application has a\nstreaming connection to a backend. If a record is created or modified,\nyou want to update the UI immediately.\n\n### Pushing Records\n\nTo push a record into the store, call the store's [`push()`](https://api.emberjs.com/ember-data/release/classes/Store/methods/push?anchor=push) method.\n\nFor example, imagine we want to preload some data into the store when\nthe application boots for the first time.\n\nWe can use the `route:application` to do so. The `route:application` is\nthe top-most route in the route hierarchy, and its `model` hook gets\ncalled once when the app starts up.\n\n```javascript {data-filename=app/models/album.js}\nimport Model, { attr } from '@ember-data/model';\n\nexport default class AlbumModel extends Model {\n  @attr title;\n  @attr artist;\n  @attr songCount;\n}\n```\n\n```javascript {data-filename=app/routes/application.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\n\nexport default class ApplicationRoute extends Route {\n  @service store;\n  \n  model() {\n    this.store.push({\n      data: [{\n        id: 1,\n        type: 'album',\n        attributes: {\n          title: 'Fewer Moving Parts',\n          artist: 'David Bazan',\n          songCount: 10\n        },\n        relationships: {}\n      }, {\n        id: 2,\n        type: 'album',\n        attributes: {\n          title: 'Calgary b/w I Can\\'t Make You Love Me/Nick Of Time',\n          artist: 'Bon Iver',\n          songCount: 2\n        },\n        relationships: {}\n      }]\n    });\n  }\n}\n```\n\nThe store's `push()` method is a low level API which accepts a JSON\nAPI document with a few important differences from the JSON:API\ndocument that the JSONAPISerializer accepts. The type name in the JSON\nAPI document must match the type name of the model exactly (In the\nexample above the type is `album` because the model is defined in\n`app/models/album.js`). Attributes and relationship names must match\nthe casing of the properties defined on the Model class.\n\nIf you would like the data to be normalized by the model's default\nserializer before pushing it into the store, you can use the\n[`store.pushPayload()`](https://api.emberjs.com/ember-data/release/classes/Store/methods/pushPayload?anchor=pushPayload) method.\n\n```javascript {data-filename=app/serializers/album.js}\nimport RESTSerializer from '@ember-data/serializer/rest';\n\nexport default class AlbumSerializer extends RESTSerializer {\n  normalize(typeHash, hash) {\n    hash['songCount'] = hash['song_count']\n    delete hash['song_count']\n    return super.normalize(typeHash, hash);\n  }\n}\n```\n\n```javascript {data-filename=app/routes/application.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\n\nexport default class ApplicationRoute extends Route {\n  @service store;\n\n  model() {\n    this.store.pushPayload({\n      albums: [\n        {\n          id: 1,\n          title: 'Fever Moving Parts',\n          artist: 'David Bazan',\n          song_count: 10\n        },\n        {\n          id: 2,\n          title: 'Calgary b/w I Can\\'t Make You Love Me/Nick Of Time',\n          artist: 'Bon Iver',\n          song_count: 2\n        }\n      ]\n    });\n  }\n}\n```\n\nThe `push()` method is also important when working with complex\nendpoints. You may find your application has an endpoint that performs\nsome business logic then creates several records. This likely does not\nmap cleanly to Ember Data's existing `save()` API which is structured\naround persisting a single record. Instead you should make your own\ncustom network request and push the resulting model data into the store\nso it can be accessed by other parts of your application.\n\n\n```javascript {data-filename=app/routes/confirm-payment.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\nimport { action } from '@ember/object';\nimport fetch from 'fetch';\n\nexport default class ConfirmPaymentRoute extends Route {\n  @service store;\n  @service router;\n  \n  @action\n  confirm(data) {\n    fetch('process-payment', {\n      method: 'POST',\n      body: JSON.stringify(data)\n    })\n    .then(response => response.json())\n    .then(digitalInventory => {\n      this.store.push(digitalInventory);\n      this.router.transitionTo('thank-you');\n    });\n  }\n}\n```\n\nProperties that are defined on the model but are omitted in the\nnormalized JSON:API document object will not be updated. Properties\nthat are included in the normalized JSON:API document object but not\ndefined on the Model will be ignored.","description":"One way to think about the store is as a cache of all of the records that have been loaded by your application. If a route or a controller in your app asks for a record, the store can return it immediately if it is in the cache. Otherwise, the store must..."}}}