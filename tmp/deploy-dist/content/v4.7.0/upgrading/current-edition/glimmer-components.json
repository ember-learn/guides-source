{"data":{"type":"contents","id":"upgrading/current-edition/glimmer-components","attributes":{"content":"There's a new component API in Octane! For this section, we'll be focusing on\nthe differences between the new style, known as Glimmer components, and classic\ncomponents, and how to upgrade. \"Classic\" components refer to older-style\ncomponents that do not use native classes.\n\nThese new types of Components _require_ native class syntax. You can define one\nlike this:\n\n```js\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nexport default class TodoComponent extends Component {\n  @tracked completed;\n}\n```\n\nYou might notice that the import comes from a package named `@glimmer`, not\n`@ember`. Behind the scenes, Ember's rendering engine comes from Glimmer, and\nnow the components do too. However, Glimmer is a low-level integration with\nEmber, and you don't need to worry about learning it separately.\n\n## Benefits of Glimmer Components\n\nGlimmer components have some huge benefits:\n\n- These new components give you all the benefits described in Native Classes\n  above\n- They don't extend from `EmberObject` at all, which means that they don't need\n  `EmberObject` APIs, such as `reopenClass`, `extend`. You can safely use\n  `constructor` for all setup code.\n- Lifecycle hooks are greatly simplified and easier to use\n- They don't have that wrapping HTML element that got in the way of CSS styling\n  and layout\n\nArguments are also namespaced on `this.args` within Glimmer components, which is\nan immutable object. This means that:\n\n- It's clear when you are accessing arguments passed to the component, and\n  when you are accessing fields and properties of the component itself.\n- Arguments always refer to the original value that was passed in, so you\n  don't have to track down confusing code in hooks or computed property\n  definitions that modifies the value of the argument.\n- There is no confusing two-way data binding for arguments via the component\n  class, data can only flow in one direction.\n\n## Getting used to Glimmer Components\n\n### Lifecycle and Properties\n\nThese components have 2 lifecycle hooks:\n\n- `constructor`\n- `willDestroy`\n\nThese can be used to setup the class and tear it down, respectively. Other\nlifecycle hooks, like `didInsertElement` and `didUpdate` don't have equivalents.\nInstead, you should use _modifiers_ to fill their use cases. These are discussed\nin more detail later on.\n\nComponents also have 3 properties:\n\n- `args` - the arguments that the component receives when invoked. These are\n  passed to and assigned in the constructor, so they're available then for any\n  setup code that is needed.\n- `isDestroying` - Set to true when the component has been marked for\n  destruction.\n- `isDestroyed` - Set to true when the component has been fully destroyed.\n\n### Outer HTML\n\nThese components don't have a wrapping element. This is referred to as _outer\nHTML semantics_, and it means that whatever you see in the template is what you\nget in the final rendered DOM:\n\n```handlebars\n{{!-- template.hbs --}}\n<div>\n  Hello, {{this.worldName}}!\n</div>\n```\n\n```html\n<!-- rendered -->\n<div>\n  Hello, Earth!\n</div>\n```\n\nThis means that you no longer have to customize your component using any of the\nfollowing APIs:\n\n- `tagName`\n- `classNames`\n- `classNameBindings`\n- `attributeBindings`\n\nInstead, you can do these directly in your template. Here are some before and\nafter examples of each API, converted from classic components:\n\n- `tagName`\n\n  Before:\n\n  ```js\n  import Component from '@ember/component';\n\n  export default Component.extend({\n    tagName: 'button',\n    text: 'Hello, world!',\n\n    click() {\n      console.log('Hello, world!');\n    }\n  });\n  ```\n\n  ```handlebars\n  {{this.text}}\n  ```\n\n  After:\n\n  ```js\n  import Component from '@glimmer/component';\n  import { action } from '@ember/object';\n\n  export default class HelloButtonComponent extends Component {\n    text = 'Hello, world!';\n\n    @action\n    sayHello() {\n      console.log('Hello, world!');\n    }\n  }\n  ```\n\n  ```handlebars\n    <button type=\"button\" {{on \"click\" this.sayHello}}>\n      {{this.text}}\n    </button>\n  ```\n\n- `classNames`\n\n  Before:\n\n  ```js\n  import Component from '@ember/component';\n\n  export default Component.extend({\n    classNames: ['hello-world'],\n    text: 'Hello, world!'\n  });\n  ```\n\n  ```handlebars\n  {{this.text}}\n  ```\n\n  After:\n\n  ```js\n  import Component from '@glimmer/component';\n\n  export default class HelloComponent extends Component {\n    text = 'Hello, world!';\n  }\n  ```\n\n  ```handlebars\n    <div class=\"hello-world\">\n      {{this.text}}\n    </div>\n  ```\n\n- `classNameBindings`\n\n  Before:\n\n  ```js\n  import Component from '@ember/component';\n\n  export default Component.extend({\n    classNameBindings: ['darkMode:dark-mode'],\n    darkMode: false,\n    text: 'Hello, world!'\n  });\n  ```\n\n  ```handlebars\n    {{this.text}}\n  ```\n\n  After:\n\n  ```js\n  import Component from '@glimmer/component';\n  import { tracked } from '@glimmer/tracking';\n\n  export default class HelloComponent extends Component {\n    text = 'Hello, world!';\n    @tracked darkMode = false;\n  }\n  ```\n\n  ```handlebars\n    <div class={{if this.darkMode \"dark-mode\"}}>\n      {{this.text}}\n    </div>\n  ```\n\n- `attributeBindings`\n\n  Before:\n\n  ```js\n  import Component from '@ember/component';\n\n  export default Component.extend({\n    attributeBindings: ['role'],\n    role: 'button',\n    text: 'Hello, world!'\n  });\n  ```\n\n  ```handlebars\n    {{this.text}}\n  ```\n\n  After:\n\n  ```js\n  import Component from '@glimmer/component';\n\n  export default class HelloComponent extends Component {\n    text = 'Hello, world!';\n    role = 'button';\n  }\n  ```\n\n  ```handlebars\n    <div role={{this.role}}>\n      {{this.text}}\n    </div>\n  ```\n\nTo sum it up, the new mental model is that the \"wrapping\" element is just like\nany other element in your template, and you interact with it in exactly the same\nway. This means that when converting a classic component, you will need to add\nthe wrapping element that was there previously to the template (unless it was a\ntagless component, e.g. `tagName: ''`).\n\n### `...attributes`\n\nWhen you pass standard HTML attributes to a component (like `class`, `alt`,\n`role`, etc), you need to tell the template where to put them. Remember, there's\nno wrapping element anymore! The way you show where to apply the attributes is\nby using `...attributes` in the template.\n\nFor example, here we pass a `class` to a component:\n\n```handlebars\n<MyComponent class=\"my-class\" />\n```\n\nAnd in that component, we can apply the class to the paragraph using\n`...attributes`:\n\n```handlebars\n{{!--\n  The paragraph gets the attributes, and not the h1\n--}}\n<h1>\n  Hello, world!\n</h1>\n<p ...attributes>\n  Lorem Ipsum...\n</p>\n```\n\nAttributes can be applied to multiple elements as well:\n\n```handlebars\n{{!-- Both elements get the attributes --}}\n<h1 ...attributes>\n  Hello, world!\n</h1>\n<p ...attributes>\n  Lorem Ipsum...\n</p>\n```\n\nYou can apply `...attributes` to elements that have explicit attributes as well.\nIf `...attributes` comes _after_ another attribute, then it'll be possible for\nthe user to override them:\n\n```handlebars\n<p\n  data-overridable=\"you can override me\"\n  ...attributes\n  data-non-overridable=\"but you can't override me!\"\n>\n  ...\n</p>\n```\n\nFinally, if you don't apply `...attributes` to _any_ elements, then Ember will\nthrow an error if someone tries to use attributes when invoking your component:\n\n```handlebars\n{{!-- components/uncustomizable-button.hbs --}}\n<button type=\"button\" class=\"btn\">Do a thing!</button>\n```\n\n```handlebars\n{{!-- This throws an error --}}\n<UncustomizableButton class=\"customized-button-class\" />\n```\n\nAttributes are also available to classic components, and `...attributes` is\napplied automatically to the wrapping element. If you're converting a component\nfrom classic components, you should be sure to add `...attributes` to the\nwrapper element.\n\nBefore:\n\n```js\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  text: 'Hello, world!'\n});\n```\n\n```handlebars\n{{this.text}}\n```\n\nAfter:\n\n```js\nimport Component from '@glimmer/component';\n\nexport default class HelloComponent extends Component {\n  text = 'Hello, world!';\n}\n```\n\n```handlebars\n<div ...attributes>\n  {{this.text}}\n</div>\n```\n\n### Arguments\n\nIn classic components, arguments are assigned _directly_ to the class instance.\nThis has caused a lot of issues over the years, from methods and actions being\noverwritten, to unclear code where the difference between internal class values\nand arguments is hard to reason about.\n\nNew components solve this by placing all arguments in an object available\nas the `args` property.\n\nBefore:\n\n```js\nimport Component from '@ember/component';\nimport { computed } from '@ember/object';\n\nexport default Component.extend({\n  width: 0,\n  height: 0,\n\n  aspectRatio: computed('width', 'height', function() {\n    return this.width / this.height;\n  })\n});\n```\n\n```handlebars\n{{!-- Usage --}}\n<Image @width=\"1920\" @height=\"1080\" />\n```\n\nAfter:\n\n```js\nimport Component from '@glimmer/component';\n\nexport default class ImageComponent extends Component {\n  get aspectRatio() {\n    return this.args.width / this.args.height;\n  }\n}\n```\n\n```handlebars\n{{!-- Usage --}}\n<Image @width=\"1920\" @height=\"1080\" />\n```\n\n`args` and its values are automatically tracked, so there is no need to annotate\nthem, the `aspectRatio` getter will invalidate properly when they change and the\ncomponent will rerender (if `aspectRatio` is used in the template).\n\nAdditionally, `args` is _not_ mutable, and is frozen in development modes. This\nis partially to prevent folks from trying to accomplish two-way bindings (which\ndoesn't work, this is discussed in more detail below) and partially to ensure\nthat `args` always stays in sync with the arguments passed to the component, so\nit can be the canonical \"single source of truth\". If you want to provide\ndefaults to an argument, you should use a getter.\n\nBefore:\n\n```js\nimport Component from '@ember/component';\nimport { computed } from '@ember/object';\n\nexport default Component.extend({\n  width: 0,\n  height: 0,\n\n  aspectRatio: computed('width', 'height', function() {\n    return this.width / this.height;\n  })\n});\n```\n\nAfter:\n\n```js\nimport Component from '@glimmer/component';\n\nexport default class ImageComponent extends Component {\n  get width() {\n    return this.args.width ?? 0;\n  }\n\n  get height() {\n    return this.args.height ?? 0;\n  }\n\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\n```\n\n### One-way Data Flow\n\nClassic component's arguments are _two-way bound_. This means that when you\n_set_ a value in the component, it also changes the value in the _parent_\ncomponent:\n\n```js\n// components/parent.js\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  value: 'Hello, world!'\n});\n```\n\n```handlebars\n{{!-- templates/components/parent.hbs --}}\n<Child @value={{this.value}} />\n```\n\n```js\n// components/child.js\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  click() {\n    this.set('value', 'Hello, moon!');\n  }\n});\n```\n\n```handlebars\n{{!-- templates/components/child.hbs --}}\n<button type=\"button\">\n  Change value\n</button>\n```\n\nIn this setup, when we click the child component's button, it'll update the\nvalue in both the child component _and_ the parent component. This feature led\nto many problematic data patterns in classic components, where mutations would\noccur seemingly randomly. It was hard to figure out what was causing changes,\nand to debug them.\n\nFor Glimmer components, arguments are _one-way bound_. There is no way to\ndirectly mutate a value on a parent component from the child component, even if\nit is passed as an argument. Instead, you must send an _action_ upward to mutate\nthe value:\n\n```js\n// components/parent.js\nimport Component from '@glimmer/component';\n\nexport default class ParentComponent extends Component {\n  value = 'Hello, world!';\n\n  @action\n  updateValue(newValue) {\n    this.value = newValue;\n  }\n}\n```\n\n```handlebars\n{{!-- templates/components/parent.hbs --}}\n<Child @value={{this.value}} @onClick={{this.updateValue}} />\n```\n\n```js\n// components/child.js\nimport Component from '@ember/component';\n\nexport default class ChildComponent extends Component {}\n```\n\n```handlebars\n{{!-- templates/components/child.hbs --}}\n<button type=\"button\" {{on \"click\" (fn @onClick 'Hello, moon!')}}>\n  Change value\n</button>\n```\n\nIn our new setup, the parent component has an action which sets the new value.\nWe pass this action to the child component, and the child component directly\nassigns it to the click of the button, using the `{{on}}` modifier. It also passes\nthe value we want to call the `@onClick` using the `fn` helper. We don't need any\nadditional logic in the child class itself - in fact, this could become a\ntemplate-only component at this point.\n\nThis pattern is known as _Data-Down, Actions Up_, or _unidirectional data flow_.\nFor these new components, this pattern is enforced - all mutations must occur\nthrough actions. This clarifies the data flow, because it's immediately possible\nto see where all of the mutations are occurring.\n\n### Lifecycle Hooks & Modifiers\n\nAs we mentioned above, components only have two lifecycle hooks,\n`constructor` and `willDestroy`. There were a number of other lifecycle hooks\nthat existed on classic components which were generally related to updating\ncomponent state or DOM manipulation:\n\n- `willInsertElement`\n- `didInsertElement`\n- `willDestroyElement`\n- `didDestroyElement`\n- `willRender`\n- `didRender`\n- `willUpdate`\n- `didUpdate`\n- `didReceiveAttrs`\n- `didUpdateAttrs`\n\nThese can generally be replaced either by using getters, in cases where they are\nrelated to updating component state, or by using _modifiers_. For example, installing the [`@ember/render-modifiers`](https://github.com/emberjs/ember-render-modifiers) addon will give you the ability to use `{{did-insert}}` and `{{did-update}}`. You can also write your own modifiers! Keep reading below to learn more.\n\n#### Updating component state\n\nIf you previously did something like this in your `didReceiveAttrs` or\n`didUpdateAttrs` hooks:\n\n```js\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  didUpdateAttrs() {\n    this._super(...arguments);\n\n    if (this.disabled) {\n      // clear input value\n      this.set('value', '');\n    }\n  },\n\n  @action\n  updateValue(newValue) {\n    this.set('value', newValue);\n\n    if (this.onChange) {\n      this.onChange(newValue);\n    }\n  }\n});\n```\n\nYou can instead model this through getters and setters, deriving the value from\nthe state of your component:\n\n```js\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nexport default class TextComponent extends Component {\n  @tracked _value;\n\n  get value() {\n    if (this.args.disabled) {\n      return (this._value = '');\n    }\n\n    return this._value;\n  }\n\n  @action\n  updateValue(newValue) {\n    this._value = newValue;\n\n    if (this.args.onChange) {\n      this.args.onChange(newValue);\n    }\n  }\n}\n```\n\nYou'll notice that this getter is _mutating_ the value when the Text component\nis disabled. If this feels like a code smell to you, it probably is, and is a\nsign that we're managing state at the wrong level. In this case, for instance,\nwe should instead consider converting the text component to be a stateless\ncomponent, and mutate the value in the same place where the `disabled` is set:\nThe Parent component.\n\n```js\n// components/form.js\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nexport default class FormComponent extends Component {\n  @tracked text;\n  @tracked disabled;\n\n  @action\n  updateText(text) {\n    this.text = text;\n  }\n\n  @action\n  updateDisabled(disabled) {\n    this.disabled = disabled;\n\n    if (disabled) {\n      this.text = '';\n    }\n  }\n}\n```\n\n```handlebars\n{{!-- templates/components/form.hbs --}}\n<Text\n  @value={{this.text}}\n  @disabled={{this.disabled}}\n  @onChange={{this.updateText}}\n/>\n<button type=\"button\" {{on \"click\" (fn this.updateDisabled (not this.disabled))}}>\n  Toggle Disabled\n</button>\n```\n\n```js\nimport Component from '@glimmer/component';\n\nexport default class TextComponent extends Component {\n  @action\n  updateValue(newValue) {\n    if (this.args.onChange) {\n      this.args.onChange(newValue);\n    }\n  }\n}\n```\n\nNow the Text component doesn't have any internal state, it defers to the parent\nForm component, and when the Form component toggles its disabled state, it\nclears the state of the text. The mutation of state is centralized in the action\nwhere it occurs, making our program easier to reason about as a whole.\n\n#### DOM Manipulation\n\nIn cases when you were using the hooks to manipulate the DOM, you can instead\nupdate to use _modifiers_. For instance, let's say you were adding an event\nlistener to the `element` in your component's `didInsertElement` hook, and\nremoving it in `willDestroyElement`:\n\n```js\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  didInsertElement() {\n    this._super(...arguments);\n\n    this.listener = e => {\n      this.set('scrollOffset', e.clientY);\n    };\n\n    this.element.addEventListener(`scroll`, this.listener);\n  },\n\n  willDestroyElement() {\n    this.element.removeEventListener(`scroll`, this.listener);\n\n    this._super(...arguments);\n  }\n});\n```\n\nThis could be rewritten using the `{{did-insert}}` and `{{will-destroy}}`\nmodifiers, if you install [@ember/render-modifiers][2] in your app:\n\n[2]: https://github.com/emberjs/ember-render-modifiers\n\n```js {data-filename=app/components/scroll-component.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class ScrollComponent extends Component {\n  @tracked scrollOffset;\n\n  @action\n  listener(e) {\n    this.scrollOffset = e.clientY;\n  }\n\n  @action\n  registerListener(element) {\n    element.addEventListener('scroll', this.listener);\n  }\n\n  @action\n  unregisterListener(element) {\n    element.removeEventListener('scroll', this.listener);\n  }\n}\n```\n\n```handlebars {data-filename=app/components/scroll-component.hbs}\n<div\n  {{did-insert this.registerListener}}\n  {{will-destroy this.unregisterListener}}\n>\n  ...\n</div>\n```\n\nThese modifiers run the function passed to them when the _element_ they are\napplied to is inserted into or removed from the DOM. This makes the hooks\nexplicit in the element they are acting on. There is also a `did-update`\nmodifier, which does not run on insertion, but runs whenever any of its passed\nvalues _change_, allowing you to update the element:\n\n```js\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class ScrollComponent extends Component {\n  @action\n  setColor(element, color) {\n    element.style.color = color;\n  }\n}\n```\n\n```handlebars\n<div\n  {{did-insert this.setColor @color}}\n  {{did-update this.setColor @color}}\n>\n  ...\n</div>\n```\n\nThese three modifiers are basic modifiers that allow you to cover most of the\nfunctionality that lifecycle hooks contained.\n\n#### Writing your own modifiers\n\nThere are also community APIs available for writing your own modifiers, such as\n[ember-modifier](https://github.com/ember-modifier/ember-modifier).\nEmber itself has low level APIs known as _modifier managers_ which can be used\nto write these higher level APIs. In general, it's recommended to use a\ncommunity addon to write modifiers, and _not_ to write your own modifier\nmanager.\n\nLet's see what our first example would look like if we were to write it as a\nmodifier using `ember-modifier`:\n\n```js {data-filename=app/modifiers/add-event-listener.js}\nimport { modifier } from 'ember-modifier';\n\nexport default modifier((element, [eventName, listener]) => {\n  element.addEventListener(eventName, listener);\n\n  return () => element.removeEventListener(eventName, listener);\n});\n```\n\n```js {data-filename=app/components/scroll-component.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class ScrollComponent extends Component {\n  @tracked scrollOffset;\n\n  @action\n  listener(e) {\n    this.scrollOffset = e.clientY;\n  }\n}\n```\n\n```handlebars {data-filename=app/components/scroll-component.hbs}\n<div {{add-event-listener \"scroll\" this.listener}}>\n  ...\n</div>\n```\n\nThis modifier generalizes the functionality that the component implemented using\nlifecycle hooks before, so we can use this modifier whenever we need to in _any_\ncomponent. This is a much better solution than manually managing event listeners\nevery time we need one! At this point, the modifier is effectively the same as\nthe `{{on}}` modifier as well, so we could get rid of it altogether and replace\nit with `on`:\n\n```handlebars {data-filename=app/components/scroll-component.hbs}\n<div {{on \"scroll\" this.listener}}>\n  ...\n</div>\n```\n\n## Template-Only Components\n\nIn Octane, template-only components have only an `hbs` file and no `JavaScript` file.\n\nTemplate-only components have no backing class instance, so `this` in their\ntemplates is `null`. This means that you can only reference passed in arguments\nvia named argument syntax (e.g. `{{@arg}}`):\n\n```handlebars\n{{!--\n  This does not work, since `this` does not exist\n--}}\n<label for=\"title\">Title</label>\n<Input @value={{this.value}} id=\"title\" />\n```\n\nAdditionally, the `mut` helper generally can't be used for the same reason:\n\n```handlebars\n{{!-- This does not work --}}\n<input\n  value={{this.value}}\n  onkeyup={{action (mut this.value) target=\"value\"}}\n/>\n```\n\nSince Octane, a template-only component shares a subset of features that are available\nin `@glimmer/component`. Such component can be seamlessly \"upgraded\" to a Glimmer component,\nwhen you add a JavaScript file alongside the template.","description":"There's a new component API in Octane! For this section, we'll be focusing on the differences between the new style, known as Glimmer components, and classic components, and how to upgrade. \"Classic\" components refer to older-style components that do not..."}}}