{"data":{"type":"contents","id":"upgrading/current-edition/tracked-properties","attributes":{"content":"Tracked properties replace computed properties. Unlike computed properties, which require you to annotate\nevery getter with the values it depends on, tracked properties only require you to\nannotate the values that are _trackable_, that is values that:\n\n1. Change over the lifetime of their owner (such as a component) and\n2. May cause the DOM to update in response to those changes\n\nFor example, a computed property like this:\n\n```js\nimport EmberObject, { computed } from '@ember/object';\n\nconst Image = EmberObject.extend({\n  aspectRatio: computed('width', 'height', function() {\n    return this.width / this.height;\n  }),\n});\n```\n\nCould be rewritten as:\n\n```js\nimport { tracked } from '@glimmer/tracking';\n\nclass Image {\n  @tracked width;\n  @tracked height;\n\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\n```\n\nNotice how `aspectRatio` doesn't require _any_ annotation at all - it's a plain old\nnative getter, and it'll still work and invalidate if it's used anywhere in a\ntemplate, directly or indirectly.\n\nAn additional benefit is that you no longer have to use `set` to update these\nvalues, you can use standard JavaScript syntax instead!\n\n```js\n// Before\nlet profilePhoto = Image.create();\nprofilePhoto.set('width', 300);\nprofilePhoto.set('height', 300);\n```\n\n```js\n// After\nlet profilePhoto = new Image();\nprofilePhoto.width = 300;\nprofilePhoto.height = 300;\n```\n\n`@tracked` installs a native setter that tracks updates to these properties,\nallowing you to treat them like any other JS value.\n\nTracked properties have subtler benefits as well:\n\n- They enforce that all of the trackable properties in your classes are\n  annotated, making them easy to find. With computed properties, it was common\n  to have properties be \"implicit\" in a class definition, like in the example\n  above; the classic class version of `Image` doesn't have `width` and\n  `height` properties defined, but they are _implied_ by their existence as\n  dependencies in the `aspectRatio` computed property.\n- They enforce a \"public API\" of all values that are trackable in your class.\n  With computed properties, it was possible to watch _any_ value in a class for changes, and\n  there was nothing you as the class author could do about it. With tracked\n  properties, only the values you _want_ to be trackable will trigger updates\n  to anything external to your class.\n\nMost computed properties should be fairly straightforward to convert to tracked\nproperties. It's important to note that in these new components, arguments are\nautomatically tracked, but in classic components they are _not_. This is because\narguments are put on the `args` hash, which is tracked\nproperty. Since they are assigned to arbitrary properties on classic components,\nthey can't be instrumented ahead of time, so you must decorate them manually.\n\n#### Plain Old JavaScript Objects (POJOs)\n\nIt's not uncommon to use POJOs in Ember code for storing state, representing\nsome models, etc. This works because `get` and `set` can be used for any path,\non any object, whether or not its an `EmberObject`, and whether or not the\nproperty was declared in advance. This is part of what lead to the \"implicit\"\nproperty problem - you `set` any property you wanted on an existing object and it\nwould work.\n\nWith tracked properties this is _not_ possible, since each property must be\ninstrumented ahead of time, and decorators can only be applied in classes. In\ngeneral, the recommendation here is to convert usages of POJOs to native classes\nwherever possible:\n\n```js\n// Before\nimport EmberObject, { computed } from '@ember/object';\n\nconst Person = EmberObject.extend({\n  init() {\n    this.address = {};\n  },\n\n  fullAddress: computed('address.{street,city,region,country}', function() {\n    let { street, city, region, country } = this.address;\n\n    return `${street}, ${city}, ${region}, ${country}`;\n  }),\n});\n```\n\n```js\n// After\nimport { tracked } from '@glimmer/tracking';\n\nclass Address {\n  @tracked street;\n  @tracked city;\n  @tracked region;\n  @tracked country;\n}\n\nclass Person {\n  address = new Address();\n\n  get fullAddress() {\n    let { street, city, region, country } = this.address;\n\n    return `${street}, ${city}, ${region}, ${country}`;\n  }\n}\n```\n\nIn some cases, if your usage of properties on POJOs is too dynamic, you may not\nbe able to enumerate every single property that could be tracked. There could be\na prohibitive number of possible properties, or there could be no way to know\nthem in advance. In this case, it's recommended that you _reset_ the value\nwherever it is updated:\n\n```js\nclass SimpleCache {\n  @tracked _cache = {};\n\n  set(key, value) {\n    this._cache[key] = value;\n\n    // trigger an update\n    this._cache = this._cache;\n  }\n\n  get(key) {\n    return this._cache[key];\n  }\n}\n```\n\nTriggering an update like this will cause any getters that used the `_cache` to\nrecalculate. Note that we can use the `get` method to access the cache, and it\nwill still push the `_cache` tracked property.\n\n#### Arrays\n\nArrays are another example of a type of object where you can't enumerate every\npossible value - after all, there are an infinite number of integers (though you\n_may_ run out of bits in your computer at some point!). Instead, you can\ncontinue to use `EmberArray`, which will continue to work with tracking and will\ncause any dependencies that use it to invalidate correctly.\n\n```js\nimport { A } from '@ember/array';\n\nclass ShoppingList {\n  items = A([]);\n\n  addItem(item) {\n    this.items.pushObject(item);\n  }\n}\n```\n\n### Backwards Compatibility\n\nTracked properties are fully backwards compatible with computed properties and\n`get`/`set`. Computed properties can depend on tracked properties like any other\ndependency:\n\n```js\nimport { tracked } from '@glimmer/tracking';\nimport { computed } from '@ember/object';\n\nclass Image {\n  @tracked width;\n\n  @computed('width', 'height')\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\n\nlet profilePhoto = new Image();\n\n// This will correctly invalidate `aspectRatio`\nprofilePhoto.width = 200;\n```\n\nNote, however, that if you want to use a getter as a dependent key, you will\nneed to use the [`dependentKeyCompat`](https://api.emberjs.com/ember/release/functions/@ember%2Fobject%2Fcompat/dependentKeyCompat) decorator. This allows you to refactor\nexisting computed properties into getters without breaking existing code that\nobserves them.\n\nVice-versa, computed properties used in native getters will autotrack and\ncause the getter to update correctly:\n\n```js\nclass Image {\n  @computed('width', 'height')\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n\n  get helloMessage() {\n    return `Image aspect ratio is: ${this.aspectRatio}!`;\n  }\n}\n```\n\nLikewise, properties that are not decorated with `@tracked` that you get using\n`get` will also autotrack, and update later on when you use `set` to update\nthem:\n\n```js\nimport { get, set } from '@ember/object';\n\nclass Image {\n  get aspectRatio() {\n    let width = get(this, 'width');\n    let height = get(this, 'height');\n\n    return width / height;\n  }\n}\n\nlet profilePhoto = new Image();\nset(profilePhoto, 'width', 300);\nset(profilePhoto, 'height', 300);\n```\n\nHowever, you _must_ use `get` for these properties, since they are not tracked\nand there is no way to know in advance that they might be changed with `set`.\nFor instance, this will not work:\n\n```js\nimport { set } from '@ember/object';\n\nclass Image {\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\n\nlet profilePhoto = new Image();\nset(profilePhoto, 'width', 250);\nset(profilePhoto, 'height', 250);\n```\n\nAdditionally, certain Ember objects still require the use of `get` and `set`,\nsuch as `ObjectProxy` and `ArrayProxy`. These will continue to function with\ntracked, but you _must_ use `get` and `set`. Likewise, KVO methods on Ember's\n`Enumerable` class, such as `objectAt` and `pushObject`, and the various\nimplementations of it will _generally_ continue to be tracked.\n\nIf you have implemented your own version of an Ember `Enumerable`, or the\n`EmberArray` mixin, in general, you will need to add an additional step to your\nimplementation of `objectAt` in order for it to work with tracking:\n\n```js\nobjectAt() {\n  get(this, '[]');\n\n  // your implementation\n}\n```\n\nThis will push the tag for the `[]` property onto the autotrack stack, and that\nproperty is what is invalidated when the array is updated with KVO methods.\n\n## When to Use `get` and `set`\n\nHere are some cases where you still need to use `get` and `set`:\n\n- When accessing and updating plain properties on objects without decorators\n- When using Ember's `ObjectProxy` class, or a class that implements the\n  `unknownProperty` function (which allows objects to intercept `get` calls)\n- When accessing relationships for Ember Data records, e.g. \n`blogPost.get('comments')`. Under the hood, this is a type of `ObjectProxy`.\n\nAdditionally, you will have to continue using _accessor_ functions for arrays if\nyou want arrays to update as expected.\nThese functions are covered in more detail in the [Looping Through Lists](../../../components/looping-through-lists/) guide.\n\nImportantly, you do _not_ have to use `get` or `set` when reading or updating\ncomputed properties, as was noted in the computed property section.\n\nIn the sections below, you will learn why these methods are still needed,\nand review some detailed examples of `ObjectProxy` and plain objects.\n\n### Background information\n\nWhy do developers still need to use `get` and `set` in some places?\n\nEmber's classic change tracking system used two methods to ensure that all data\nwas accessed properly and updated correctly: `get` and `set`.\n\n```js\nimport { get, set } from '@ember/object';\n\nlet image = {};\n\nset(image, 'width', 250);\nset(image, 'height', 500);\n\nget(image, 'width'); // 250\nget(image, 'height'); // 500\n```\n\nIn classic Ember, all property access had to go through these two methods. Over\ntime, these rules have become less strict, and now they have been minimized to\njust the few cases mentioned in this section.\nIn general, in a modern Ember app, you shouldn't need to use\nthem all that much. As long as you are marking your properties as `@tracked`,\nEmber should automatically figure out what needs to change, and when.\n\n### Plain Properties\n\nIn general, if a value in your application could update, and that update should\ntrigger rerenders, then you should mark that value as `@tracked`. This\noftentimes may mean taking a POJO and turning it into a class, but this is\nusually better because it forces us to _rationalize_ the object - think about\nwhat its API is, what values it has, what data it represents, and define that in\na single place.\n\nHowever, there are times when data is _too_ dynamic. As noted below, proxies are\noften used for this type of data, but usually they're overkill. Most of the\ntime, all we want is a POJO.\n\nIn those cases, you can still use `get` and `set` to read and update state from\nPOJOs within your getters, and these will track automatically and trigger\nupdates.\n\n```js\nclass Profile {\n  photo = {\n    width: 300,\n    height: 300,\n  };\n\n  get photoAspectRatio() {\n    return get(this.photo, 'width') / get(this.photo, 'height');\n  }\n}\n\nlet profile = new Profile();\n\n// render the page...\n\nset(profile.photo, 'width', 500); // triggers an update\n```\n\nThis is also useful when working with older Ember code which has not yet\nbeen updated to tracked properties. If you're unsure, you can use `get` and\n`set` to be safe.\n\n### `ObjectProxy`\n\nEmber has and continues to support an implementation of a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy),\nwhich is a type of object that can _wrap around_ other objects and _intercept_\nall of your gets and sets to them. Native JavaScript proxies allow you to do\nthis without any special methods or syntax, but unfortunately they are not\navailable in IE11. Since many Ember users must still support IE11, Ember's\n`ObjectProxy` class allows us to accomplish something similar.\n\nThe use cases for proxies are generally cases where some data is very dynamic,\nand its not possible to know ahead of time how to create a class that is\ndecorated. For instance, [`ember-m3`](https://github.com/hjdivad/ember-m3) is an\naddon that allows Ember Data to work with dynamically generated models instead\nof models defined using `@attr`, `@hasMany`, and `@belongsTo`. This cuts back on\ncode shipped to the browser, but it means that the models have to _dynamically_\nwatch and update values. A proxy allows all accesses and updates to be\nintercepted, so `m3` can do what it needs to do without predefined classes.\n\nMost `ObjectProxy` classes have their own `get` and `set` method on them, like\n`EmberObject` classes. This means you can use them directly on the class\ninstance:\n\n```js\nproxy.get('width');\nproxy.set('width', 100);\n```\n\nIf you're unsure whether or not a given object will be a proxy or not, you can\nstill use Ember's `get` and `set` functions:\n\n```js\nget(maybeProxy, 'width');\nset(maybeProxy, 'width', 100);\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"Tracked properties replace computed properties. Unlike computed properties, which require you to annotate every getter with the values it depends on, tracked properties only require you to annotate the values that are trackable, that is values that: \n\n1..."}}}