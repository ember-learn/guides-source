{"data":{"type":"contents","id":"upgrading/current-edition/action-on-and-fn","attributes":{"content":"Octane provides a set of new conventional APIs for creating and adding event\nhandlers and actions to your components and templates:\n\n* The `@action` decorator\n* The `{{on}}` modifier\n* The `{{fn}}` helper\n\nThese are meant to replace the `{{action}}` helper/modifier, which will be\ndeprecated in the future. You can use them like this:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class TodoComponent extends Component {\n  @action\n  toggleCompleted(isComplete) {\n    // ...\n  }\n}\n```\n\n```handlebars\n<button type=\"button\" {{on \"click\" (fn this.toggleCompleted true)}}>Complete</button>\n```\n\n## Benefits of `@action`, `{{on}}`, and `{{fn}}`\n\n`{{action}}` has a number of functions, including:\n\n* Creating action callbacks, which bind the _context_ of the callback (the\n  component/controller).\n* Adding arguments to action callbacks:\n\n  ```handlebars\n    <!-- passes 123 to the 'setValue' action -->\n    <MyComponent @onClick={{action 'setValue' 123}} />\n  ```\n\n* Adding event handlers to elements (when used as a modifier):\n\n  ```handlebars\n    <button type=\"button\" {{action 'sayHello'}}>Say Hello!</button>\n  ```\n\nThe new APIs split each of these pieces of functionality out into one clearly\ndefined API:\n\n* `@action` is a decorator that binds a method to the context its used in\n* `{{on}}` is a modifier that's used to add event listeners to DOM elements\n* `{{fn}}` is a helper that adds arguments to another function or callback\n\nThis keeps the responsibilities clearly delineated, and makes it much easier to\nreason about what each individual API is doing.\n\n## Getting used to `@action`, `{{on}}`, and `{{fn}}`\n\n### The `@action` Decorator\n\nIn Ember Octane, actions are no longer defined on the `actions` object of a\ncomponent or controller. Instead, they are standard class methods decorated with\nthe `@action` decorator.\n\nBefore:\n\n```javascript\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  actions: {\n    doSomething() {\n      // ...\n    }\n  }\n})\n```\n\nAfter:\n\n```javascript\nimport Component from '@glimmer/component';\n\nexport default class ExampleComponent extends Component {\n  @action\n  doSomething() {\n    // ...\n  }\n}\n```\n\nThe decorator leaves the method intact without any changes, so you can continue\nto use it like a normal method. This also means that you can reference the\naction directly in templates, instead of using strings.\n\nBefore:\n\n```handlebars\n<button type=\"button\" {{action \"doSomething\"}}>Click Me!</button>\n```\n\nAfter:\n\n```handlebars\n<button type=\"button\" {{on \"click\" this.doSomething}}>Click Me!</button>\n```\n\nThe decorator _is_ important, as it binds the action directly to the class so it\ncan reference it later on.\n\n### The `{{on}}` Modifier\n\nThe API for `{{on}}` is the same as JavaScript's native [`addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener). It receives the event name as the first argument, and a\ncallback function as the second argument:\n\n```handlebars\n<button type=\"button\" {{on \"click\" this.handleClick}}>Click Me!</button>\n```\n\nThe event can be _any_ event name, not just the `click` event, which makes\n`{{on}}` perfect for handling any kind of DOM event. For a list of native\nbrowser events, see the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/Events).\nThe callback function will receive the event as its first argument:\n\n```javascript\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class ExampleComponent extends Component {\n  @action\n  handleClick(event) {\n    event.preventDefault();\n  }\n}\n```\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        The <code>{{action}}</code> modifier called <code>event.preventDefault()</code> under the hood, but the <code>{{on}}</code> modifier does not, so if you need to do anything other than the default action for a particular event, you must call <code>event.preventDefault</code> within the action.\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div> \n\nThis is a replacement for `{{action}}` when it is used as a modifier:\n\n```handlebars\n<!-- Before -->\n<button type=\"button\" {{action 'handleClick'}}>Click Me!</button>\n<button type=\"button\" {{action 'handleDoubleClick' on=\"doubleClick\"}}>Double Click Me!</button>\n\n<!-- After -->\n<button type=\"button\" {{on \"click\" this.handleClick}}>Click Me!</button>\n<button type=\"button\" {{on \"dblclick\" this.handleDoubleClick}}>Double Click Me!</button>\n```\n\nYou can also pass additional options such as `passive` and `once` as named\nparameters to the modifier:\n\n```handlebars\n<button type=\"button\" {{on \"click\" this.handleClick passive=true}}>Click Me!</button>\n```\n\nIf you ever used the `value` parameter of `{{action}}`, there is no direct\nequivalent for `{{on}}`. You should instead write an action that gets the value\nfor you.\n\nBefore:\n\n```handlebars\n<input value={{this.value}} onchange={{action (mut this.value) value=\"target.value\"}} />\n```\n\nAfter:\n\n```handlebars\n<input value={{this.value}} {{on \"change\" this.updateValue}} />\n```\n```javascript\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class ExampleComponent extends Component {\n  @tracked value;\n\n  @action\n  updateValue(event) {\n    this.value = event.target.value;\n  }\n}\n```\n\nIf you want to pass additional parameters to the callback function, you must use\nthe `{{fn}}` helper. `{{on}}` does not receive any additional parameters.\n\n### The `{{fn}}` Helper\n\n`{{fn}}` is a helper that receives a function and some arguments, and returns\na new function that combines. This allows you to pass parameters along to\nfunctions in your templates:\n\n```handlebars\n<button type=\"button\" {{on \"click\" (fn this.handleClick 123)}}>Click Me!</button>\n```\n\n```javascript\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class ExampleComponent extends Component {\n  @action\n  handleClick(value) {\n    console.log(value); // 123\n  }\n}\n```\n\nThis is a replacement for passing parameters to the `{{action}}` modifier or\nhelper:\n\n```handlebars\n<!-- Before -->\n<button type=\"button\" {{action 'handleClick' 123}}>Click Me!</button>\n<MyComponent @onClick={{action 'handleClick' 123}} />\n\n<!-- After -->\n<button type=\"button\" {{on \"click\" (fn this.handleClick 123)}}>Click Me!</button>\n<MyComponent @onClick={{fn this.handleClick 123}} />\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"Octane provides a set of new conventional APIs for creating and adding event handlers and actions to your components and templates: \n\n- The @action decorator\n- The {{on}} modifier\n- The {{fn}} helper \n\nThese are meant to replace the {{action}}..."}}}