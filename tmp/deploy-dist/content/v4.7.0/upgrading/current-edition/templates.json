{"data":{"type":"contents","id":"upgrading/current-edition/templates","attributes":{"content":"There are two significant changes to templates in Octane compared to classic Ember:\n\n1. Angle Bracket Syntax\n2. Named Arguments\n\nNote that this guide assumes your app is on version 4.x of Ember. If you are on an older\nversion, please choose it from the dropdown in the sidebar.\n## Angle Bracket Syntax\n\nWhen you are using a component in a template, you can invoke it using Angle Brackets (`<...>`) instead of curly braces (`{{...}}`).\nThe component itself will work the same as it did before.\n\n```handlebars\n{{!-- Before --}}\n{{#todo-list as |item|}}\n  {{to-do item=item}}\n{{/todo-list}}\n\n{{!-- After --}}\n<TodoList as |item|>\n  <Todo @item={{item}} />\n</TodoList>\n```\n\n### Benefits of Angle Brackets\n\nAngle Brackets have a number of benefits:\n\n- Single word component names are completely OK in angle bracket form.\n\n- It is clear to your collaborators you are using a component and not a helper in a template.\n\n- Standard attribute values applied to the component are treated like _plain-old\n  HTML attributes_. This means you can assign any valid HTML attribute, and it\n  will be reflected onto the component directly:\n\n```handlebars\n  <Todo\n    role=\"list-item\"\n    data-test-todo-item\n    data-test-id={{this.todo.id}}\n    class=\"todo {{this.todoClass}}\"\n  />\n```\n\nAs you can see, both literal and bound values can be set on attributes, and\nattributes can be used _without_ setting a value at all, just like HTML\nattributes. The component you are invoking decides where to put these attributes\nby using the special `...attributes` syntax. This will be discussed later in\nthe section on components.\n\nFor classic components, only attributes that were explicitly listed by the component\nyou are invoking would be placed on the component's wrapper element.\n\n- _Arguments_ and _attributes_ are distinguished from each other when using a\n  component. With curly brace style components, every value you pass to the\n  component is an _argument_ - a JS value that is passed to the component class\n  so it can be used in the component's template:\n\n  ```handlebars\n  {{!-- In this example, `value` is an argument --}}\n  {{custom-input value=this.text}}\n  ```\n\n  With angle brackets, since you can pass standard HTML attributes to the\n  component directly, we need a way to distinguish between those and the\n  component's arguments. To do this, we use the `@` symbol:\n\n  ```handlebars\n  <CustomInput @value={{this.text}} />\n  ```\n\n  This allows you to see at a glance whether a value is an argument, which will\n  likely affect the JS of a component, or an attribute, which will likely affect\n  the HTML of a component.\n\n### Getting used to Angle Brackets\n\nHere are the main differences between angle bracket and curly syntax:\n\n- The component name is in `CapitalCase` instead of `kebab-case`.\n  `{{my-component}}` becomes `<MyComponent />`.\n\n- Components open and close in the same way as HTML elements. Components that do\n  not accept a block can use the self closing syntax (a trailing slash) just\n  like `<img />` or other tags.\n\n- _Arguments_ are passed by adding `@` to the front of the argument name:\n\n  ```handlebars\n    {{!-- Before --}}\n    {{todo-item item=item}}\n\n    {{!-- After --}}\n    <TodoItem @item={{this.item}} />\n  ```\n\n- When you pass a bound value to a component, remember that it needs to be\n  wrapped in curly braces:\n\n  ```handlebars\n    <Todo @done={{this.isDone}} />\n  ```\n\n  Like HTML, all values for attributes that are not wrapped in strings are\n  coerced to strings. If you want to pass a boolean or number to a component and\n  _not_ have it coerced to a string, wrap it in curly braces:\n\n  ```handlebars\n    <Todo @done={{false}} maxItems={{10}} />\n  ```\n\n- Yielded values work the same as in curly invocation:\n\n  ```handlebars\n    <TodoList as |item|>\n      <Todo @item={{item}} />\n    </TodoList>\n  ```\n\n- Yielded components can also be invoked with angle bracket syntax:\n\n  ```handlebars\n    <TodoList as |Item|>\n      <Item />\n    </TodoList>\n  ```\n\n- Positional arguments (e.g. `{{my-component this.someValue}}`) are _not_\n  available in angle bracket invocation, since there is some ambiguity between\n  their behavior and the behavior of standard HTML attributes (HTML attributes\n  without `=` default to truthy). If you still need positional arguments, you\n  _must_ use the component with curly bracket syntax.\n\n  If you are updating a classic component to use angle bracket syntax, you can\n  also overwrite the parameter array with a named argument instead. For\n  instance, if `my-greeting` had the following implementation:\n\n  ```javascript {data-filename=\"app/components/my-greeting.js\"}\n    import Component from '@ember/component';\n\n    export default Component.extend({\n    }).reopenClass({\n      positionalParams: 'params'\n    });\n  ```\n\n  To invoke it using angle bracket syntax, you would do the following:\n\n  ```handlebars\n  <MyGreeting @params={{array \"Hello\" \"World\"}}>\n  ```\n\n- You can use either angle bracket or curly brackets invocation for a given\n  component within the same app, and even within the same template. This allows\n  for gradual migration.\n\n- Angle bracket syntax works for invoking components of any type, whether they\n  are classic components, Glimmer components, or any other type of component.\n\n- Curly syntax is still appropriate for some types of components! Check out\n  [`ember-control-flow-component`](https://github.com/tildeio/ember-control-flow-component)\n  for an alternative to Glimmer components and angle bracket syntax for such\n  components.\n\n## Named Arguments\n\nWith angle brackets, there is a new syntax for passing arguments to a component:\n\n```handlebars {data-filename=application.hbs}\n{{!-- Passing the argument to the BlogPost component --}}\n<BlogPost @title=\"Hello, world!\"/>\n```\n\nWithin the component, you can now access these arguments _directly_ with the\nsame syntax:\n\n```handlebars {data-filename=blog-post.hbs}\n{{!-- inside the BlogPost component --}}\n<h1>{{@title}}</h1>\n```\n\nCollectively, this is referred to as _named arguments_.\n\n### Benefits of Named Arguments\n\nNamed Arguments have a number of benefits:\n\n- When you see a named argument used in a component's template, you can tell\n  immediately that it is a value that was passed to the component, without\n  looking at the component's class.\n\n- Named arguments always refer to the original value that was passed to the\n  component, so you can also be sure that the value was never mutated by the\n  component's class.\n\n- Teams can gradually refactor an app to use named arguments, separately from\n  upgrading to angle bracket invocation. You don't need to worry about whether\n  the parent used angle brackets or curly brackets. For example, this works just\n  fine:\n\n  ```handlebars {data-filename=application.hbs}\n    {{blog-post title=\"Hello, world!\"}}\n  ```\n\n  ```handlebars {data-filename=blog-post.hbs}\n    {{!-- This still works --}}\n    <h1>{{@title}}</h1>\n  ```\n\n### Getting used to Named Arguments\n\nThe most important thing to know about named argument syntax is that an argument\nwith an `@` _always_ refers to the _original_ value that was passed when the\ncomponent was invoked. If you change that value in a classic component, it will\n_not_ update:\n\n```js {data-filename=blog-post.js}\nimport Component from '@ember/component';\n\nexport default Component.extend({\n  init() {\n    this.set('title', this.title.toUpperCase());\n  },\n});\n```\n\n```handlebars {data-filename=blog-post.hbs}\n{{!-- This is still the original title, \"Hello, world!\" --}}\n<h1>{{@title}}</h1>\n\n{{!-- This is the uppercased title, \"HELLO, WORLD!\" --}}\n<h1>{{this.title}}</h1>\n```\n\nIf you need to provide a default value, you'll have to do it via a getter:\n\n```js {data-filename=blog-post.js}\nimport Component from '@glimmer/component';\n\nexport default class BlogPostComponent extends Component {\n  get title() {\n    return this.args.title || 'Untitled';\n  }\n}\n```\n\n```handlebars {data-filename=blog-post.hbs}\n<h1>{{this.title}}</h1>\n```\n\n> Note: The above sample uses Glimmer components - we'll be covering these in\n> detail later on.\n\nOr by using a helper in the template:\n\n```handlebars {data-filename=blog-post.hbs}\n{{!-- using {{or}} from ember-truth-helpers --}}\n<h1>{{or @title \"Untitled\"}}</h1>\n```\n\nIf you find yourself forgetting to add the `@` symbol before named arguments, it\nmay be helpful to think of how the child template mirrors argument being passed\ninto a component via angle bracket invocation.","description":"There are two significant changes to templates in Octane compared to classic Ember: \n\n1. Angle Bracket Syntax\n2. Named Arguments \n\nNote that this guide assumes your app is on version 4.x of Ember. If you are on an older version, please choose it from the..."}}}