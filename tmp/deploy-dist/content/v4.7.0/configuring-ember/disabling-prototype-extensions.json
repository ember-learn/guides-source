{"data":{"type":"contents","id":"configuring-ember/disabling-prototype-extensions","attributes":{"content":"By default, Ember.js will extend the prototypes of native JavaScript\narrays to implement the `Ember.Enumerable`, `Ember.MutableEnumerable`,\n`Ember.MutableArray` and `Ember.Array` interfaces. This polyfills\nECMAScript 5 array methods in browsers that do not implement them, adds\nconvenience methods and properties to built-in arrays, and makes array\nmutations observable.\n\nThis is the extent to which Ember.js enhances native prototypes. We have\ncarefully weighed the trade-offs involved with changing these prototypes,\nand recommend that most Ember.js developers use them. These extensions\nsignificantly reduce the amount of boilerplate code that must be typed.\n\nHowever, we understand that there are cases where your Ember.js\napplication may be embedded in an environment beyond your control. The\nmost common scenarios are when authoring third-party JavaScript that is\nembedded directly in other pages, or when transitioning an application\npiecemeal to a more modern Ember.js architecture.\n\nIn those cases, where you can't or don't want to modify native\nprototypes, Ember.js allows you to completely disable the extensions\ndescribed above.\n\nTo do so, simply set the `EmberENV.EXTEND_PROTOTYPES` flag to `false`:\n\n```javascript {data-filename=config/environment.js}\nENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: false\n  }\n}\n```\n\nYou can configure which classes to include prototype extensions\nfor in your application's configuration like so:\n\n```javascript {data-filename=config/environment.js}\nENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: {\n      Array: false\n    }\n  }\n}\n```\n\n## Life Without Prototype Extension\n\nIn order for your application to behave correctly, you will need to\nmanually extend or create the objects that the native objects were\ncreating before.\n\n### Arrays\n\nNative arrays will no longer implement the functionality needed to\nobserve them. If you disable prototype extension and attempt to use\nnative arrays with things like a template's `{{#each}}` helper, Ember.js\nwill have no way to detect changes to the array and the template will\nnot update as the underlying array changes.\n\nYou can manually coerce a native array into an array that implements the\nrequired interfaces using the convenience method `Ember.A`:\n\n```javascript\nimport { A } from '@ember/array';\n\nlet islands = ['Oahu', 'Kauai'];\nislands.pushObject('Maui');\n// => TypeError: Object Oahu,Kauai has no method `pushObject`\n\n// Convert `islands` to an array that implements the\n// Ember enumerable and array interfaces\nA(islands);\n\nislands.pushObject('Maui');\n// => ['Oahu', 'Kauai', 'Maui'];\n```\n\nYou can also use an \"immutable update\" style with tracked properties:\n\n```javascript\nimport { tracked } from '@glimmer/tracking';\n\nclass Ocean {\n  @tracked islands = ['Oahu', 'Kauai'];\n  \n  addIsland(newIsland) {\n    this.islands = this.islands.concat(newIsland);\n  }\n}\n\nconst ocean = new Ocean();\nocean.addIsland('Maui');\nocean.islands; // => ['Oahu', 'Kauai', 'Maui'];\n```\n\nAlternatively, you can use the community library `tracked-built-ins`\nto get a natively tracked version of `Array`, and use native `Array`\nmethods with auto-tracking reactivity:\n\n```javascript\nimport { TrackedArray } from 'tracked-built-ins';\n\nlet islands = new TrackedArray(['Oahu', 'Kauai']);\nislands.push('Maui');\n// => ['Oahu', 'Kauai', 'Maui'];\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"By default, Ember.js will extend the prototypes of native JavaScript arrays to implement the Ember.Enumerable, Ember.MutableEnumerable, Ember.MutableArray and Ember.Array interfaces. This polyfills ECMAScript 5 array methods in browsers that do not..."}}}