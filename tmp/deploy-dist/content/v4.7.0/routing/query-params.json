{"data":{"type":"contents","id":"routing/query-params","attributes":{"content":"Query parameters are optional key-value pairs that appear to the right of\nthe `?` in a URL. For example, the following URL has two query params,\n`sort` and `page`, with respective values `ASC` and `2`:\n\n```text\nhttp://example.com/articles?sort=ASC&page=2\n```\n\nQuery params allow for additional application state to be serialized\ninto the URL that can't otherwise fit into the _path_ of the URL (i.e.\neverything to the left of the `?`). Common use cases for query params include\nrepresenting the current page number in a paginated collection, filter criteria, or sorting criteria.\n\nIn web development, query parameters are used within a URL as described above but can also be used\nin API requests that retrieve data. Ember treats these as _two_ different concepts. This section\ndescribes how routing query parameters are used in Ember. See [finding records](../../models/finding-records/#toc_querying-for-multiple-records) to see how query parameters are\napplied to API requests in Ember Data.\n\n### Specifying Query Parameters\n\nQuery params are declared on route-driven controllers. For example, to\nconfigure query params that are active within the `articles` route,\nthey must be declared on `controller:articles`.\n\nTo add a `category`\nquery parameter that will filter out all the articles that haven't\nbeen categorized as popular we'd specify `'category'`\nas one of `controller:articles`'s `queryParams`:\n\n```javascript {data-filename=app/controllers/articles.js}\nimport Controller from '@ember/controller';\n\nexport default class ArticlesController extends Controller {\n  queryParams = ['category'];\n  \n  category = null;\n}\n```\n\nThis sets up a binding between the `category` query param in the URL,\nand the `category` property on `controller:articles`. In other words,\nonce the `articles` route has been entered, any changes to the\n`category` query param in the URL will update the `category` property\non `controller:articles`, and vice versa.\nNote that you can't make `queryParams` be a dynamically generated property (neither computed property, nor property getter); they\nhave to be values.\n\nNow we need to define a getter for our category-filtered\narray, which the `articles` template will render. For the getter to recompute when values change, `category` and `model` should be marked as tracked properties:\n\n```javascript {data-filename=app/controllers/articles.js}\nimport Controller from '@ember/controller';\nimport { tracked } from '@glimmer/tracking';\n\nexport default class ArticlesController extends Controller {\n  queryParams = ['category'];\n  \n  @tracked category = null;\n\n  @tracked model;\n\n  get filteredArticles() {\n    let category = this.category;\n    let articles = this.model;\n\n    if (category) {\n      return articles.filterBy('category', category);\n    } else {\n      return articles;\n    }\n  }\n}\n```\n\nWith this code, we have established the following behaviors:\n\n1. If the user navigates to `/articles`, `category` will be `null`, so\n   the articles won't be filtered.\n2. If the user navigates to `/articles?category=recent`,\n   `category` will be set to `\"recent\"`, so articles will be filtered.\n3. Once inside the `articles` route, any changes to the `category`\n   property on `controller:articles` will cause the URL to update the\n   query param. By default, a query param property change won't cause a\n   full router transition (i.e. it won't call `model` hooks and\n   `setupController`, etc.); it will only update the URL.\n\n### <LinkTo /> component\n\nThe `<LinkTo />` component supports specifying query params using the `@query`\nargument, along with the `{{hash}}` helper:\n\n```handlebars\n// Explicitly set target query params\n<LinkTo @route=\"posts\" @query={{hash direction=\"asc\"}}>Sort</LinkTo>\n\n// Binding is also supported\n<LinkTo @route=\"posts\" @query={{hash direction=this.otherDirection}}>Sort</LinkTo>\n\n```\n\nIn the above examples, `direction` is presumably a query param property\non the `posts` controller, but it could also refer to a `direction` property\non any of the controllers associated with the `posts` route hierarchy,\nmatching the leaf-most controller with the supplied property name.\n\nThe `<LinkTo />` component takes into account query parameters when determining\nits \"active\" state, and will set the class appropriately. The active state\nis determined by calculating whether the query params end up the same after\nclicking a link. You don't have to supply all of the current,\nactive query params for this to be true.\n\n### transitionTo\n\n`Router#transitionTo` accepts a final argument, which is an object with the key `queryParams`.\n\n```javascript {data-filename=app/routes/some-route.js}\nthis.router.transitionTo('post', object, { queryParams: { showDetails: true }});\nthis.router.transitionTo('posts', { queryParams: { sort: 'title' }});\n\n// if you want to transition the query parameters without changing the route\nthis.router.transitionTo({ queryParams: { direction: 'asc' }});\n```\n\nYou can also add query params to URL transitions:\n\n```javascript {data-filename=app/routes/some-route.js}\nthis.router.transitionTo('/posts/1?sort=date&showDetails=true');\n```\n\n### Opting into a full transition\n\nWhen you change query params through a transition (`transitionTo` and `<LinkTo />`),\nit is not considered a full transition.\nThis means that the controller properties associated with the query params will be updated,\nas will the URL, but no `Route` method hook like `model` or `setupController` will be called.\n\nIf you need a query param change to trigger a full transition, and thus the method hooks,\nyou can use the optional `queryParams` configuration hash on the `Route`.\nIf you have a `category` query param and you want it to trigger a model refresh,\nyou can set it as follows:\n\n```javascript {data-filename=app/routes/articles.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\n\nexport default class ArticlesRoute extends Route {\n  @service store;\n\n  queryParams = {\n    category: {\n      refreshModel: true\n    }\n  };\n\n  model(params) {\n    // This gets called upon entering 'articles' route\n    // for the first time, and we opt into refiring it upon\n    // query param changes by setting `refreshModel:true` above.\n\n    // params has format of { category: \"someValueOrJustNull\" },\n    // which we can forward to the server.\n    return this.store.query('article', params);\n  }\n}\n```\n\n```javascript {data-filename=app/controllers/articles.js}\nimport Controller from '@ember/controller';\n\nexport default class ArticlesController extends Controller {\n  queryParams = ['category'];\n  \n  category = null;\n}\n```\n\n### Update URL with `replaceState` instead\n\nBy default, Ember will use `pushState` to update the URL in the\naddress bar in response to a controller query param property change.\nIf you would like to use `replaceState` instead, which prevents an\nadditional item from being added to your browser's history,\nyou can specify this as follows:\n\n```javascript {data-filename=app/routes/articles.js}\nimport Route from '@ember/routing/route';\n\nexport default class ArticlesRoute extends Route {\n  queryParams = {\n    category: {\n      replace: true\n    }\n  };\n}\n```\n\nThis behavior is similar to `<LinkTo />`,\nwhich also lets you opt into a `replaceState` transition via `replace=true`.\n\n### Map a controller's property to a different query param key\n\nBy default, specifying `foo` as a controller query param property will\nbind to a query param whose key is `foo`, e.g. `?foo=123`.\nYou can also map a controller property to a different query param key using the following configuration syntax:\n\n```javascript {data-filename=app/controllers/articles.js}\nimport Controller from '@ember/controller';\n\nexport default class ArticlesController extends Controller {\n  queryParams = [{\n    category: 'articles_category'\n  }];\n\n  category = null;\n}\n```\n\nThis will cause changes to the `controller:articles`'s `category`\nproperty to update the `articles_category` query param, and vice versa.\n\nQuery params that require additional customization can\nbe provided along with strings in the `queryParams` array.\n\n```javascript {data-filename=app/controllers/articles.js}\nimport Controller from '@ember/controller';\n\nexport default class ArticlesController extends Controller {\n  queryParams = ['page', 'filter', {\n    category: 'articles_category'\n  }];\n\n  category = null;\n  page = 1;\n  filter = 'recent';\n}\n```\n\n### Default values and deserialization\n\nIn the following example,\nthe controller query param property `page` is considered to have a default value of `1`.\n\n```javascript {data-filename=app/controllers/articles.js}\nimport Controller from '@ember/controller';\n\nexport default class ArticlesController extends Controller {\n  queryParams = ['page'];\n  \n  page = 1;\n}\n```\n\nThis affects query param behavior in two ways:\n\n1. Query param values are cast to the same datatype as the default\n   value, e.g. a URL change from `/?page=3` to `/?page=2` will set\n   `controller:articles`'s `page` property to the number `2`, rather than\n   the string `\"2\"`. The same also applies to boolean default values. If the\n   default value is an array, the string will be parsed using `JSON.parse`.\n2. When a controller's query param property is currently set to its\n   default value, this value won't be serialized into the URL. So in the\n   above example, if `page` is `1`, the URL might look like `/articles`,\n   but once someone sets the controller's `page` value to `2`, the URL\n   will become `/articles?page=2`.\n\n### Sticky Query Param Values\n\nThe query params are defined per route/controller. They are not global to the app. \nFor example, if a route `first-route` has a query param `firstParam` associated with it and we try to navigate to `first-route` by using `<LinkTo />` component from a different route `second-route`, like in the following handlebar template, the `firstParam` will be omitted.\n\n```handlebars\n<LinkTo @route=\"first-route\" @query={{hash secondParam=\"asc\"}}>Sort</LinkTo>\n```\n\nBy default, query param values in Ember are \"sticky\",\nin that if you make changes to a query param and then leave and re-enter the route,\nthe new value of that query param will be preserved (rather than reset to its default).\nThis is a particularly handy default for preserving sort/filter parameters as you navigate back and forth between routes.\n\nFurthermore, these sticky query param values are remembered/restored according to the model loaded into the route.\nSo, given a `team` route with dynamic segment `/:team_name` and controller query param \"filter\",\nif you navigate to `/badgers` and filter by `\"rookies\"`,\nthen navigate to `/bears` and filter by `\"best\"`,\nand then navigate to `/potatoes` and filter by `\"worst\"`,\nthen given the following nav bar links:\n\n```handlebars\n<LinkTo @route=\"team\" @model=\"badgers\">Badgers</LinkTo>\n<LinkTo @route=\"team\" @model=\"bears\">Bears</LinkTo>\n<LinkTo @route=\"team\" @model=\"potatoes\">Potatoes</LinkTo>\n```\n\nthe generated links would be:\n\n```html\n<a href=\"/badgers?filter=rookies\">Badgers</a>\n<a href=\"/bears?filter=best\">Bears</a>\n<a href=\"/potatoes?filter=worst\">Potatoes</a>\n```\n\nThis illustrates that once you change a query param,\nit is stored and tied to the model loaded into the route.\n\nIf you wish to reset a query param, you have two options:\n\n1. explicitly pass in the default value for that query param into\n   `<LinkTo />` or `transitionTo`.\n2. use the `Route.resetController` hook to set query param values back to\n   their defaults before exiting the route or changing the route's model.\n\nIn the following example, the controller's `page` query param is reset to 1,\n_while still scoped to the pre-transition `ArticlesRoute` model_.\nThe result of this is that all links pointing back into the exited route will use the newly reset value `1` as the value for the `page` query param.\n\n```javascript {data-filename=app/routes/articles.js}\nimport Route from '@ember/routing/route';\n\nexport default class ArticlesRoute extends Route {\n  resetController(controller, isExiting, transition) {\n    if (isExiting) {\n      // isExiting would be false if only the route's model was changing\n      controller.set('page', 1);\n    }\n  }\n}\n```\n\nIn some cases, you might not want the sticky query param value to be\nscoped to the route's model but would rather reuse a query param's value\neven as a route's model changes. This can be accomplished by setting the\n`scope` option to `\"controller\"` within the controller's `queryParams`\nconfig hash:\n\n```javascript {data-filename=app/controllers/articles.js}\nimport Controller from '@ember/controller';\n\nexport default class ArticlesController extends Controller {\n  queryParams = [{\n    showMagnifyingGlass: {\n      scope: 'controller'\n    }\n  }];\n}\n```\n\nThe following demonstrates how you can override both the scope and the query param URL key of a single controller query param property:\n\n```javascript {data-filename=app/controllers/articles.js}\nimport Controller from '@ember/controller';\n\nexport default class ArticlesController extends Controller {\n  queryParams = ['page', 'filter', {\n    showMagnifyingGlass: {\n      scope: 'controller',\n      as: 'glass'\n    }\n  }];\n}\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"Query parameters are optional key-value pairs that appear to the right of the ? in a URL. For example, the following URL has two query params, sort and page, with respective values ASC and 2: \n\nhttp://example.com/articles?sort=ASC&page=2  \n\nQuery params..."}}}