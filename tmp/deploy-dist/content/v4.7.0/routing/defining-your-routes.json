{"data":{"type":"contents","id":"routing/defining-your-routes","attributes":{"content":"When your application starts, the router matches the current URL to the _routes_\nthat you've defined. The routes, in turn, are responsible for displaying\ntemplates, loading data, and setting up application state.\n\nTo define a route, run\n\n```bash\nember generate route route-name\n```\n\nThis creates a route file at `app/routes/route-name.js`, a template for the route at `app/templates/route-name.hbs`,\nand a unit test file at `tests/unit/routes/route-name-test.js`.\nIt also adds the route to the router.\n\n## Basic Routes\n\nThe [`map()`](https://api.emberjs.com/ember/release/classes/EmberRouter/methods/map?anchor=map) method\nof your Ember application's router can be invoked to define URL mappings. When\ncalling `map()`, you should pass a function that will be invoked with the value\n`this` set to an object which you can use to create routes.\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('about', { path: '/about' });\n  this.route('favorites', { path: '/favs' });\n});\n```\n\nNow, when the user visits `/about`, Ember will render the `about`\ntemplate. Visiting `/favs` will render the `favorites` template.\n\nYou can leave off the path if it is the same as the route\nname. In this case, the following is equivalent to the above example:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('about');\n  this.route('favorites', { path: '/favs' });\n});\n```\n\nInside your templates, you can use [`<LinkTo />`](https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods/LinkTo?anchor=LinkTo) to navigate between\nroutes, using the name that you provided to the `route` method.\n\n```handlebars\n<LinkTo @route=\"index\">\n  <img class=\"logo\">\n</LinkTo>\n\n<nav>\n  <LinkTo @route=\"about\">About</LinkTo>\n  <LinkTo @route=\"favorites\">Favorites</LinkTo>\n</nav>\n```\n\nThe `<LinkTo />` component will also add an `active` class to the link that\npoints to the currently active route.\n\nMulti-word route names are conventionally dasherized, such as:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('blog-post', { path: '/blog-post' });\n});\n```\n\nThe route defined above will by default use the `blog-post.js` route handler,\nthe `blog-post.hbs` template, and be referred to as `blog-post` in any\n`<LinkTo />` components.\n\nMulti-word route names that break this convention, such as:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('blog_post', { path: '/blog-post' });\n});\n```\n\nwill still by default use the `blog-post.js` route handler and the\n`blog-post.hbs` template, but will be referred to as `blog_post` in any\n`<LinkTo />` components.\n\n## Nested Routes\n\nOften you'll want to have a template that displays inside another template.\nFor example, in a blogging application, instead of going from a list of blog\nposts to creating a new post, you might want to have the post creation page\ndisplay next to the list.\n\nIn these cases, you can use nested routes to display one template inside\nof another.\n\nYou can define nested routes by passing a callback to `this.route`:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('posts', function() {\n    this.route('new');\n  });\n});\n```\n\nAssuming you have already generated the `posts` route, to generate the above nested route you would run:\n\n```bash\nember generate route posts/new\n```\n\nAnd then add the `{{outlet}}` helper to your template where you want the nested\ntemplate to display. You can also add a page title with the current page name (using [page-title helper](../../accessibility/page-template-considerations/#toc_page-title)), this will help users with assistive technology know where they are in the website.\n\n```handlebars {data-filename=templates/posts.hbs}\n{{page-title \"Posts - Site Title\"}}\n<h1>Posts</h1>\n{{!-- Display posts and other content --}}\n{{outlet}}\n```\n\nThis generates a route for `/posts` and for `/posts/new`. When a user\nvisits `/posts`, they'll simply see the `posts.hbs` template. (Below, [index\nroutes](#toc_index-routes) explains an important addition to this.) When the\nuser visits `posts/new`, they'll see the `posts/new.hbs` template rendered into\nthe `{{outlet}}` of the `posts` template.\n\nA nested route name includes the names of its ancestors.\nIf you want to transition to a route (either\nvia `transitionTo` or `<LinkTo />`), make sure to use the full route\nname (`posts.new`, not `new`).\n\n## The application route\n\nThe `application` route is entered when your app first boots up. Like other\nroutes, it will load a template with the same name (`application` in\nthis case) by default.\nYou should put your header, footer, and any other decorative content\nhere. All other routes will render\ntheir templates into the `application.hbs` template's `{{outlet}}`.\n\nThis route is part of every application, so you don't need to\nspecify it in your `app/router.js`.\n\n## Index Routes\n\nAt every level of nesting (including the top level), Ember\nautomatically provides a route for the `/` path named `index`.\nTo see when a new level of nesting occurs, check the router,\nwhenever you see a `function`, that's a new level.\n\nFor example, if you write a simple router like this:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('favorites');\n});\n```\n\nIt is the equivalent of:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('index', { path: '/' });\n  this.route('favorites');\n});\n```\n\nThe `index` template will be rendered into the `{{outlet}}` in the\n`application` template. If the user navigates to `/favorites`,\nEmber will replace the `index` template with the `favorites`\ntemplate.\n\nA nested router like this:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('posts', function() {\n    this.route('favorites');\n  });\n});\n```\n\nIs the equivalent of:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('index', { path: '/' });\n  this.route('posts', function() {\n    this.route('index', { path: '/' });\n    this.route('favorites');\n  });\n});\n```\n\nLikewise, if the user navigates to `/posts`, the current route will be\n`posts.index`, and the `posts/index` template\nwill be rendered into the `{{outlet}}` of the `posts` template.\n\nIf the user then navigates to `/posts/favorites`, Ember will\nreplace the `{{outlet}}` in the `posts` template with the\n`posts/favorites` template.\n\nThe following scenarios may help with understanding the `index` route:\n\n- The top-level index route is analogous to `index.html`. For example, when someone visits `https://some-ember-app.com`, the contents of the `template/index.hbs` file will be rendered. There is no need to add an entry `this.route('index', { path: '/' });` in `app/router.js` file. The `index` route is implicitly included in order to help reduce verbose declarations in the `app/router.js`. The `app/router.js` file could be empty, and the `index` would still be shown:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n});\n```\n- When a user navigates to `/posts`, the contents of `index.hbs` will be rendered. This is similar to a user navigating to the child route of `/posts`. `/posts/index` is a child route like `/posts/comments` or `/posts/likes`.\n\n### When to use an index route\n\nThe index route is most helpful for rendering a view when the route has [dynamic segments](#toc_dynamic-segments) defined in it or there are nested routes. In other words, an `index` template is used to show content that should not be present on sibling and child routes. For example, a blog app might have an `index` route that shows a list of all posts, but if a user clicks on a post, they should only see the content for the individual post. Here is how that looks in practice:\n\nA `templates/posts.hbs` file has the following:\n\n```handlebars {data-filename=templates/posts.hbs}\n{{page-title \"Posts\"}}\n<h1>This is the posts template, containing headers to show on all child routes</h1>\n{{outlet}}\n```\n\nThe `templates/posts/index.hbs` file has the following:\n\n```handlebars {data-filename=templates/posts/index.hbs}\n{{page-title \"Posts\"}}\n<p>This is the posts/index template with a list of posts</p>\n```\n\nThe `templates/posts/post.hbs` file has the following:\n\n```handlebars {data-filename=templates/posts/post.hbs}\n{{page-title \"Post\"}}\n<p>This is an individual post, from the posts/post template, used when we enter the /posts/:post_id route</p>\n```\n\nThis is equivalent to having the following entry in `app/router.js` file\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('posts', function() {\n    this.route('post', { path: '/:post_id' });\n    this.route('index', { path: '/' });\n  })\n});\n```\n\nWhen the user navigates to `/posts/123`, the following markup will be seen:\n\n```handlebars {data-filename=templates/posts/post.hbs}\n{{page-title \"Posts\"}}\n<h1>This is the posts template, containing headers to show on all child routes</h1>\n<p>This is an individual post, from the posts/post template, used when we enter the /posts/:post_id route</p>\n```\n\nWhen the user navigates to `/posts/`, the following markup will be seen:\n\n```handlebars {data-filename=templates/posts/index.hbs}\n{{page-title \"Posts\"}}\n<h1>This is the posts template, containing headers to show on all child routes</h1>\n<p>This is the posts/index template with a list of posts</p>\n```\n\n## Dynamic Segments\n\nOne of the responsibilities of a route is to load a model.\n\nFor example, if we have the route `this.route('posts');`, our\nroute might load all of the blog posts for the app.\n\nBecause `/posts` represents a fixed model, we don't need any\nadditional information to know what to retrieve.  However, if we want a route\nto represent a single post, we would not want to have to hardcode every\npossible post into the router.\n\nEnter _dynamic segments_.\n\nA dynamic segment is a portion of a URL that starts with a `:` and is followed by an identifier.\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n```\n\nIf the user navigates to `/post/5`, the route will then have the `post_id` of\n`5` to use to load the correct post.\nEmber follows the convention of `:model-name_id` for two reasons.\nThe first reason is that Routes know how to fetch the right model by default, if you follow the convention.\nThe second is that `params` is an object, and can only have one value associated with a key.\nTo put it in code, the following will _not_ work properly:\n\n```javascript {data-filename=app/router.js}\n// This won't work! The dynamic segments will collide.\nRouter.map(function() {\n  this.route('photo', { path: '/photo/:id' }, function() {\n    this.route('comment', { path: '/comment/:id' });\n  });\n});\n```\n\nBut the following will:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('photo', { path: '/photo/:photo_id' }, function() {\n    this.route('comment', { path: '/comment/:comment_id' });\n  });\n});\n```\n\nIn the next section, [Specifying a Route's Model](../specifying-a-routes-model/), you will learn more about how to load a model.\n\n## Wildcard / globbing routes\n\nYou can define wildcard routes that will match multiple URL segments.\nThis could be used, for example, if you'd like a catch-all route which is useful when the user enters an incorrect URL not managed by your app.\nWildcard routes begin with an asterisk.\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('not-found', { path: '/*path' });\n});\n```\n\n```handlebars {data-filename=app/templates/not-found.hbs}\n{{page-title \"Not found\"}}\n<p>Oops, the page you're looking for wasn't found</p>\n```\n\nIn the above example we have successfully used a wildcard route to handle all routes not managed by our application\nso that when a user navigates to `/a/non-existent/path` they will be shown a message that says the page they're looking for wasn't found.\n\nNote that if you want to manually transition to this wildcard route, you need to pass an arbitrary (not empty) argument. For example, using Ember Data to find a record:\n\n```javascript {data-filename=app/routes/some-route.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\nimport { action } from '@ember/object';\n\nexport default class SomeRouteRoute extends Route {\n  @service store;\n  @service router;\n  // …\n  @action\n  async visitUserProfile(id) {\n    this.store.findRecord('user', id).then(function (user) {\n      // Success callback\n      this.router.transitionTo('user.profile', user);\n    }).catch(function () {\n      // Error callback\n      this.router.transitionTo('not-found', 404);\n    }\n  }\n}\n```\n## Route Handlers\n\nTo have your route do something beyond render a template with the same name, you'll\nneed to create a route handler. The following guides will explore the different\nfeatures of route handlers. For more information on routes, see the API documentation\nfor [the router](https://api.emberjs.com/ember/release/classes/EmberRouter) and for [route\nhandlers](https://api.emberjs.com/ember/release/classes/Route).\n\n## Transitioning Between Routes\nOnce the routes are defined, how do we go about transitioning between them within our application? It depends on where the transition needs to take place:\n\n- From a template, use [`<LinkTo />`](https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods/LinkTo?anchor=LinkTo) as mentioned above\n- From anywhere else in your application, such as a component, inject the [Router Service](https://api.emberjs.com/ember/release/classes/RouterService) and use the [`transitionTo()`](https://api.emberjs.com/ember/release/classes/RouterService/methods/transitionTo?anchor=transitionTo) method","description":"When your application starts, the router matches the current URL to the routes that you've defined. The routes, in turn, are responsible for displaying templates, loading data, and setting up application state. \n\nTo define a route, run \n\nember generate..."}}}