{"data":{"type":"contents","id":"testing/testing-application","attributes":{"content":"To create an application test, run `ember generate acceptance-test <name>`.\nFor example:\n\n```bash\nember g acceptance-test login\n```\n\nThis generates this file:\n\n```javascript {data-filename=tests/acceptance/login-test.js}\nimport { module, test } from 'qunit';\nimport { visit, currentURL } from '@ember/test-helpers';\nimport { setupApplicationTest } from 'ember-qunit';\n\nmodule('Acceptance | login', function(hooks) {\n  setupApplicationTest(hooks);\n\n  test('visiting /login', async function(assert) {\n    await visit('/login');\n    assert.equal(currentURL(), '/login');\n  });\n});\n```\n\n`module` allows you to scope your tests: Any test setup that is done inside of this scope will\napply to all test cases contained in this module.\nScoping your tests with `module` also allows you to execute your tests independently from other tests.\nFor example, to only run your tests from your `login` module, run `ember test --module='Acceptance | login'`.\n`setupApplicationTest` deals with application setup and teardown.\nThe `test` function contains an example test.\n\nAlmost every test has a pattern of visiting a route, interacting with the page\n(using the helpers), and checking for expected changes in the DOM.\n\nFor example:\n\n```javascript {data-filename=tests/acceptance/new-post-appears-first-test.js}\nimport { module, test } from 'qunit';\nimport { click, fillIn, visit } from '@ember/test-helpers';\nimport { setupApplicationTest } from 'ember-qunit';\n\nmodule('Acceptance | posts', function(hooks) {\n  setupApplicationTest(hooks);\n\n  test('should add new post', async function(assert) {\n    await visit('/posts/new');\n    await fillIn('[data-test-field=\"Title\"]', 'My new post');\n    await click('[data-test-button=\"Save\"]');\n    assert\n      .dom('[data-test-post-title]')\n      .hasText('My new post', 'The user sees the correct title.');\n  });\n});\n```\n\n## Test Helpers\n\nOne of the major issues in testing web applications is that all code is\nevent-driven and therefore has the potential to be asynchronous (i.e. output can\nhappen out of sequence from input). This has the ramification that code can be\nexecuted in any order.\n\nAn example may help here: Let's say a user clicks two buttons, one after another\nand both load data from different servers. They take different times to respond.\n\nWhen writing your tests, you need to be keenly aware of the fact that you cannot\nbe sure that the response will return immediately after you make your requests,\ntherefore your assertion code (the \"tester\") needs to wait for the thing being\ntested (the \"testee\") to be in a synchronized state. In the example above, that\nwould be when both servers have responded and the test code can go about its\nbusiness checking the data (whether it is mock data, or real data).\n\nThis is why all Ember's test helpers are wrapped in code that ensures Ember is\nback in a synchronized state when it makes its assertions. It saves you from\nhaving to wrap everything in code that does that, and it makes it easier to read\nyour tests because there's less boilerplate in them.\n\nEmber includes several helpers to facilitate application testing. There are two\ntypes of helpers: **asynchronous** and **synchronous**.\n\n### Asynchronous Helpers\n\nAsynchronous helpers are \"aware\" of (and wait for) asynchronous behavior within\nyour application, making it much easier to write deterministic tests.\n\nSome of these handy helpers are:\n\n* [`click(selector)`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#click)\n  - Clicks an element and triggers any actions triggered by the element's `click`\n    event and returns a promise that fulfills when all resulting async behavior\n    is complete.\n* [`fillIn(selector, value)`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#fillin)\n  - Fills in the selected input with the given value and returns a promise that\n     fulfills when all resulting async behavior is complete. Works with `<select>` elements as well as `<input>` elements. Keep in mind that with `<select>` elements, `value` must be set to the _value_ of the `<option>` tag, rather than its _content_ (for example, `true` rather than `\"Yes\"`).\n* [`triggerKeyEvent(selector, type, keyCode)`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#triggerkeyevent)\n  - Simulates a key event type, e.g. `keypress`, `keydown`, `keyup` with the\n    desired keyCode on element found by the selector.\n* [`triggerEvent(selector, type, options)`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#triggerevent)\n  - Triggers the given event, e.g. `blur`, `dblclick` on the element identified\n    by the provided selector.\n* [`visit(url)`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#visit)\n  - Visits the given route and returns a promise that fulfills when all resulting\n     async behavior is complete.\n\nYou can find the full list of helpers in the [API Documentation of ember-test-helpers](https://github.com/emberjs/ember-test-helpers/blob/master/API.md).\n\nThe asynchronous test helpers from `@ember/test-helpers` are meant to be used together with the [ES2017 feature async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) to write easy-to-read tests which\ndeal with asynchronous behavior as follows:\n\nMark the callback passed to the `test` function as asynchronous using the `async` keyword:\n\n```javascript {data-filename=tests/acceptance/new-post-appears-first-test.js}\n  test('should add new post', async function(assert) {\n\n  });\n```\nBefore making an assertion, wait for the execution of each asynchronous helper to finish with the `await` keyword:\n\n```javascript {data-filename=tests/acceptance/new-post-appears-first-test.js}\n  test('should add new post', async function(assert) {\n    await visit('/posts/new');\n    await fillIn('[data-test-field=\"Title\"]', 'My new post');\n    await click('[data-test-button=\"Save\"]');\n    assert.dom('[data-test-post-title]').hasText('My new post');\n  });\n```\n\nOnce we `await` the execution of the asynchronous helpers this way, we will ensure that all subsequent assertions are always made **after** the\nprevious steps in the test have completed.\n\n### Synchronous Helpers\n\nSynchronous helpers are performed immediately when triggered.\n\n* [`currentRouteName()`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#currentroutename): returns the currently active route name.\n* [`currentURL()`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#currenturl): returns the current URL.\n* [`find(selector)`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#find): finds one element within the app's root element\n  that matches the given selector. Scoping to the root element is useful\n  to avoid conflicts with the test framework's reporter.\n* [`findAll(selector)`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#findall): like `find(selector)`, but finds all elements\n  that match the given selector. Equivalent to calling querySelectorAll()\n  on the test root element. Returns an array of matched elements.\n\n## Debugging Your Tests\n\nDuring the development of your tests or when you refactor your application's code, the execution of your tests may fail. In order to help you understand why, [`pauseTest()`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#pausetest) and [`resumeTest()`](https://github.com/emberjs/ember-test-helpers/blob/master/API.md#resumetest) can help you.\n\nTo try them out, do the following steps:\n\n1. Add `await pauseTest();` in your test code.\n2. Run `ember server`.\n3. Visit `http://localhost:4200/tests` in your browser\n\nWhen the execution of the test come upon `await pauseTest()`, the test will be paused, allowing you to inspect the state of your application.\n\nYou can now type `resumeTest()` in the console of your browser to continue the test execution.","description":"To create an application test, run ember generate acceptance-test <name>. For example: \n\nember g acceptance-test login  \n\nThis generates this file: \n\n```javascript {data-filename=tests/acceptance/login-test.js} import { module, test } from 'qunit'; import {..."}}}