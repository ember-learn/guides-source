{"data":{"type":"contents","id":"components/template-lifecycle-dom-and-modifiers","attributes":{"content":"For the most part, you should be able to build Ember applications without directly manipulating the DOM. Before considering directly accessing the DOM, it's always best to first consider whether there's an Ember-native way to accomplish your goal.\n\n## Thinking About Updates\n\nIn most cases, the best way to think about your component's output is to assume that it will be re-executed from the top every time anything changes in your application.\n\nFor example, consider an `Article` component that takes `@title` and `@body` arguments.\n\n```handlebars {data-filename=app/components/article/template.hbs}\n<article>\n  <header><h1>{{@title}}</h1></header>\n  <section>{{@body}}</section>\n</article>\n```\n\nAssuming an `article` route with a model that looks like:\n\n```json\n{\n  \"title\": \"Hello world\",\n  \"body\": \"This is the first article\"\n}\n```\n\nThis component would be invoked this way:\n\n```handlebars {data-filename=app/templates/article.hbs}\n<Article @title={{@model.title}} @body={{@model.body}}>\n```\n\nThe first time the `Article` component is rendered, it would produce this output:\n\n```html\n<article>\n  <header><h1>Hello world</h1></header>\n  <section>This is the first article</section>\n</article>\n```\n\nIn a way, this is like substitution: references to `@title` in the component's template are replaced by the value passed in from the outside.\n\nIf the model changes to:\n\n```json\n{\n  \"title\": \"Hello world\",\n  \"body\": \"This is the first article. [UPDATE] I am so excited!\"\n}\n```\n\nthe output will be updated to:\n\n```html\n<article>\n  <header><h1>Hello world</h1></header>\n  <section>This is the first article. [UPDATE] I am so excited!</section>\n</article>\n```\n\nThink of this as evaluating the template from scratch, substituting in the new values, and updating the output with the new contents.\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        In practice, Ember avoids updating parts of the DOM that haven't changed,\n        which means that the user's selection state, cursor and scroll position,\n        and other state won't change for no reason.\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\nIn general, before reaching for direct DOM manipulation, you should see whether you can model the changes that you want by writing a single template that applies no matter what the input is.\n\n## Manipulating Attributes\n\nThe same philosophy that applies to changing text also applies to changing attributes.\n\nFor example, let's say we want to enhance our `Article` component to include a `title` attribute on the `<article>` tag.\n\n```handlebars {data-filename=app/components/article/template.hbs}\n<article title=\"{{@title}}\">\n  <header><h1>{{@title}}</h1></header>\n  <section>{{@body}}</section>\n</article>\n```\n\nWith the model:\n\n```json\n{\n  \"title\": \"Hello world\",\n  \"body\": \"This is the first article. [UPDATE] I am so excited!\"\n}\n```\n\nthe output will be:\n\n```html\n<article title=\"Hello world\">\n  <header><h1>Hello world</h1></header>\n  <section>This is the first article. [UPDATE] I am so excited!</section>\n</article>\n```\n\nJust like in previous examples, you can think of attribute changes as substitution. If the model changes to:\n\n```json {data-filename=\"input\" data-diff=\"-2,+3\"}\n{\n  \"title\": \"Hello world\",\n  \"title\": \"Hello world!\",\n  \"body\": \"This is the first article. [UPDATE] I am so excited!\"\n}\n```\n\nthe output will be updated to:\n\n```html {data-filename=\"output\" data-diff=\"-1,+2,-3,+4\"}\n<article title=\"Hello world\">\n<article title=\"Hello world!\">\n  <header><h1>Hello world</h1></header>\n  <header><h1>Hello world!</h1></header>\n  <section>This is the first article. [UPDATE] I am so excited!</section>\n</article>\n```\n\n## Conditional Attributes\n\nSo far, we've talked about how to populate an attribute with the value of a variable. But what if we\nwant the value of an attribute to differ based upon whether the variable is truthy or falsy?\n\nFor example, let's say we want the `class` on a `<div>` to be `superuser` if the `@isAdmin` variable\nis true, but `standard` if the `@isAdmin` variable is false.\n\nWe could accomplish this requirement by using the `if` helper inside of an attribute:\n\n```handlebars\n<div class={{if @isAdmin \"superuser\" \"standard\"}}>\n  Welcome to my app.\n</div>\n```\n\nInstead of thinking about changing the class imperatively when the `@isAdmin` variable changes, we\ncan think about how to build a template that produces the right output in both cases, and leave it\nup to Ember to figure out how to update the HTML output.\n\n## Summary: The Principle of Substitution\n\nIn summary, when you're trying to update a piece of text or an attribute in your component, think\nof the Principle of Substitution, and write a template that produces the right HTML when you\nsubstitute all of the variables in the template with the current values of the variables.\n\nWhenever any of those variables change, Ember will automatically update the HTML efficiently without\nblowing away browser state unnecessarily.\n\nThe advantage to writing components this way is that there is no way to make a mistake and forget to\nupdate the output correctly in some situations. As long as the template produces the right HTML for\nits inputs, the output will remain up to date.\n\nThis approach works great when you're trying to produce output that can be represented in HTML. But\nwhat about aspects of your component that aren't represented in HTML, like event handlers? In those\ncases, Ember tries to stick to the spirit of the Principle of Substitution, and allow you to write\ntemplates as if they only ran one time, and then automatically keep the output up to date for you.\n\nThe rest of this guide describes how to enhance your templates with event handlers, custom DOM\nproperties and other kinds of custom JavaScript.\n\n## Event Handlers\n\nIf you want to add an event handler to an HTML element, you can use the `{{on` element modifier.\n\n```js {data-filename=\"app/components/counter.js\"}\nimport Component from \"@glimmer/component\";\nimport { action } from \"@ember/object\";\nimport { tracked } from '@glimmer/tracking';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  @action\n  increment() {\n    this.count++;\n  }\n}\n```\n\n```handlebars {data-filename=\"app/components/counter.hbs\"}\n<p>{{this.count}}</p>\n\n<button type=\"button\" {{on \"click\" this.increment}}>+</button>\n```\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Tomster says...</div>\n      <div class=\"cta-note-message\">\n        \"Element modifiers\" appear inside free-floating curly braces inside of an opening\n        tag. Unlike <strong>attribute syntax</strong>, which works by substitution\n        (and therefore affects the HTML output of your page), element modifiers work\n        by passing the element to a function that can do anything with it.\n      </div>\n    </div>\n  </div>\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-message\">\n        Unlike attributes, element modifiers do <strong>not</strong> run on the\n        server-side, because there is no general-purpose and complete way to serialize\n        the results of an element modifier into HTML.</p>\n      </div>\n    </div>\n    <img src=\"/images/mascots/tomster.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\n## Manipulating Properties\n\nSince you're writing an HTML template, you can use dynamic substitution inside of an attribute's value; whenever the value changes, the attribute will change.\n\nSetting properties on an HTML element, on the other hand, is a different story, because there's no way to set a property using HTML syntax.\n\nFor example, let's say you want to create an `<audio>` element, but pass it a blob as its [`srcObject`](https://www.w3.org/TR/html52/semantics-embedded-content.html#dom-htmlmediaelement-srcobject).\n\nSince `srcObject` is a property and not an HTML attribute, you can use the `prop` element modifier from [ember-prop-modifier][prop-modifier] like this:\n\n```handlebars\n<audio {{prop srcObject=this.blob}} />\n```\n\n[prop-modifier]: https://www.npmjs.com/package/ember-prop-modifier\n\nIf the value changes, Ember will automatically update the element's property for you.\n\n### How to Know If You Need a Property\n\nIf you're looking at a piece of documentation written using HTML syntax, you can use the syntax as-is in your template, and use `{{` to insert dynamic content.\n\nOn the other hand, if you're looking at JavaScript documentation that tells you to set a property on an element object, you can use `{{prop` to set the prop\n\nIf you want to set a property, you can use the `prop` element modifier.\n\n## Calling Methods On First Render\n\nSo far, we've talked about web APIs that work by setting attributes as well as web APIs that work by setting properties. But what about web APIs that work by calling methods, like setting focus on an element?\n\nFor example, let's say we want to focus an `<input>` in a form as soon as the form is rendered. The web API for focusing an element is:\n\n```js\ninputElement.focus();\n```\n\nThis code needs to run after the element is rendered.\n\nThe simplest way to accomplish this is by using the `did-insert` modifier from [@ember/render-modifiers][render-modifiers].\n\n[render-modifiers]: https://github.com/emberjs/ember-render-modifiers\n\n```handlebars {app/components/edit-form.hbs}\n<form>\n  <input {{did-insert this.focus}}>\n</form>\n```\n\n```js {app/components/edit-form.js}\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class EditFormComponent extends Component {\n  @action\n  focus(element) {\n    element.focus();\n  }\n}\n```\n\nThe `did-insert` modifier will call a function after its element is added to the DOM. That function receives the element as a parameter.\n\n### Abstracting the Logic Into a Custom Modifier\n\nUsing the `did-insert` modifier works well for one-off cases, but if you want to pull this logic into reusable functionality that you can use throughout your app, you can make your _own_ modifier.\n\nThe modifier that we're going to build will allow us to say:\n\n```handlebars {data-filename=\"app/components/edit-form.hbs\"}\n<form>\n  <input {{autofocus}}>\n</form>\n```\n\nPretty nice, right?\n\nTo accomplish that, we'll create a modifier in `app/modifiers/autofocus.js`. First, install [`ember-modifier`](https://github.com/ember-modifier/ember-modifier) and then generate an `autofocus` modifier for your app:\n\n```bash\nember install ember-modifier\nember generate modifier autofocus\n```\n\nNow add the functionality to focus the element:\n\n```js {data-filename=\"app/modifiers/autofocus.js\"}\nimport { modifier } from \"ember-modifier\";\n\nexport default modifier(element => element.focus());\n```\n\nAnd that's it!\n\nNow we can use our custom `{{autofocus}}` modifier throughout our application.\n\n## Communicating Between Elements in a Component\n\nWhat if you want to handle an event in one part of your component by calling a DOM method on another part? For example, let's say you're creating an audio component:\n\n```handlebars {data-filename=\"app/components/audio-player.hbs\"}\n<audio src={{@srcURL}} />\n\n<button type=\"button\">Play</button>\n<button type=\"button\">Pause</button>\n```\n\nHow should we connect clicking the \"Play\" and \"Pause\" to calling the audio tag's `play` and `pause` methods?\n\nWhile we _could_ manage these DOM interactions in the component class (for example, by using `{{did-render}}`), we're better off using a modifier here. It lets us cleanly separate our concerns: the component manages the _state_, and the modifier manages _interactions with the DOM_.\n\nThere are three reasons to reach for modifiers for DOM element interactions:\n\n1. A component, by itself, doesn't have direct access to DOM elements. We have to render the page, push an element back up into the component class, and only then can we safely refer to that element. This can sometimes require us to render the component's HTML twice in order for things to start working. Modifiers let us avoid this possible performance issue.\n2. By keeping state in the component and handling DOM method calls in a modifier, we can use autotracking and stick to 1-way data flow in the component. Further, we could change the component's own design later _without_ having to change how we interact with the DOM element.\n3. The code for calling the audio element's `play` and `pause` can be reused. It isn't tied to this particular audio component. It can be tested independently, too!\n\nNow that we see _why_ we want to use a modifier for our audio component, let's walk through _how_ to create one. We will start with the component (to manage the state) and then implement the modifier (the manage the DOM).\n\nFirst, we add actions to handle the `click` events for the `Play` and `Pause` buttons:\n\n```handlebars {data-filename=\"app/components/audio-player.hbs\" data-diff=\"-3,+4,-5,+6\"}\n<audio src={{@srcURL}} />\n\n<button type=\"button\">Play</button>\n<button type=\"button\" {{on \"click\" this.play}}>Play</button>\n<button type=\"button\">Pause</button>\n<button type=\"button\" {{on \"click\" this.pause}}>Pause</button>\n```\n\n```js {data-filename=\"app/components/audio-player.js\"}\nimport Component from \"@glimmer/component\";\nimport { action } from \"@ember/object\";\n\nexport default class AudioPlayerComponent extends Component {\n  @action\n  play() {\n    // TODO\n  }\n\n  @action\n  pause() {\n    // TODO\n  }\n}\n```\n\nRecall that our modifier will manage the DOM (i.e. calling the audio element's `play` or `pause` method). All the component needs to do is to track whether the audio is playing:\n\n```js {data-filename=\"app/components/audio-player.js\" data-diff=\"+2,+6,+7,-10,+11,-16,+17\"}\nimport Component from \"@glimmer/component\";\nimport { tracked } from \"@glimmer/tracking\";\nimport { action } from \"@ember/object\";\n\nexport default class AudioPlayerComponent extends Component {\n  @tracked isPlaying = false;\n\n  @action\n  play() {\n    // TODO\n    this.isPlaying = true;\n  }\n\n  @action\n  pause() {\n    // TODO\n    this.isPlaying = false;\n  }\n}\n```\n\nThat's it for the component: we're translating the user's interactions into _state_. Now we need to build a modifier to translate the state into the appropriate DOM method calls!\n\n```bash\nember install ember-modifier\nember generate modifier play-when\n```\n\nThe modifier takes 1 argument, a Boolean that specifies if we should call the element's `play` or `pause` method.\n\n```js {data-filename=\"app/modifiers/play-when.js\"}\nimport { modifier } from \"ember-modifier\";\n\nexport default modifier((element, [isPlaying]) => {\n  if (isPlaying) {\n    element.play();\n  } else {\n    element.pause();\n  }\n});\n```\n\nLast but not least, we attach the modifier to the `audio` element:\n\n```handlebars {data-filename=\"app/components/audio-player.hbs\" data-diff=\"-1,+2\"}\n<audio src={{@srcURL}} />\n<audio src={{@srcURL}} {{play-when this.isPlaying}} />\n\n<button type=\"button\" {{on \"click\" this.play}}>Play</button>\n<button type=\"button\" {{on \"click\" this.pause}}>Pause</button>\n```\n\nWith that, we can now click the buttons to play and pause the audio!\n\nIn summary, when you want to allow elements in a component to communicate, see if you can separate the concerns of _managing state_ and _managing DOM interactions_. The component can manage the state, while a modifier can manage the DOM.\n\nThe modifier that we made for the audio player component can be reused on _any_ element that implements `play` and `pause` methods. In particular, we can reuse the modifier on any `HTMLMediaElement`, which includes `audio` and `video` elements.\n\n## Out-of-Component Modifications\n\nIn most cases, your component should restrict its behavior to its own elements. However, there are cases where a component needs to do something outside of itself. One simple example of this would be an element that wants to handle clicks outside of its DOM, which requires registering a handler on the whole document, and then hit-testing the element.\n\nLet's start with the DOM structure of a super-simple component that would remove its contents when a click occurs outside of the element.\n\n```handlebars {data-filename=\"app/components/modal.hbs\"}\n<div class=\"modal\">\n  {{yield}}\n</div>\n```\n\nWe don't want to use `{{on \"click\"}}` here because we want the opposite behavior: do something whenever the user clicks _outside_ of the `<div>`. To accomplish that, we'll register a `click` handler on the entire document and then hit-test it, looking something like this:\n\n```js\ndocument.addEventListener(\"click\", event => {\n  if (!element.contains(event.target)) {\n    // do something\n  }\n});\n```\n\nThe most important difference between this example and the cases we've seen so far is that we need to remove the `click` event handler from the document when this element is destroyed.\n\nTo accomplish this, we can use [`ember-modifier`](https://github.com/ember-modifier/ember-modifier) to create a `on-click-outside` modifier that sets up the event listener after the element is first inserted and removes the event listener when the element is removed. \n\nRun the following commands to install the addon and generate a new modifier:\n\n```bash\nember install ember-modifier\nember generate modifier on-click-outside\n```\n\nThe `on-click-outside` modifier adds the click handler to the `document` and returns _another function_ that should be run when Ember removes the element the modifier is attached to.\n\n```js {data-filename=\"app/modifiers/on-click-outside.js\"}\nimport { modifier } from \"ember-modifier\";\n\nexport default modifier((element, [callback]) => {\n  function handleClick(event) {\n    if (!element.contains(event.target)) {\n      callback();\n    }\n  }\n\n  document.addEventListener(\"click\", handleClick);\n\n  return () => {\n    document.removeEventListener(\"click\", handleClick);\n  };\n});\n```\n\nNow that we've created this modifier, we can use it in our `modal` component, and add some logic to invoke a passed-in action whenever the user clicks outside the modal.\n\n```handlebars {data-filename=\"app/components/modal.hbs\"}\n<div class=\"modal\" {{on-click-outside @clickedOutside}}>\n  {{yield}}\n</div>\n```\n\nWe could then use the `modal` component this way:\n\n```handlebars {data-filename=\"app/components/sidebar.hbs\"}\n<p class=\"help-icon\" {{on \"click\" this.showHelp}}>?</p>\n\n{{#if this.showingHelp}}\n  <Modal @clickedOutside={{this.hideHelp}}>\n    Here's some interesting facts about the sidebar that you can learn.\n  </Modal>\n{{/if}}\n```\n\n```js {data-filename=\"app/components/sidebar.js\"}\nimport Component from \"@glimmer/component\";\nimport { tracked } from \"@glimmer/tracking\";\nimport { action } from \"@ember/object\";\n\nexport default class SidebarComponent extends Component {\n  @tracked showingHelp = false;\n\n  @action\n  showHelp() {\n    this.showingHelp = true;\n  }\n\n  @action\n  hideHelp() {\n    this.showingHelp = false;\n  }\n}\n```\n\n#### Modifiers and `...attributes`\n\nModifiers can also be applied to components, and when they are, they are also\npassed forward and applied to an element with `...attributes`:\n\n```handlebars\n<Tooltip {{did-insert this.setupTooltip}}/>\n```\n\n```handlebars {data-filename=\"app/components/tooltip.hbs\"}\n<div ...attributes>\n  ...\n</div>\n```\n\nIn this example, the `div` within the Tooltip component will get the\n`did-insert` modifier applied to it.","description":"For the most part, you should be able to build Ember applications without directly manipulating the DOM. Before considering directly accessing the DOM, it's always best to first consider whether there's an Ember-native way to accomplish your goal. Thinking..."}}}