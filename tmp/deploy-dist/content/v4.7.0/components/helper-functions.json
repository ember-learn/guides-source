{"data":{"type":"contents","id":"components/helper-functions","attributes":{"content":"Helper functions are JavaScript functions that you can call from your template.\n\nEmber's template syntax limits what you can express to keep the structure of your application clear at a glance. When you need to compute something using JavaScript, you can use helper functions. It's possible to create your own helpers or just [use the built-in ones](./#toc_built-in-helpers).\n\nFor instance, let's take a look at a generic message component from a messaging app.\n\n```handlebars {data-filename=\"app/components/message.hbs\"}\n<Message::Avatar\n  @title={{@avatarTitle}}\n  @initial={{@avatarInitial}}\n  @isActive={{@userIsActive}}\n  class={{if @isCurrentUser \"current-user\"}}\n/>\n<section>\n  <Message::Username\n    @name={{@username}}\n    @localTime={{@userLocalTime}}\n  />\n\n  {{yield}}\n</section>\n```\n\n```handlebars\n<Message\n  @username=\"Tomster\"\n  @userIsActive={{true}}\n  @userLocalTime=\"4:56pm\"\n  @avatarTitle=\"Tomster's avatar\"\n  @avatarInitial=\"T\"\n>\n  <p>\n    Hey Zoey, have you had a chance to look at the EmberConf\n    brainstorming doc I sent you?\n  </p>\n</Message>\n```\n\nBy looking at how we use the `<Message>` component, we can see that some of the arguments are fairly repetitive. Both `@avatarTitle` and `@avatarInitial` are based on the user's `@username`, but the title has more text, and the initial is only the first letter of the name. We'd rather just pass a username to the `<Message>` component and _compute_ the value of the title and initial.\n\nLet's update the component to do that. It'll take a `@username` argument and calculate the title and initial.\n\nSince the title is just the `@username` plus some extra stuff, we can replace `@avatarTitle` by _interpolating_ the `@username` argument in a string literal passed to `<Message::Avatar>`.\n\n```handlebars {data-filename=\"app/components/message.hbs\" data-diff=\"-2,+3\"}\n<Message::Avatar\n  @title={{@avatarTitle}}\n  @title=\"{{@username}}'s avatar\"\n  @initial={{@avatarInitial}}\n  @isActive={{@userIsActive}}\n  class={{if @isCurrentUser \"current-user\"}}\n/>\n<section>\n  <Message::Username\n    @name={{@username}}\n    @localTime={{@userLocalTime}}\n  />\n\n  {{yield}}\n</section>\n```\n\nHowever, to get the first initial of the string, we'll need to use JavaScript. To do that, we'll write a helper function.\n\n## Writing a Helper Function\n\nWe define helper functions in the `app/helpers` folder.\n\nIn this case we want a helper function that takes three arguments: a string, a starting position, and a length. The function will return a substring of the original string.\n\nTo implement the helper, we write a JavaScript function that takes its arguments as an _array_. This is because helpers can also receive _named_\narguments, which we'll discuss next.\n\n```js {data-filename=\"app/helpers/substring.js\"}\nimport { helper } from '@ember/component/helper';\n\nfunction substring(args) {\n  let [string, start, end] = args;\n  return string.substring(start, end);\n}\n\nexport default helper(substring);\n```\n\nWe can tighten up the implementation by moving the [destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) into the function's signature.\n\n```js {data-filename=\"app/helpers/substring.js\" data-diff=\"+3,-4,-5\"}\nimport { helper } from '@ember/component/helper';\n\nfunction substring([string, start, end]) {\nfunction substring(args) {\n  let [string, start, end] = args;\n  return string.substring(start, end);\n}\n\nexport default helper(substring);\n```\n\n**This is how we normally write helpers in Ember**.\n\nWe can then use this helper in the component's template to get the first letter of the username.\n\n```handlebars {data-filename=\"app/components/message.hbs\" data-diff=\"-3,+4\"}\n<Message::Avatar\n  @title=\"{{@username}}'s avatar\"\n  @initial={{@avatarTitle}}\n  @initial={{substring @username 0 1}}\n  @isActive={{@userIsActive}}\n  class={{if @isCurrentUser \"current-user\"}}\n/>\n<section>\n  <Message::Username\n    @name={{@username}}\n    @localTime={{@userLocalTime}}\n  />\n\n  {{yield}}\n</section>\n```\n\n### Named Arguments\n\nThe syntax `{{substring @username 0 1}}` is a little hard to read. We see some numbers at the end but can't tell what exactly they mean. We can use _named arguments_ to make the `substring` helper easier to read.\n\nUsing named arguments, we could make our template a lot clearer.\n\n```handlebars {data-filename=\"app/components/message.hbs\" data-diff=\"-3,+4,+5\"}\n<Message::Avatar\n  @title=\"{{@username}}'s avatar\"\n  @initial={{substring @username 0 1}}\n  {{! This won't work yet! We need to update the substring helper }}\n  @initial={{substring @username start=0 end=1}}\n  @isActive={{@userIsActive}}\n  class={{if @isCurrentUser \"current-user\"}}\n/>\n<section>\n  <Message::Username\n    @name={{@username}}\n    @localTime={{@userLocalTime}}\n  />\n\n  {{yield}}\n</section>\n```\n\nIn addition to taking _positional arguments_ as an array, helpers take _named arguments_ as a JavaScript object. Here's what that looks like using [destructuring syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Unpacking_fields_from_objects_passed_as_function_parameter).\n\n```js {data-filename=\"app/helpers/substring.js\"}\nimport { helper } from '@ember/component/helper';\n\nfunction substring([string], { start, end }) {\n  return string.substring(start || 0, end);\n}\n\nexport default helper(substring);\n```\n\nYou can mix positional and named arguments to make your templates easy to read.\n\n### Nested Helpers\n\nSometimes, you might see helpers invoked by placing them inside parentheses,\n`()`. This means that a Helper is being used inside of another Helper or\nComponent. This is referred to as a \"nested\" Helper Invocation. Parentheses must\nbe used because curly braces `{{}}` cannot be nested.\n\n```handlebars {data-filename=app/templates/application.hbs}\n{{sum (multiply 2 4) 2}}\n```\n\nIn this example, we are using a helper to multiply `2` and `4` _before_ passing\nthe value into `{{sum}}`.\n\nThus, the output of these combined helpers is `10`.\n\nAs you move forward with these template guides, keep in mind that a helper can\nbe used anywhere a normal value can be used.\n\nMany of Ember's built-in helpers (as well as your custom helpers) can be used in\nnested form.\n\n## Advanced: Class Helpers\n\nHelpers can also be defined using class syntax. For instance, we could define\nthe substring helper using classes instead.\n\n```js {data-filename=\"app/helpers/substring.js\" data-diff=\"-1,+2,-4,+5,+6,+8\"}\nimport { helper } from '@ember/component/helper';\nimport Helper from '@ember/component/helper';\n\nfunction substring([string], { start, length }) {\nexport default class Substring extends Helper {\n  compute([string], { start, end }) {\n    return string.substring(start || 0, end);\n  }\n}\n```\n\nClass helpers are useful when the helper logic is fairly complicated, requires\nfine-grained control of the helper lifecycle, or is _stateful_ (we'll be\ndiscussing state in the next chapter).\n\n## Built-in Helpers\n\nBelow you will find some useful template helpers documented.\nFor the full list of available helpers, you can check the [template helpers API documentation](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/).\n\n### The `get` helper\n\nThe [`{{get}}`](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods/get?anchor=get)\nhelper makes it easy to dynamically look up a property on an object or an element in an array. The second argument to `{{get}}` can be a string or a number, depending on the object being accessed.\n\n\nTo access a property on an object with a string key:\n\n```handlebars\n{{get this.someObject \"object_key\"}}\n```\n\nTo access the first element in an array:\n\n```handlebars\n{{get this.someArray 0}}\n```\n\nTo access a property on an object with a dynamic key:\n\n```handlebars\n{{get this.address this.part}}\n```\n\nIf the `part` getter returns \"zip\", this will display the result of `this.address.zip`.\nIf it returns \"city\", you get `this.address.city`.\n\n\n### The `concat` helper\n\nWe mentioned above that helpers can be nested. This can be\ncombined with different dynamic helpers. For example, the\n[`{{concat}}`](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods/concat?anchor=concat)\nhelper makes it easy to dynamically send a number of parameters to a component\nor helper as a single parameter in the format of a concatenated string.\n\n```handlebars\n{{get this.foo (concat \"item\" this.index)}}\n```\n\nThis will display the result of `this.foo.item1` when index is 1, and\n`this.foo.item2` when index is 2, etc.\n\n### The `let` helper\n\nNow let's say your template is starting to get a bit cluttered and you want\nto clean up the logic in your templates. This can be achieved with the `let`\nblock helper.\nThe [`{{let}}`](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods/let?anchor=let)\nhelper lets you create new bindings (or temporary variables) in your template.\n\nSay your template now looks like this:\n\n```handlebars\nWelcome back {{concat (capitalize this.person.givenName) ' ' (capitalize this.person.familyName)}}\n\nAccount Details:\nGiven Name: {{capitalize this.person.givenName}}\nFamily Name: {{capitalize this.person.familyName}}\n```\n\nAs mentioned in the previous section, we use the `concat` helper to render both\n`person.givenName` and `person.familyName` in one go. But we also want to make\nsure that the names are capitalized. It gets a bit repetitive to keep writing\n`capitalize` and honestly, we might just forget it at some point. Thankfully, we\ncan use the `{{let}}` helper to fix this:\n\n```handlebars\n{{#let (capitalize this.person.givenName) (capitalize this.person.familyName)\n  as |givenName familyName|\n}}\n  Welcome back {{concat givenName ' ' familyName}}\n\n  Account Details:\n  Given Name: {{givenName}}\n  Family Name: {{familyName}}\n{{/let}}\n```\n\nNow, as long as your template is wrapped in the `let` helper, you can access the\ncapitalized given name and family name as `givenName` and `familyName` instead of\n`(capitalize this.person.givenName)`.\n\n### The `array` helper\n\nUsing the [`{{array}}`](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods/array?anchor=array) helper,\nyou can pass arrays directly from the template as an argument to your components.\n\n```handlebars\n<MyComponent\n  @people={{array\n    'Tom Dale'\n    'Yehuda Katz'\n    this.myOtherPerson\n  }}\n/>\n```\n\nIn the component's template, you can then use the `people` argument as an array:\n\n```handlebars {data-filename=app/components/my-component/template.hbs}\n<ul>\n  {{#each @people as |person|}}\n    <li>{{person}}</li>\n  {{/each}}\n</ul>\n```\n\n### The `hash` helper\n\nUsing the [`{{hash}}`](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods/hash?anchor=hash)\nhelper, you can pass objects directly from the template as an argument to your\ncomponents.\n\n```handlebars\n<Greeting\n  @person={{hash\n    givenName='Jen'\n    familyName='Weber'\n  }}\n/>\n```\n\nIn the component's template, you can then use the `person` object:\n```handlebars {data-filename=app/components/greeting/template.hbs}\nHello, {{@person.givenName}} {{@person.familyName}}\n```\n\n### The `in-element` helper\n\nUsing the [`{{in-element}}`](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods/in-element?anchor=in-element) helper, you can render content into a DOM element that is in a _different_ part of the page. For instance, we might want\nto render a modal, tooltip, or dropdown.\n\nSuppose we want to show a dropdown menu when the user clicks on a button. The code below shows a `<button>` element, a placeholder `<div>` element, and a dropdown component. The argument `@show`, when set to `true`, will add the dropdown to the placeholder div.\n```handlebars {data-filename=app/components/some-component.hbs}\n  <button\n    type=\"button\"\n    {{on \"click\" this.onClickShowDropdown}}\n  >\n    More Actions\n  </button>\n  <div id=\"dropdown-destination\" />\n\n  <MyDropdownComponent\n    @show={{this.showDropdown}}\n  />\n```\n\nWhen the user clicks on the button, the flag `showDropdown` will be set to `true`.\n```js {data-filename=app/components/some-component.js}\n  @tracked\n  showDropdown = false;\n\n  @action\n  onClickShowDropdown() {\n    this.showDropdown = true;\n  }\n```\n\nThe dropdown component uses the argument `@show` to activate the `in-element` helper. We must **provide the destination DOM element** to the helper. In other words, where should the helper render its block content?\n```handlebars {data-filename=app/components/my-dropdown-component.hbs}\n{{#if @show}}\n  {{#in-element this.destinationElement}}\n    <ul>\n      <li>Archive</li>\n      <li>Mark as Read</li>\n      <li>Report</li>\n    </ul>\n  {{/in-element}}\n{{/if}}\n```\n\n```js {data-filename=app/components/my-dropdown-component.js}\n  get destinationElement() {\n    return document.querySelector('#dropdown-destination');\n  }\n```\n\nAfter the user clicks on the button, the final HTML result for the div will be like this:\n```html\n  <div id=\"dropdown-destination\">\n    <ul>\n      <li>Archive</li>\n      <li>Mark as Read</li>\n      <li>Report</li>\n    </ul>\n  </div>\n```\n\nThings to note:\n- The destination element needs to exist in the DOM before we use the helper. Otherwise, an error will be thrown if you are in development mode. The error is not thrown in production.\n- When the destination element changes, the content defined in `in-element` will re-render completely.\n- By default, the `in-element` helper replaces the destination element's existing content with the helper's block content. If you want to instead append the block content, you can pass `insertBefore=null`.","description":"Helper functions are JavaScript functions that you can call from your template. \n\nEmber's template syntax limits what you can express to keep the structure of your application clear at a glance. When you need to compute something using JavaScript, you can..."}}}