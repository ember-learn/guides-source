{"data":{"type":"contents","id":"routing/asynchronous-routing","attributes":{"content":"This section covers some more advanced features of the router and its\ncapability for handling complex async logic within your app.\n\n### A Word on Promises...\n\nEmber's approach to handling asynchronous logic in the router makes\nheavy use of the concept of Promises. In short, promises are objects that\nrepresent an eventual value. A promise can either _fulfill_\n(successfully resolve the value) or _reject_ (fail to resolve the\nvalue). The way to retrieve this eventual value, or handle the cases\nwhen the promise rejects, is via the promise's [`then()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) method, which\naccepts two optional callbacks, one for fulfillment and one for\nrejection. If the promise fulfills, the fulfillment handler gets called\nwith the fulfilled value as its sole argument, and if the promise rejects,\nthe rejection handler gets called with a reason for the rejection as its\nsole argument. For example:\n\n\n```javascript\nlet promise = fetchTheAnswer();\n\npromise.then(fulfillCallback, rejectCallback);\n\nfunction fulfillCallback(answer) {\n  console.log(`The answer is ${answer}`);\n}\n\nfunction rejectCallback(reason) {\n  console.log(`Couldn't get the answer! Reason: ${reason}`);\n}\n```\n\nMuch of the power of promises comes from the fact that they can be\nchained together to perform sequential asynchronous operations:\n\n```javascript\nimport fetch from 'fetch';\n\nlet usernamesPromise = fetch('/usernames.json');\n\nusernamesPromise.then(response => response.json())\n                .then(fetchPhotosOfUsers)\n                .then(applyInstagramFilters)\n                .then(uploadTrendyPhotoAlbum)\n                .then(displaySuccessMessage, handleErrors);\n```\n\nIn the above example, if any of the methods\n`fetchPhotosOfUsers`, `applyInstagramFilters`, or\n`uploadTrendyPhotoAlbum` returns a promise that rejects,\n`handleErrors` will be called with\nthe reason for the failure. In this manner, promises approximate an\nasynchronous form of try-catch statements that prevent the rightward\nflow of nested callback after nested callback and facilitate a saner\napproach to managing complex asynchronous logic in your applications.\n\n### The Router Pauses for Promises\n\nWhen transitioning between routes, the Ember router collects all of the\nmodels (via the `model` hook) that will be passed to the route's\ncontrollers at the end of the transition. If the `model` hook (or the related\n`beforeModel` or `afterModel` hooks) return normal (non-promise) objects or\narrays, the transition will complete immediately. But if the `model` hook\n(or the related `beforeModel` or `afterModel` hooks) returns a promise (or\nif a promise was provided as an argument to `transitionTo`), the transition\nwill pause until that promise fulfills or rejects.\n\nThe router considers any object with a `then()` method\ndefined on it to be a promise.\n\nIf the promise fulfills, the transition will pick up where it left off and\nbegin resolving the next (child) route's model, pausing if it too is a\npromise, and so on, until all destination route models have been\nresolved. The values passed to the [`setupController()`](https://api.emberjs.com/ember/release/classes/Route/methods/setupController?anchor=setupController) hook for each route\nwill be the fulfilled values from the promises.\n\n\nA basic example:\n\n```javascript {data-filename=app/routes/tardy.js}\nimport Route from '@ember/routing/route';\nimport { later } from '@ember/runloop';\n\nexport default class TardyRoute extends Route {\n  model() {\n    return new Promise(function(resolve) {\n      later(function() {\n        resolve({ msg: 'Hold Your Horses' });\n      }, 3000);\n    });\n  }\n\n  setupController(controller, model) {\n    console.log(model.msg); // \"Hold Your Horses\"\n  }\n}\n```\n\nWhen transitioning into `route:tardy`, the `model()` hook will be called and\nreturn a promise that won't resolve until 3 seconds later, during which time\nthe router will be paused in mid-transition. When the promise eventually\nfulfills, the router will continue transitioning and eventually call\n`route:tardy`'s `setupController()` hook with the resolved object.\n\nThis pause-on-promise behavior is extremely valuable for when you need\nto guarantee that a route's data has fully loaded before displaying a\nnew template.\n\n### When Promises Reject...\n\nWe've covered the case when a model promise fulfills, but what if it rejects?\n\nBy default, if a model promise rejects during a transition, the transition is\naborted, no new destination route templates are rendered, and an error\nis logged to the console.\n\nYou can configure this error-handling logic via the `error` handler. When a\npromise rejects, an `error` event will be fired on that route and bubble up\nto `route:application`'s default error handler unless it is handled by a\ncustom error handler along the way, e.g.:\n\n```javascript {data-filename=app/routes/good-for-nothing.js}\nimport Route from '@ember/routing/route';\nimport { action } from '@ember/object';\n// import { service } from '@ember/service';\n\nexport default class GoodForNothingRoute extends Route {\n  // @service router;\n\n  model() {\n    return Promise.reject(\"FAIL\");\n  }\n\n  @action\n  error(reason) {\n    alert(reason); // \"FAIL\"\n\n    // Can transition to another route here, e.g.\n    // this.router.transitionTo('index');\n\n    // Uncomment the line below to bubble this error event:\n    // return true;\n  }\n}\n```\n\nIn the above example, the error event would stop right at\n`route:good-for-nothing`'s error handler and not continue to bubble. To\nmake the event continue bubbling up to `route:application`, you can\n`return true;` from the error handler.\n\n### Recovering from Rejection\n\nRejected model promises halt transitions, but because promises are chainable,\nyou can catch promise rejects within the `model` hook itself and convert\nthem into fulfills that won't halt the transition.\n\n```javascript {data-filename=app/routes/funky.js}\nimport Route from '@ember/routing/route';\n\nexport default class FunkyRoute extends Route {\n  model() {\n    return iHopeThisWorks().catch(function() {\n      // Promise rejected, fulfill with some default value to\n      // use as the route's model and continue on with the transition\n      return { msg: 'Recovered from rejected promise' };\n    });\n  }\n}\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"This section covers some more advanced features of the router and its capability for handling complex async logic within your app. A Word on Promisesâ€¦ \n\nEmber's approach to handling asynchronous logic in the router makes heavy use of the concept of Promises..."}}}