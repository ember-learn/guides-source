{"data":{"type":"contents","id":"routing/specifying-a-routes-model","attributes":{"content":"A route's JavaScript file is one of the best places in an app to make requests to an API.\nIn this section of the guides, you'll learn how to use the\n[`model`](https://api.emberjs.com/ember/release/classes/Route/methods/model?anchor=model)\nmethod to fetch data by making a HTTP request, and render it in a route's `hbs` template, or pass it down to a component.\n\nFor example, take this router:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('favorite-posts');\n});\n```\n\nIn Ember, functions that automatically run during rendering or setup are commonly referred to as \"hooks\".\nWhen a user first visits the `/favorite-posts` route, the `model` hook in `app/routes/favorite-posts.js` will automatically run.\nHere's an example of a model hook in use within a route:\n\n```javascript {data-filename=app/routes/favorite-posts.js}\nimport Route from '@ember/routing/route';\n\nexport default class FavoritePostsRoute extends Route {\n  model() {\n    console.log('The model hook just ran!');\n    return 'Hello Ember!';\n  }\n}\n```\n\n`model` hooks have some special powers:\n\n1. When you return data from this model, it becomes automatically available in the route's `.hbs` file as `@model` and in the route's controller as `this.model`.\n2. A `model` hook can return just about any type of data, like a string, object, or array, but the most common pattern is to return a JavaScript [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises).\n3. If you return a Promise from the model hook, your route will wait for the Promise to resolve before it renders the template.\n4. Since the `model` hook is Promise-aware, it is great for making API requests (using tools like [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)) and returning the results.\n5. When using the `model` hook to load data, you can take advantage of other niceties that Ember provides, like [automatic route transitions](../preventing-and-retrying-transitions/) after the data is returned, [loading screens, error handling](../loading-and-error-substates/), and more.\n6. The `model` hook may automatically re-run in certain conditions, as you'll read about below.\n\n## Using the `model` hook\n\nTo start, here's an example of returning a simple array from the `model` hook. Even if we eventually plan to fetch this data over a network, starting with something simple makes initial development of a new route quick and easy.\n\n```javascript {data-filename=app/routes/favorite-posts.js}\nimport Route from '@ember/routing/route';\n\nexport default class FavoritePostsRoute extends Route {\n  model() {\n    return [\n      { title: 'Ember Roadmap' },\n      { title: 'Accessibility in Ember' },\n      { title: 'EmberConf Recap' }\n    ];\n  }\n}\n```\n\nNow that data can be used in the `favorite-posts` template:\n\n```handlebars {data-filename=app/templates/favorite-posts.hbs}\n{{#each @model as |post|}}\n  <div>\n    {{post.title}}\n  </div>\n{{/each}}\n```\n\nBehind the scenes, what is happening is that the [route's controller](https://api.emberjs.com/ember/release/classes/Route/methods/setupController?anchor=setupController) receives the results of the model hook, and Ember makes the model hook results available to the template. Your app may not have a controller file for the route, but the behavior is the same regardless.\n\nLet's compare some examples using the model hook to make asynchronous HTTP requests to a server somewhere.\n\n### Fetch example\n\nFirst, here's an example using a core browser API called [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), which returns a Promise.\nInstall [`ember-fetch`](https://github.com/ember-cli/ember-fetch) with the command `ember install ember-fetch`, if it is not already in the app's `package.json`.\nOlder browsers may not have `fetch`, but the `ember-fetch` library includes a polyfill, so we don't have to worry about backwards compatibility!\n\n```javascript {data-filename=app/routes/photos.js}\nimport Route from '@ember/routing/route';\nimport fetch from 'fetch';\n\nexport default class PhotosRoute extends Route {\n  async model() {\n    const response = await fetch('/my-cool-end-point.json');\n    const photos = await response.json();\n\n    return { photos };\n  }\n}\n```\n\n### Ember Data example\n\nEmber Data is a powerful (but optional) library included by default in new Ember apps.\nIn the next example, we will use Ember Data's [`findAll`](https://api.emberjs.com/ember-data/release/classes/Store/methods/findAll?anchor=findAll) method, which returns a Promise, and resolves with an array of [Ember Data records](../../models/).\n\n```javascript {data-filename=app/routes/favorite-posts.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\n\nexport default class FavoritePostsRoute extends Route {\n  @service store;\n\n  model() {\n    return this.store.findAll('post');\n  }\n}\n```\n\nNote that Ember Data also has a feature called a [`Model`](https://api.emberjs.com/ember-data/release/classes/Model), but it's a separate concept from a route's [`model`](https://api.emberjs.com/ember/release/classes/Route/methods/model?anchor=model) hook.\n\n## Multiple Models\n\nWhat should you do if you need the `model` to return the results of multiple API requests?\n\nMultiple models can be returned through an\n[RSVP.hash](https://api.emberjs.com/ember/release/classes/rsvp/methods/hash?anchor=hash).\nThe `RSVP.hash` method takes an object containing multiple promises.\nIf all of the promises resolve, the returned promise will resolve to an object that contains the results of each request. For example:\n\n```javascript {data-filename=app/routes/songs.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\nimport RSVP from 'rsvp';\n\nexport default class SongsRoute extends Route {\n  @service store;\n\n  model() {\n    return RSVP.hash({\n      songs: this.store.findAll('song'),\n      albums: this.store.findAll('album')\n    });\n  }\n}\n```\n\nIn the `songs` template, we can specify both models and use the `{{#each}}` helper to display\neach record in the song model and album model:\n\n```handlebars {data-filename=app/templates/songs.hbs}\n<h1>Playlist</h1>\n\n<ul>\n  {{#each @model.songs as |song|}}\n    <li>{{song.name}} by {{song.artist}}</li>\n  {{/each}}\n</ul>\n\n<h1>Albums</h1>\n\n<ul>\n  {{#each @model.albums as |album|}}\n    <li>{{album.title}} by {{album.artist}}</li>\n  {{/each}}\n</ul>\n```\n\n## Dynamic Models\n\nIn the examples above, we showed a route that will always return the same data, a collection of favorite posts. Even when the user leaves and re-enters the `/posts` route, they will see the same thing.\nBut what if you need to request different data after user interaction?\nWhat if a specific post should load based on the URL that the user visited, like `posts/42`?\nIn Ember, this can be accomplished by defining routes with [dynamic\nsegments](../defining-your-routes/#toc_dynamic-segments), or by using [query parameters](../query-params/), and then using the dynamic data to make requests.\n\nIn the previous Guides topic, we showed making a dynamic segment in the app's `router.js`:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n```\n\nWhatever shows up in the URL at the `:post_id`, the dynamic segment, will be available in the params for the route's `model` hook:\n\n```javascript {data-filename=app/routes/post.js}\nimport Route from '@ember/routing/route';\n\nexport default class PostRoute extends Route {\n  model(params) {\n    console.log('This is the dynamic segment data: ' + params.post_id);\n    // make an API request that uses the id\n  }\n}\n```\n\nIf you do not define a model hook for a route, it will default to using Ember Data to look up the record, as shown below:\n\n```js\nmodel(params) {\n return this.store.findRecord('post', params.post_id);\n}\n```\n\nIn the `model` hook for routes with dynamic segments, it's your job to\nturn the ID (something like `47` or `post-slug`) into a model that can\nbe rendered by the route's template. In the above example, we use the\npost's ID (`params.post_id`) as an argument to Ember Data's `findRecord`\nmethod.\n\n### Linking to a dynamic segment\n\nThere are two ways to link to a dynamic segment from an `.hbs` template using [`<LinkTo>`](../../templates/links/).\nDepending on which approach you use, it will affect whether that route's `model` hook is run.\nTo learn how to link to a dynamic segment from within the JavaScript file, see the API documentation on\n[`transitionTo`](https://api.emberjs.com/ember/release/classes/RouterService/methods/transitionTo?anchor=transitionTo)\ninstead.\n\nWhen you provide a string or number to the `<LinkTo>`, the dynamic segment's `model` hook will run when the app transitions to the new route.\nIn this example, `photo.id` might have an id of `4`:\n\n```handlebars {data-filename=app/templates/photos.hbs}\n{{#each @model as |photo|}}\n  <LinkTo @route=\"photo\" @model={{photo.id}}>\n    link text to display\n  </LinkTo>\n{{/each}}\n```\n\nHowever, if you provide the entire model context, the model hook for that URL segment will _not_ be run.\nFor this reason, many Ember developers choose to pass only ids to `<LinkTo>` so that the behavior is consistent.\n\nHere's what it looks like to pass the entire `photo` record:\n\n```handlebars {data-filename=app/templates/photos.hbs}\n{{#each @model as |photo|}}\n  <LinkTo @route=\"photo\" @model={{photo}}>\n    link text to display\n  </LinkTo>\n{{/each}}\n```\n\nIf you decide to pass the entire model, be sure to cover this behavior in your [application tests](../../testing/testing-application/).\n\nIf a route you are trying to link to has multiple dynamic segments, like `/photos/4/comments/18`, be sure to specify all the necessary information for each segment:\n\n```handlebars\n<LinkTo @route=\"photos.photo.comments.comment\" @models={{array 4 18}}>\n  link text to display\n</LinkTo>\n```\n\nRoutes without dynamic segments will always execute the model hook.\n\n## Reusing Route Context\n\nSometimes you need to fetch a model, but your route doesn't have the parameters, because it's\na child route and the route directly above or a few levels above has the parameters that your route\nneeds.\nYou might run into this if you have a URL like `/album/4/songs/18`, and when you're in the songs route, you need an album ID.\n\nIn this scenario, you can use the `paramsFor` method to get the parameters of a parent route.\n\n```javascript {data-filename=app/routes/album/index.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\n\nexport default class AlbumIndexRoute extends Route {\n  @service store;\n\n  model() {\n    let { album_id } = this.paramsFor('album');\n\n    return this.store.query('song', { album: album_id });\n  }\n}\n```\n\nThis is guaranteed to work because the parent route is loaded. But if you tried to\ndo `paramsFor` on a sibling route, you wouldn't have the results you expected.\n\nThis is a great way to use the parent context to load something that you want.\nUsing `paramsFor` will also give you the query params defined on that route's controller.\nThis method could also be used to look up the current route's parameters from an action\nor another method on the route, and in that case we have a shortcut: `this.paramsFor(this.routeName)`.\n\nIn our case, the parent route had already loaded its songs, so we would be writing unnecessary fetching logic.\nLet's rewrite the same route, but use `modelFor`, which works the same way, but returns the model\nfrom the parent route.\n\n```javascript {data-filename=app/routes/album/index.js}\nimport Route from '@ember/routing/route';\n\nexport default class AlbumIndexRoute extends Route {\n  model() {\n    let { songs } = this.modelFor('album');\n\n    return songs;\n  }\n}\n```\n\nIn the case above, the parent route looked something like this:\n\n```javascript {data-filename=app/routes/album.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\nimport RSVP from 'rsvp';\n\nexport default class AlbumRoute extends Route {\n  @service store;\n  \n  model({ album_id }) {\n    return RSVP.hash({\n      album: this.store.findRecord('album', album_id),\n      songs: this.store.query('song', { album: album_id })\n    });\n  }\n}\n```\n\nAnd calling `modelFor` returned the result of the `model` hook.\n\n## Debugging models\n\nIf you are having trouble getting a model's data to show up in the template, here are some tips:\n\n- Use the [`{{debugger}}`](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods/debugger?anchor=debugger) or [`{{log}}`](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods/log?anchor=log) helper to inspect the `{{@model}}` from the template\n- return hard-coded sample data as a test to see if the problem is really in the model hook, or elsewhere down the line\n- study JavaScript Promises in general, to make sure you are returning data from the Promise correctly\n- make sure your `model` hook has a `return` statement\n- check to see whether the data returned from a `model` hook is an object, array, or JavaScript Primitive. For example, if the result of `model` is an array, using `{{@model}}` in the template won't work. You will need to iterate over the array with an [`{{#each}}`](https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods/each?anchor=each) helper. If the result is an object, you need to access the individual attribute like `{{@model.title}}` to render it in the template.\n- use your browser's development tools to examine the outgoing and incoming API responses and see if they match what your code expects\n- If you are using Ember Data, use the [Ember Inspector](../../ember-inspector/) browser plugin to explore the View Tree/Model and Data sections.","description":"A route's JavaScript file is one of the best places in an app to make requests to an API. In this section of the guides, you'll learn how to use the model method to fetch data by making a HTTP request, and render it in a route's hbs template, or pass it..."}}}