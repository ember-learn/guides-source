{"data":{"type":"contents","id":"routing/loading-and-error-substates","attributes":{"content":"The Ember Router allows you to provide feedback that a route is loading, as well\nas when an error occurs in loading a route.\n\nThe `error` and `loading` substates exist as a part of each route, so they\nshould not be added to your `router.js` file. To utilize a substate, the route, controller,\nand template may be optionally defined as desired.\n\n## `loading` substates\n\nDuring the `beforeModel`, `model`, and `afterModel` hooks, data may take some\ntime to load. Technically, the router pauses the transition until the promises\nreturned from each hook fulfill.\n\nConsider the following:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('slow-model');\n});\n```\n\n```javascript {data-filename=app/routes/slow-model.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\n\nexport default class SlowModelRoute extends Route {\n  @service store;\n\n  model() {\n    return this.store.findAll('slow-model');\n  }\n}\n```\n\nIf you navigate to `slow-model`, in the `model` hook using [Ember Data](../../models/),\nthe query may take a long time to complete.\nDuring this time, your UI isn't really giving you any feedback as to\nwhat's happening. If you're entering this route after a full page\nrefresh, your UI will be entirely blank, as you have not actually\nfinished fully entering any route and haven't yet displayed any\ntemplates. If you're navigating to `slow-model` from another\nroute, you'll continue to see the templates from the previous route\nuntil the model finish loading, and then, boom, suddenly all the\ntemplates for `slow-model` load.\n\nSo, how can we provide some visual feedback during the transition?\n\nSimply define a template called `loading` (and optionally a corresponding route)\nthat Ember will transition to. The\nintermediate transition into the loading substate happens immediately\n(synchronously), the URL won't be updated, and, unlike other transitions, the\ncurrently active transition won't be aborted.\n\nOnce the main transition into `slow-model` completes, the `loading`\nroute will be exited and the transition to `slow-model` will continue.\n\nFor nested routes, like:\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('user', function() {\n    this.route('about', function() {\n      this.route('slow-model');\n    });\n  });\n});\n```\n\nEach of the following assumes a transition from the application or index route.\n\nWhen accessing `user.about.slow-model` route then Ember will alternate trying to\nfind a `routeName-loading` or `loading` template in the hierarchy starting with\n`user.about.slow-model-loading`:\n\n1. `user.about.slow-model-loading`\n2. `user.about.loading` or `user.about-loading`\n3. `user.loading` or `user-loading`\n4. `loading` or `application-loading`\n\nIt's important to note that for `slow-model` itself, Ember will not try to\nfind a `slow-model.loading` template but for the rest of the hierarchy either\nsyntax is acceptable. This can be useful for creating a custom loading screen\nfor a leaf route like `slow-model`.\n\nWhen accessing `user.about` route then Ember will search for:\n\n1. `user.about-loading`\n2. `user.loading` or `user-loading`\n3. `loading` or `application-loading`\n\nIt's important to note that `user.about.loading` template is not considered now.\n\nEmber will *not* look above the common parent in a transition between child\nroutes. For example, if the user transitions from `user.about.index` to\n`user.about.slow-model` the following search for template will happen:\n\n1. `user.about.slow-model-loading`\n2. `user.about.loading` or `user.about-loading`\n\nNotice that `user.loading`, `user-loading`, `loading`, and `application-loading`\nare not included here, Since `about` is the common parent for `index` and `slow-model`. This means we'll need to handle loading at every level\nwithin the route hierarchy where loading feedback is important.\n\n\n### The `loading` event\n\nIf the various `beforeModel`/`model`/`afterModel` hooks\ndon't immediately resolve, a [`loading`](https://api.emberjs.com/ember/release/classes/Route/events/loading?anchor=loading) event will be fired on that route.\n\n```javascript {data-filename=app/routes/user-slow-model.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\nimport { action } from '@ember/object';\n\nexport default class UserSlowModelRoute extends Route {\n  @service store;\n  \n  model() {\n    return this.store.findAll('slow-model');\n  }\n\n  @action\n  loading(transition, originRoute) {\n    let controller = this.controllerFor('foo');\n    controller.set('currentlyLoading', true);\n    return true; // allows the loading template to be shown\n  }\n}\n```\n\nIf the `loading` handler is not defined at the specific route,\nthe event will continue to bubble above a transition's parent\nroute, providing the `application` route the opportunity to manage it.\n\nWhen using the `loading` handler, we can make use of the transition promise to know when the loading event is over:\n\n```javascript {data-filename=app/routes/user-slow-model.js}\nimport Route from '@ember/routing/route';\nimport { action } from '@ember/object';\n\nexport default class UserSlowModelRoute extends Route {\n  // ...\n  @action\n  async loading(transition, originRoute) {\n    let controller = this.controllerFor('foo');\n    controller.set('currentlyLoading', true);\n    transition.promise.finally(function() {\n        controller.set('currentlyLoading', false);\n    });\n  }\n};\n```\n\nIn case we want both custom logic and the default behavior for the loading substate,\nwe can implement the `loading` action and let it bubble by returning `true`.\n\n```javascript {data-filename=app/routes/user-slow-model.js}\nimport Route from '@ember/routing/route';\nimport { action } from '@ember/object';\n\nexport default class UserSlowModelRoute extends Route {\n  // ...\n  @action\n  loading(transition) {\n    let start = new Date();\n    transition.promise.finally(() => {\n      this.notifier.notify(`Took ${new Date() - start}ms to load`);\n    });\n\n    return true;\n  }\n};\n```\n\n## `error` substates\n\nEmber provides an analogous approach to `loading` substates in\nthe case of errors encountered during a transition.\n\nSimilar to how the default `loading` event handlers are implemented,\nthe default `error` handlers will look for an appropriate error substate to\nenter, if one can be found.\n\n```javascript {data-filename=app/router.js}\nRouter.map(function() {\n  this.route('articles', function() {\n    this.route('overview');\n  });\n});\n```\n\nAs with the `loading` substate, on a thrown error or rejected promise returned\nfrom the `articles.overview` route's `model` hook (or `beforeModel` or\n`afterModel`) Ember will look for an error template or route in the following\norder:\n\n1. `articles.overview-error`\n2. `articles.error` or `articles-error`\n3. `error` or `application-error`\n\nIf one of the above is found, the router will immediately transition into\nthat substate (without updating the URL). The \"reason\" for the error\n(i.e. the exception thrown or the promise reject value) will be passed\nto that error state as its `model`.\n\nThe model hooks (`beforeModel`, `model`, and `afterModel`) of an error substate\nare not called. Only the `setupController` method of the error substate is\ncalled with the `error` as the model. See example below:\n\n```javascript\nsetupController(controller, error) {\n  console.log(error.message);\n  super.setupController(...arguments)\n}\n```\n\nIf no viable error substates can be found, an error message will be\nlogged.\n\n### The `error` event\n\nIf the `articles.overview` route's `model` hook returns a promise that rejects\n(for instance the server returned an error, the user isn't logged in,\netc.), an [`error`](https://api.emberjs.com/ember/release/classes/Route/events/error?anchor=error) event will fire from that route and bubble upward.\nThis `error` event can be handled and used to display an error message,\nredirect to a login page, etc.\n\n```javascript {data-filename=app/routes/articles-overview.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\nimport { action } from '@ember/object';\n\nexport default class ArticlesOverviewRoute extends Route {\n  @service store;\n  @service router;\n\n  model(params) {\n    return this.store.findAll('privileged-model');\n  }\n\n  @action\n  error(error, transition) {\n    if (error.status === '403') {\n      this.router.replaceWith('login');\n    } else {\n      // Let the route above this handle the error.\n      return true;\n    }\n  }\n};\n```\n\nAnalogous to the `loading` event, you could manage the `error` event\nat the application level to avoid writing the same code for multiple routes.\n\nIn case we want to run some custom logic and have the default behavior of rendering the error template,\nwe can handle the `error` event and let it bubble by returning `true`.\n\n```javascript {data-filename=app/routes/articles-overview.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\nimport { action } from '@ember/object';\n\nexport default class ArticlesOverviewRoute extends Route {\n  @service store;\n  \n  model(params) {\n    return this.get('store').findAll('privileged-model');\n  }\n\n  @action\n  error(error) {\n    this.notifier.error(error);\n    return true;\n  }\n};\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"The Ember Router allows you to provide feedback that a route is loading, as well as when an error occurs in loading a route. \n\nThe error and loading substates exist as a part of each route, so they should not be added to your router.js file. To utilize a..."}}}