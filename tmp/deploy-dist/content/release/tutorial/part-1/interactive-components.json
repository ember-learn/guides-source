{"data":{"type":"contents","id":"tutorial/part-1/interactive-components","attributes":{"content":"<!-- Heads up! This is a generated file, do not edit directly. You can find the source at https://github.com/ember-learn/super-rentals-tutorial/blob/master/src/markdown/tutorial/part-1/06-interactive-components.md -->\n\nIn this chapter, you will add interactivity to the page, allowing the user to click an image to enlarge or shrink it:\n\n<!-- TODO: make this a gif instead -->\n\n<img src=\"/images/tutorial/part-1/interactive-components/rental-image-default@2x.png\" alt=\"The Super Rentals app by the end of the chapter (default image size)\" width=\"1024\" height=\"1129\">\n\n<img src=\"/images/tutorial/part-1/interactive-components/rental-image-large@2x.png\" alt=\"The Super Rentals app by the end of the chapter (large image size)\" width=\"1024\" height=\"1500\">\n\nWhile doing so, you will learn about:\n\n- Adding behavior to components with classes\n- Accessing instance states from templates\n- Managing state with tracked properties\n- Using conditionals syntaxes in templates\n- Responding to user interaction with actions\n- Invoking element modifiers\n- Testing user interactions\n\n## Adding Behavior to Components with Classes\n\nSo far, all the components we have written are purely _presentational_â€”they are simply reusable snippets of markup. That's pretty cool! But in Ember, components can do so much more.\n\nSometimes, you want to associate some _[behavior](https://developer.mozilla.org/docs/Learn/JavaScript/Building_blocks/Events)_ with your components so that they can do more interesting things. For example, `<LinkTo>` can respond to clicks by changing the URL and navigating us to a different page.\n\nHere, we are going to do just that! We are going to implement the \"View Larger\" and \"View Smaller\" functionality, which will allow our users to click on a property's image to view a larger version, and click on it again to return to the smaller version.\n\nIn other words, we want a way to _toggle_ the image between one of the two _[states](../../../components/component-state-and-actions/)_. In order to do that, we need a way for the component to store two possible states, and to be aware of which state it is currently in.\n\nEmber optionally allows us to associate JavaScript code with a component for exactly this purpose. We can add a JavaScript file for our `<Rental::Image>` component by running the `component-class` generator:\n\n```shell\n$ ember generate component-class rental/image\ninstalling component-class\n  create app/components/rental/image.js\n```\n\nThis generated a JavaScript file with the same name as our component's template at `app/components/rental/image.js`. It contains a _[JavaScript class](https://javascript.info/class)_, _[inheriting](https://javascript.info/class-inheritance)_ from `@glimmer/component`.\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        <p><code>@glimmer/component</code>, or <em><a href=\"../../../upgrading/current-edition/glimmer-components/\">Glimmer component</a></em>, is one of the several component classes available to use. They are a great starting point whenever you want to add behavior to your components. In this tutorial, we will be using Glimmer components exclusively.</p>        \n<p>In general, Glimmer components should be used whenever possible. However, you may also see <code>@ember/components</code>, or <em><a href=\"https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/\">classic components</a></em>, used in older apps. You can tell them apart by looking at their import path (which is helpful for looking up the respective documentation, as they have different and incompatible APIs).</p>\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\nEmber will create an _instance_ of the class whenever our component is invoked. We can use that instance to store our state:\n\n```js { data-filename=\"app/components/rental/image.js\" data-diff=\"-3,+4,+5,+6,+7,+8,+9\" }\nimport Component from '@glimmer/component';\n\nexport default class RentalImageComponent extends Component {}\nexport default class RentalImageComponent extends Component {\n  constructor(...args) {\n    super(...args);\n    this.isLarge = false;\n  }\n}\n```\n\nHere, in the _component's constructor_, we _initialized_ the _instance variable_ `this.isLarge` with the value `false`, since this is the default state that we want for our component.\n\n## Accessing Instance States from Templates\n\nLet's update our template to use this state we just added:\n\n```handlebars { data-filename=\"app/components/rental/image.hbs\" data-diff=\"-1,-2,-3,+4,+5,+6,+7,+8,+9,+10,+11,+12,+13,+14\" }\n<div class=\"image\">\n  <img ...attributes>\n</div>\n{{#if this.isLarge}}\n  <div class=\"image large\">\n    <img ...attributes>\n    <small>View Smaller</small>\n  </div>\n{{else}}\n  <div class=\"image\">\n    <img ...attributes>\n    <small>View Larger</small>\n  </div>\n{{/if}}\n```\n\nIn the template, we have access to the component's instance variables. The `{{#if ...}}...{{else}}...{{/if}}` _[conditionals](../../../components/conditional-content/)_ syntax allows us to render different content based on a condition (in this case, the value of the instance variable `this.isLarge`). Combining these two features, we can render either the small or the large version of the image accordingly.\n\nWe can verify this works by temporarily changing the initial value in our JavaScript file. If we change `app/components/rental/image.js` to initialize `this.isLarge = true;` in the constructor, we should see the large version of the property image in the browser. Cool!\n\n<img src=\"/images/tutorial/part-1/interactive-components/is-large-true@2x.png\" alt=\"&lt;Rental::Image&gt; with this.isLarge set to true\" width=\"1024\" height=\"1500\">\n\nOnce we've tested this out, we can change `this.isLarge` back to `false`.\n\nSince this pattern of initializing instance variables in the constructor is pretty common, there happens to be a much more concise syntax for it:\n\n```js { data-filename=\"app/components/rental/image.js\" data-diff=\"-4,-5,-6,-7,+8\" }\nimport Component from '@glimmer/component';\n\nexport default class RentalImageComponent extends Component {\n  constructor(...args) {\n    super(...args);\n    this.isLarge = false;\n  }\n  isLarge = false;\n}\n```\n\nThis does exactly the same thing as before, but it's much shorter and less to type!\n\nOf course, our users cannot edit our source code, so we need a way for them to toggle the image size from the browser. Specifically, we want to toggle the value of `this.isLarge` whenever the user clicks on our component.\n\n## Managing State with Tracked Properties\n\nLet's modify our class to add a _[method](../../../in-depth-topics/native-classes-in-depth/#toc_methods)_ for toggling the size:\n\n```js { data-filename=\"app/components/rental/image.js\" data-diff=\"+2,+3,-6,+7,+8,+9,+10,+11\" }\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class RentalImageComponent extends Component {\n  isLarge = false;\n  @tracked isLarge = false;\n\n  @action toggleSize() {\n    this.isLarge = !this.isLarge;\n  }\n}\n```\n\nWe did a few things here, so let's break it down.\n\nFirst, we added the `@tracked` _[decorator](../../../in-depth-topics/native-classes-in-depth/#toc_decorators)_ to the `isLarge` instance variable. This annotation tells Ember to monitor this variable for updates. Whenever this variable's value changes, Ember will automatically re-render any templates that depend on its value.\n\nIn our case, whenever we assign a new value to `this.isLarge`, the `@tracked` annotation will cause Ember to re-evaluate the `{{#if this.isLarge}}` conditional in our template, and will switch between the two _[blocks](../../../components/conditional-content/#toc_block-if)_ accordingly.\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        <p>Don't worry! If you reference a variable in the template but forget to add the <code>@tracked</code> decorator, you will get a helpful development mode error when you change its value!</p>\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\n## Responding to User Interaction with Actions\n\nNext, we added a `toggleSize` method to our class that switches `this.isLarge` to the opposite of its current state (`false` becomes `true`, or `true` becomes `false`).\n\nFinally, we added the `@action` decorator to our method. This indicates to Ember that we intend to use this method from our template. Without this, the method will not function properly as a callback function (in this case, a click handler).\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        <p>If you forget to add the <code>@action</code> decorator, you will also get a helpful error when clicking on the button in development mode!</p>\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\nWith that, it's time to wire this up in the template:\n\n```handlebars { data-filename=\"app/components/rental/image.hbs\" data-diff=\"-2,+3,-6,+7,-9,+10,-13,+14\" }\n{{#if this.isLarge}}\n  <div class=\"image large\">\n  <button type=\"button\" class=\"image large\" {{on \"click\" this.toggleSize}}>\n    <img ...attributes>\n    <small>View Smaller</small>\n  </div>\n  </button>\n{{else}}\n  <div class=\"image\">\n  <button type=\"button\" class=\"image\" {{on \"click\" this.toggleSize}}>\n    <img ...attributes>\n    <small>View Larger</small>\n  </div>\n  </button>\n{{/if}}\n```\n\nWe changed two things here.\n\nFirst, since we wanted to make our component interactive, we switched the containing tag from `<div>` to `<button>` (this is important for accessibility reasons). By using the correct semantic tag, we will also get focusability and keyboard interaction handling \"for free\".\n\nNext, we used the `{{on}}` _[modifier](../../../components/template-lifecycle-dom-and-modifiers/#toc_event-handlers)_ to attach `this.toggleSize` as a click handler on the button.\n\nWith that, we have created our first _interactive_ component. Go ahead and try it in the browser!\n\n<!-- TODO: make this a gif instead -->\n\n<img src=\"/images/tutorial/part-1/interactive-components/rental-image-default@2x.png\" alt=\"&lt;Rental::Image&gt; (default size)\" width=\"1024\" height=\"1129\">\n\n<img src=\"/images/tutorial/part-1/interactive-components/rental-image-large@2x.png\" alt=\"&lt;Rental::Image&gt; (large size)\" width=\"1024\" height=\"1500\">\n\n## Testing User Interactions\n\nFinally, let's write a test for this new behavior:\n\n```js { data-filename=\"tests/integration/components/rental/image-test.js\" data-diff=\"-3,+4,+24,+25,+26,+27,+28,+29,+30,+31,+32,+33,+34,+35,+36,+37,+38,+39,+40,+41,+42,+43,+44,+45,+46,+47\" }\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'super-rentals/tests/helpers';\nimport { render } from '@ember/test-helpers';\nimport { render, click } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\n\nmodule('Integration | Component | rental/image', function (hooks) {\n  setupRenderingTest(hooks);\n\n  test('it renders the given image', async function (assert) {\n    await render(hbs`\n      <Rental::Image\n        src=\"/assets/images/teaching-tomster.png\"\n        alt=\"Teaching Tomster\"\n      />\n    `);\n\n    assert\n      .dom('.image img')\n      .exists()\n      .hasAttribute('src', '/assets/images/teaching-tomster.png')\n      .hasAttribute('alt', 'Teaching Tomster');\n  });\n\n  test('clicking on the component toggles its size', async function (assert) {\n    await render(hbs`\n      <Rental::Image\n        src=\"/assets/images/teaching-tomster.png\"\n        alt=\"Teaching Tomster\"\n      />\n    `);\n\n    assert.dom('button.image').exists();\n\n    assert.dom('.image').doesNotHaveClass('large');\n    assert.dom('.image small').hasText('View Larger');\n\n    await click('button.image');\n\n    assert.dom('.image').hasClass('large');\n    assert.dom('.image small').hasText('View Smaller');\n\n    await click('button.image');\n\n    assert.dom('.image').doesNotHaveClass('large');\n    assert.dom('.image small').hasText('View Larger');\n  });\n});\n```\n\n<img src=\"/images/tutorial/part-1/interactive-components/pass@2x.png\" alt=\"Tests passing with the new &lt;Rental::Image&gt; test\" width=\"1024\" height=\"512\">\n\nLet's clean up our template before moving on. We introduced a lot of duplication when we added the conditional in the template. If we look closely, the only things that are different between the two blocks are:\n\n1. The presence of the `\"large\"` CSS class on the `<button>` tag.\n2. The \"View Larger\" and \"View Smaller\" text.\n\nThese changes are buried deep within the large amount of duplicated code. We can reduce the duplication by using an `{{if}}` _[expression](../../../components/conditional-content/#toc_inline-if)_ instead:\n\n```handlebars { data-filename=\"app/components/rental/image.hbs\" data-diff=\"-1,-2,-3,+4,+5,+6,-8,-9,-10,-11,+12,-14,-15,+16,+17\" }\n{{#if this.isLarge}}\n  <button type=\"button\" class=\"image large\" {{on \"click\" this.toggleSize}}>\n    <img ...attributes>\n<button type=\"button\" class=\"image {{if this.isLarge \"large\"}}\" {{on \"click\" this.toggleSize}}>\n  <img ...attributes>\n  {{#if this.isLarge}}\n    <small>View Smaller</small>\n  </button>\n{{else}}\n  <button type=\"button\" class=\"image\" {{on \"click\" this.toggleSize}}>\n    <img ...attributes>\n  {{else}}\n    <small>View Larger</small>\n  </button>\n{{/if}}\n  {{/if}}\n</button>\n```\n\nThe expression version of `{{if}}` takes two arguments. The first argument is the condition. The second argument is the expression that should be evaluated if the condition is true.\n\nOptionally, `{{if}}` can take a third argument for what the expression should evaluate into if the condition is false. This means we could rewrite the button label like so:\n\n```handlebars { data-filename=\"app/components/rental/image.hbs\" data-diff=\"-3,-4,-5,-6,-7,+8\" }\n<button type=\"button\" class=\"image {{if this.isLarge \"large\"}}\" {{on \"click\" this.toggleSize}}>\n  <img ...attributes>\n  {{#if this.isLarge}}\n    <small>View Smaller</small>\n  {{else}}\n    <small>View Larger</small>\n  {{/if}}\n  <small>View {{if this.isLarge \"Smaller\" \"Larger\"}}</small>\n</button>\n```\n\nWhether or not this is an improvement in the clarity of our code is mostly a matter of taste. Either way, we have significantly reduced the duplication in our code, and made the important bits of logic stand out from the rest.\n\nRun the test suite one last time to confirm our refactor didn't break anything unexpectedly, and we will be ready for the next challenge!\n\n<img src=\"/images/tutorial/part-1/interactive-components/pass-2@2x.png\" alt=\"Tests still passing after the refactor\" width=\"1024\" height=\"512\">","description":"In this chapter, you will add interactivity to the page, allowing the user to click an image to enlarge or shrink it:  \n\n \n\n \n\nWhile doing so, you will learn about: \n\n- Adding behavior to components with classes\n- Accessing instance states from templates\n-..."}}}