{"data":{"type":"contents","id":"tutorial/part-1/working-with-data","attributes":{"content":"<!-- Heads up! This is a generated file, do not edit directly. You can find the source at https://github.com/ember-learn/super-rentals-tutorial/blob/master/src/markdown/tutorial/part-1/08-working-with-data.md -->\n\nIn this chapter, we will remove the hard-coded data from our `<Rental>` component. By the end, your app would finally be displaying real data that came from the server:\n\n<img src=\"/images/tutorial/part-1/working-with-data/three-properties@2x.png\" alt=\"The Super Rentals app by the end of the chapter\" width=\"1024\" height=\"1129\">\n\nIn this chapter, you will learn about:\n\n- Working with route files\n- Returning local data from the model hook\n- Accessing route models from templates\n- Mocking server data with static JSON files\n- Fetching remote data from the model hook\n- Adapting server data\n- Loops and local variables in templates with `{{#each}}`\n\n## Working with Route Files\n\nSo far, we've been hard-coding everything into our `<Rental>` component. But that's probably not very sustainable, since eventually, we want our data to come from a server instead. Let's go ahead and move some of those hard-coded values out of the component in preparation for that.\n\nWe want to start working towards a place where we can eventually fetch data from the server, and then render the requested data as dynamic content from the templates. In order to do that, we will need a place where we can write the code for fetching data and loading it into the routes.\n\nIn Ember, _[route files](../../../routing/defining-your-routes/)_ are the place to do that. We haven't needed them yet, because all our routes are essentially just rendering static pages up until this point, but we are about to change that.\n\nLet's start by creating a route file for the index route. We will create a new file at `app/routes/index.js` with the following content:\n\n```js { data-filename=\"app/routes/index.js\" }\nimport Route from '@ember/routing/route';\n\nexport default class IndexRoute extends Route {\n  async model() {\n    return {\n      title: 'Grand Old Mansion',\n      owner: 'Veruca Salt',\n      city: 'San Francisco',\n      location: {\n        lat: 37.7749,\n        lng: -122.4194,\n      },\n      category: 'Estate',\n      type: 'Standalone',\n      bedrooms: 15,\n      image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',\n      description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',\n    };\n  }\n}\n```\n\nThere's a lot happening here that we haven't seen before, so let's walk through this. First, we're importing the _[`Route` class](https://api.emberjs.com/ember/release/classes/Route)_ into the file. This class is used as a starting point for adding functionality to a route, such as loading data.\n\nThen, we are extending the `Route` class into our _own_ `IndexRoute`, which we also _[`export`](https://javascript.info/import-export#export-default)_ so that the rest of the application can use it.\n\n## Returning Local Data from the Model Hook\n\nSo far, so good. But what's happening inside of this route class? We implemented an _[async](https://developer.mozilla.org/docs/Learn/JavaScript/Asynchronous/Concepts)_ method called `model()`. This method is also known as the _model hook_.\n\nThe model hook is responsible for fetching and preparing any data that you need for your route. Ember will automatically call this hook when entering a route, so that you can have an opportunity to run your own code to get the data you need. The object returned from this hook is known as the _[model](../../../routing/specifying-a-routes-model/)_ for the route (surprise!).\n\nUsually, this is where we'd fetch data from a server. Since fetching data is usually an asynchronous operation, the model hook is marked as `async`. This gives us the option of using the `await` keyword to wait for the data fetching operations to finish.\n\nWe'll get to that bit later on. At the moment, we are just returning the same hard-coding model data, extracted from the `<Rental>` component, but in a _[JavaScript object](https://developer.mozilla.org/docs/Learn/JavaScript/Objects/Basics)_ format.\n\n## Accessing Route Models from Templates\n\nSo, now that we've prepared some model data for our route, let's use it in our template. In route templates, we can access the model for the route as `@model`. In our case, that would contain the POJO returned from our model hook.\n\nTo test that this is working, let's modify our template and try to render the `title` property from our model:\n\n```handlebars { data-filename=\"app/templates/index.hbs\" data-diff=\"+7,+8\" }\n<Jumbo>\n  <h2>Welcome to Super Rentals!</h2>\n  <p>We hope you find exactly what you're looking for in a place to stay.</p>\n  <LinkTo @route=\"about\" class=\"button\">About Us</LinkTo>\n</Jumbo>\n\n<h1>{{@model.title}}</h1>\n\n<div class=\"rentals\">\n  <ul class=\"results\">\n    <li><Rental /></li>\n    <li><Rental /></li>\n    <li><Rental /></li>\n  </ul>\n</div>\n```\n\nIf we look at our page in the browser, we should see our model data reflected as a new header.\n\n<img src=\"/images/tutorial/part-1/working-with-data/model-header@2x.png\" alt=\"New header using the @model data\" width=\"1024\" height=\"512\">\n\nAwesome!\n\nOkay, now that we know that we have a model to use at our disposal, let's remove some of the hard-coding that we did earlier! Instead of explicitly hard-coding the rental information into our `<Rental>` component, we can pass the model object to our component instead.\n\nLet's try it out.\n\nFirst, let's pass in our model to our `<Rental>` component as the `@rental` argument. We will also remove the extraneous `<h1>` tag we added earlier, now that we know things are working:\n\n```handlebars { data-filename=\"app/templates/index.hbs\" data-diff=\"-7,-8,-11,-12,-13,+14,+15,+16\" }\n<Jumbo>\n  <h2>Welcome to Super Rentals!</h2>\n  <p>We hope you find exactly what you're looking for in a place to stay.</p>\n  <LinkTo @route=\"about\" class=\"button\">About Us</LinkTo>\n</Jumbo>\n\n<h1>{{@model.title}}</h1>\n\n<div class=\"rentals\">\n  <ul class=\"results\">\n    <li><Rental /></li>\n    <li><Rental /></li>\n    <li><Rental /></li>\n    <li><Rental @rental={{@model}} /></li>\n    <li><Rental @rental={{@model}} /></li>\n    <li><Rental @rental={{@model}} /></li>\n  </ul>\n</div>\n```\n\nBy passing in `@model` into the `<Rental>` component as the `@rental` argument, we will have access to our \"Grand Old Mansion\" model object in the `<Rental>` component's template! Now, we can replace our hard-coded values in this component by using the values that live on our `@rental` model.\n\n```handlebars { data-filename=\"app/components/rental.hbs\" data-diff=\"-3,-4,+5,+6,-9,+10,-12,+13,-16,+17,-20,+21,-24,+25,-29,-30,+31,+32,-36,+37\" }\n<article class=\"rental\">\n  <Rental::Image\n    src=\"https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg\"\n    alt=\"A picture of Grand Old Mansion\"\n    src={{@rental.image}}\n    alt=\"A picture of {{@rental.title}}\"\n  />\n  <div class=\"details\">\n    <h3>Grand Old Mansion</h3>\n    <h3>{{@rental.title}}</h3>\n    <div class=\"detail owner\">\n      <span>Owner:</span> Veruca Salt\n      <span>Owner:</span> {{@rental.owner}}\n    </div>\n    <div class=\"detail type\">\n      <span>Type:</span> Standalone\n      <span>Type:</span> {{@rental.type}}\n    </div>\n    <div class=\"detail location\">\n      <span>Location:</span> San Francisco\n      <span>Location:</span> {{@rental.city}}\n    </div>\n    <div class=\"detail bedrooms\">\n      <span>Number of bedrooms:</span> 15\n      <span>Number of bedrooms:</span> {{@rental.bedrooms}}\n    </div>\n  </div>\n  <Map\n    @lat=\"37.7749\"\n    @lng=\"-122.4194\"\n    @lat={{@rental.location.lat}}\n    @lng={{@rental.location.lng}}\n    @zoom=\"9\"\n    @width=\"150\"\n    @height=\"150\"\n    alt=\"A map of Grand Old Mansion\"\n    alt=\"A map of {{@rental.title}}\"\n  />\n</article>\n```\n\nSince the model object contains exactly the same data as the previously-hard-coded \"Grand Old Mansion\", the page should look exactly the same as before the change.\n\n<img src=\"/images/tutorial/part-1/working-with-data/using-model-data@2x.png\" alt=\"New header using the @model data\" width=\"1024\" height=\"512\">\n\nNow, we have one last thing to do: update the tests to reflect this change.\n\nBecause component tests are meant to render and test a single component in isolation from the rest of the app, they do not perform any routing, which means we won't have access to the same data returned from the `model` hook.\n\nTherefore, in our `<Rental>` component's test, we will have to feed the data into it some other way. We can do this using the `setProperties` we learned about from the [previous chapter](../reusable-components/).\n\n```js { data-filename=\"tests/integration/components/rental-test.js\" data-diff=\"-10,+11,+12,+13,+14,+15,+16,+17,+18,+19,+20,+21,+22,+23,+24,+25,+26,+27,+28,+29,+30\" }\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'super-rentals/tests/helpers';\nimport { render } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\n\nmodule('Integration | Component | rental', function (hooks) {\n  setupRenderingTest(hooks);\n\n  test('it renders information about a rental property', async function (assert) {\n    await render(hbs`<Rental />`);\n    this.setProperties({\n      rental: {\n        title: 'Grand Old Mansion',\n        owner: 'Veruca Salt',\n        city: 'San Francisco',\n        location: {\n          lat: 37.7749,\n          lng: -122.4194,\n        },\n        category: 'Estate',\n        type: 'Standalone',\n        bedrooms: 15,\n        image:\n          'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',\n        description:\n          'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',\n      },\n    });\n\n    await render(hbs`<Rental @rental={{this.rental}} />`);\n\n    assert.dom('article').hasClass('rental');\n    assert.dom('article h3').hasText('Grand Old Mansion');\n    assert.dom('article .detail.owner').includesText('Veruca Salt');\n    assert.dom('article .detail.type').includesText('Standalone');\n    assert.dom('article .detail.location').includesText('San Francisco');\n    assert.dom('article .detail.bedrooms').includesText('15');\n    assert.dom('article .image').exists();\n    assert.dom('article .map').exists();\n  });\n});\n```\n\nNotice that we also need to update the invocation of the `<Rental>` component in the `render` function call to also have a `@rental` argument passed into it. If we run our tests now, they should all pass!\n\n<img src=\"/images/tutorial/part-1/working-with-data/pass@2x.png\" alt=\"All our tests are passing\" width=\"1024\" height=\"768\">\n\n## Mocking Server Data with Static JSON Files\n\nNow that we have things in place, let's do the fun part of removing _all_ our hard-coded values from the model hook and actually fetch some data from the server!\n\nIn a production app, the data that we'd fetch would most likely come from a remote API server. To avoid setting up an API server just for this tutorial, we will put some JSON data into the `public` folder instead. That way, we can still request this JSON data with regular HTTP requests—just like we would with a real API server —but without having to write any server logic.\n\nBut where will the data come from? You can <a href=\"/downloads/data.zip\" download=\"data.zip\">download this data file</a>, where we have prepared some JSON data and bundled it into a `.zip` file format. Extract its content into the `public` folder.\n\nWhen you are done, your `public` folder should now have the following content:\n\n```plain\npublic\n├── api\n│   ├── rentals\n│   │   ├── downtown-charm.json\n│   │   ├── grand-old-mansion.json\n│   │   └── urban-living.json\n│   └── rentals.json\n├── assets\n│   └── images\n│       └── teaching-tomster.png\n└── robots.txt\n\n4 directories, 6 files\n```\n\nYou can verify that everything is working correctly by navigating to `http://localhost:4200/api/rentals.json`.\n\n<img src=\"/images/tutorial/part-1/working-with-data/data@2x.png\" alt=\"Our server serving up our rental properties as JSON data\" width=\"1024\" height=\"512\">\n\nAwesome! Our \"server\" is now up and running, serving up our rental properties as JSON data.\n\n## Fetching Remote Data from the Model Hook\n\nNow, let's turn our attention to our model hook again. We need to change it so that we actually fetch the data from the server.\n\n```js { data-filename=\"app/routes/index.js\" data-diff=\"-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,+19,+20,+21\" }\nimport Route from '@ember/routing/route';\n\nexport default class IndexRoute extends Route {\n  async model() {\n    return {\n      title: 'Grand Old Mansion',\n      owner: 'Veruca Salt',\n      city: 'San Francisco',\n      location: {\n        lat: 37.7749,\n        lng: -122.4194,\n      },\n      category: 'Estate',\n      type: 'Standalone',\n      bedrooms: 15,\n      image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',\n      description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',\n    };\n    let response = await fetch('/api/rentals.json');\n    let parsed = await response.json();\n    return parsed;\n  }\n}\n```\n\nWhat's happening here?\n\nFirst off, we're using the browser's _[Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)_ to request that JSON data from our server's API at `public/api/rentals.json`, the same URL we visited earlier.\n\nAs mentioned above, fetching data from the server is usually an asynchronous operation. The Fetch API takes this into account, which is why `fetch` is an `async` function, just like our model hook. To consume its response, we will have to pair it with the `await` keyword.\n\nThe Fetch API returns a _[response object](https://developer.mozilla.org/docs/Web/API/Response)_ asynchronously. Once we have this object, we can convert the server's response into whatever format we need; in our case, we knew the server sent the data using the JSON format, so we can use the `json()` method to _[parse](https://developer.mozilla.org/docs/Web/API/Body/json)_ the response data accordingly. Parsing the response data is _also_ an asynchronous operation, so we'll just use the `await` keyword here, too.\n\n## Adapting Server Data\n\nBefore we go any further, let's pause for a second to look at the server's data again.\n\n```json { data-filename=\"public/api/rentals.json\" }\n{\n  \"data\": [\n    {\n      \"type\": \"rentals\",\n      \"id\": \"grand-old-mansion\",\n      \"attributes\": {\n        \"title\": \"Grand Old Mansion\",\n        \"owner\": \"Veruca Salt\",\n        \"city\": \"San Francisco\",\n        \"location\": {\n          \"lat\": 37.7749,\n          \"lng\": -122.4194\n        },\n        \"category\": \"Estate\",\n        \"bedrooms\": 15,\n        \"image\": \"https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg\",\n        \"description\": \"This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.\"\n      }\n    },\n    {\n      \"type\": \"rentals\",\n      \"id\": \"urban-living\",\n      \"attributes\": {\n        \"title\": \"Urban Living\",\n        \"owner\": \"Mike Teavee\",\n        \"city\": \"Seattle\",\n        \"location\": {\n          \"lat\": 47.6062,\n          \"lng\": -122.3321\n        },\n        \"category\": \"Condo\",\n        \"bedrooms\": 1,\n        \"image\": \"https://upload.wikimedia.org/wikipedia/commons/2/20/Seattle_-_Barnes_and_Bell_Buildings.jpg\",\n        \"description\": \"A commuters dream. This rental is within walking distance of 2 bus stops and the Metro.\"\n      }\n    },\n    {\n      \"type\": \"rentals\",\n      \"id\": \"downtown-charm\",\n      \"attributes\": {\n        \"title\": \"Downtown Charm\",\n        \"owner\": \"Violet Beauregarde\",\n        \"city\": \"Portland\",\n        \"location\": {\n          \"lat\": 45.5175,\n          \"lng\": -122.6801\n        },\n        \"category\": \"Apartment\",\n        \"bedrooms\": 3,\n        \"image\": \"https://upload.wikimedia.org/wikipedia/commons/f/f7/Wheeldon_Apartment_Building_-_Portland_Oregon.jpg\",\n        \"description\": \"Convenience is at your doorstep with this charming downtown rental. Great restaurants and active night life are within a few feet.\"\n      }\n    }\n  ]\n}\n```\n\nThis data follows the _[JSON:API](https://jsonapi.org/)_ format, which is _slightly_ different than the hard-coded data that we were returning from the model hook before.\n\nFirst off, the JSON:API format returns an array nested under the `\"data\"` key, rather than just the data for a single rental property. If we think about this, though, it makes sense; we now want to show a whole list of rental properties that are coming from our server, not just one, so an array of rental property objects is just what we need.\n\nThe rental property objects contained in the array also have a slightly different structure. Every data object has a `type` and `id`, which we don't intend to use in our template (yet!). For now, the only data we really need is nested within the `attributes` key.\n\nThere's one more key difference here, which perhaps only those with very sharp eyes will be able to catch: the data coming from the server is missing the `type` property, which previously existed on our hard-coded model object. The `type` property could either be `\"Standalone\"` or `\"Community\"`, depending on the type of rental property, which is required by our `<Rental>` component.\n\nIn [Part 2](../../part-2/) of this tutorial, we will learn about a more convenient way to consume data in the JSON:API format. For now, we can just fix up the data and deal with these differences in formats ourselves.\n\nWe can handle it all in our model hook:\n\n```js { data-filename=\"app/routes/index.js\" data-diff=\"+3,+4,-8,-9,+10,+11,+12,+13,+14,+15,+16,+17,+18,+19,+20,+21,+22,+23\" }\nimport Route from '@ember/routing/route';\n\nconst COMMUNITY_CATEGORIES = ['Condo', 'Townhouse', 'Apartment'];\n\nexport default class IndexRoute extends Route {\n  async model() {\n    let response = await fetch('/api/rentals.json');\n    let parsed = await response.json();\n    return parsed;\n    let { data } = await response.json();\n\n    return data.map((model) => {\n      let { attributes } = model;\n      let type;\n\n      if (COMMUNITY_CATEGORIES.includes(attributes.category)) {\n        type = 'Community';\n      } else {\n        type = 'Standalone';\n      }\n\n      return { type, ...attributes };\n    });\n  }\n}\n```\n\nAfter parsing the JSON data, we extracted the nested `attributes` object, added back the missing `type` attribute manually, then returned it from the model hook. That way, the rest of our app will have no idea that this difference ever existed.\n\nAwesome! Now we're in business.\n\n## Loops and Local Variables in Templates with `{{#each}}`\n\nThe last change we'll need to make is to our `index.hbs` route template, where we invoke our `<Rental>` components. Previously, we were passing in `@rental` as `@model` to our components. However, `@model` is no longer a single object, but rather, an array! So, we'll need to change this template to account for that.\n\nLet's see how.\n\n```handlebars { data-filename=\"app/templates/index.hbs\" data-diff=\"-9,-10,-11,+12,+13,+14\" }\n<Jumbo>\n  <h2>Welcome to Super Rentals!</h2>\n  <p>We hope you find exactly what you're looking for in a place to stay.</p>\n  <LinkTo @route=\"about\" class=\"button\">About Us</LinkTo>\n</Jumbo>\n\n<div class=\"rentals\">\n  <ul class=\"results\">\n    <li><Rental @rental={{@model}} /></li>\n    <li><Rental @rental={{@model}} /></li>\n    <li><Rental @rental={{@model}} /></li>\n    {{#each @model as |rental|}}\n      <li><Rental @rental={{rental}} /></li>\n    {{/each}}\n  </ul>\n</div>\n```\n\nWe can use the `{{#each}}...{{/each}}` syntax to iterate and loop through the array returned by the model hook. For each iteration through the array—for each item in the array—we will render the block that is passed to it once. In our case, the block is our `<Rental>` component, surrounded by `<li>` tags.\n\nInside of the block we have access to the item of the _current_ iteration with the `{{rental}}` variable. But why `rental`? Well, because we named it that! This variable comes from the `as |rental|` declaration of the `each` loop. We could have just as easily called it something else, like `as |property|`, in which case we would have to access the current item through the `{{property}}` variable.\n\nNow, let's go over to our browser and see what our index route looks like with this change.\n\n<img src=\"/images/tutorial/part-1/working-with-data/three-properties@2x.png\" alt=\"Three different rental properties\" width=\"1024\" height=\"1129\">\n\nHooray! Finally we're seeing different rental properties in our list. And we got to play with `fetch` and write a loop. Pretty productive, if you ask me.\n\nBetter yet, all of our tests are still passing too!\n\n<img src=\"/images/tutorial/part-1/working-with-data/pass-2@2x.png\" alt=\"All our tests are passing\" width=\"1024\" height=\"768\">","description":"In this chapter, we will remove the hard-coded data from our <Rental> component. By the end, your app would finally be displaying real data that came from the server: \n\n \n\nIn this chapter, you will learn about: \n\n- Working with route files\n- Returning local..."}}}