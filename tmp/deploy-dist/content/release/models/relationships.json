{"data":{"type":"contents","id":"models/relationships","attributes":{"content":"Ember Data includes several built-in relationship types to help you\ndefine how your models relate to each other.\n\n### One-to-One\n\nTo declare a one-to-one relationship between two models, use\n`belongsTo`:\n\n```javascript {data-filename=app/models/user.js}\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @belongsTo('profile') profile;\n}\n```\n\n```javascript {data-filename=app/models/profile.js}\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class ProfileModel extends Model {\n  @belongsTo('user') user;\n}\n```\n\n### One-to-Many\n\nTo declare a one-to-many relationship between two models, use\n`belongsTo` in combination with `hasMany`, like this:\n\n```javascript {data-filename=app/models/blog-post.js}\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class BlogPostModel extends Model {\n  @hasMany('comment') comments;\n}\n```\n\n```javascript {data-filename=app/models/comment.js}\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class CommentModel extends Model {\n  @belongsTo('blog-post') blogPost;\n}\n```\n\n### Many-to-Many\n\nTo declare a many-to-many relationship between two models, use\n`hasMany`:\n\n```javascript {data-filename=app/models/blog-post.js}\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class BlogPostModel extends Model {\n  @hasMany('tag') tags;\n}\n```\n\n```javascript {data-filename=app/models/tag.js}\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class TagModel extends Model {\n  @hasMany('blog-post') blogPosts;\n}\n```\n\n### Explicit Inverses\n\nEmber Data will do its best to discover which relationships map to one\nanother. In the one-to-many code above, for example, Ember Data can figure out that\nchanging the `comments` relationship should update the `blogPost`\nrelationship on the inverse because `blogPost` is the only relationship to\nthat model.\n\nHowever, sometimes you may have multiple `belongsTo`/`hasMany`s for\nthe same type. You can specify which property on the related model is\nthe inverse using `belongsTo` or `hasMany`'s `inverse`\noption. Relationships without an inverse can be indicated as such by\nincluding `{ inverse: null }`.\n\n```javascript {data-filename=app/models/comment.js}\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class CommentModel extends Model {\n  @belongsTo('blog-post', { inverse: null }) onePost;\n  @belongsTo('blog-post') twoPost;\n  @belongsTo('blog-post') redPost;\n  @belongsTo('blog-post') bluePost;\n}\n```\n\n```javascript {data-filename=app/models/blog-post.js}\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class BlogPostModel extends Model {\n  @hasMany('comment', {\n    inverse: 'redPost'\n  })\n  comments;\n}\n```\n\n### Reflexive Relations\n\nWhen you want to define a reflexive relation (a model that has a relationship to\nitself), you must explicitly define the inverse relationship. If there\nis no inverse relationship then you can set the inverse to `null`.\n\nHere's an example of a one-to-many reflexive relationship:\n\n```javascript {data-filename=app/models/folder.js}\nimport Model, { belongsTo, hasMany } from '@ember-data/model';\n\nexport default class FolderModel extends Model {\n  @hasMany('folder', { inverse: 'parent' }) children;\n  @belongsTo('folder', { inverse: 'children' }) parent;\n}\n```\n\nHere's an example of a one-to-one reflexive relationship:\n\n```javascript {data-filename=app/models/user.js}\nimport Model, { attr, belongsTo } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @attr('string') name;\n  @belongsTo('user', { inverse: 'bestFriend' }) bestFriend;\n}\n```\n\nYou can also define a reflexive relationship that doesn't have an inverse:\n\n```javascript {data-filename=app/models/folder.js}\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class FolderModel extends Model {\n  @belongsTo('folder', { inverse: null }) parent;\n}\n```\n\n### Polymorphism\n\nPolymorphism is a powerful concept which allows a developer\nto abstract common functionality into a base class. Consider the\nfollowing example: a user with multiple payment methods. They\ncould have a linked PayPal account, and a couple credit cards on\nfile.\n\nNote that, for polymorphism to work, Ember Data expects a\n\"type\" declaration polymorphic type via the reserved `type`\nproperty on the model. Confused? See the API response below.\n\nFirst, let's look at the model definitions:\n\n```javascript {data-filename=app/models/user.js}\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class UserModel extends Model {\n  @hasMany('payment-method', { polymorphic: true }) paymentMethods;\n}\n```\n\n```javascript {data-filename=app/models/payment-method.js}\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class PaymentMethodModel extends Model {\n  @belongsTo('user', { inverse: 'paymentMethods' }) user;\n}\n```\n\n```javascript {data-filename=app/models/payment-method-cc.js}\nimport { attr } from '@ember-data/model';\nimport PaymentMethod from './payment-method';\n\nexport default class PaymentMethodCcModel extends PaymentMethod {\n  @attr last4;\n\n  get obfuscatedIdentifier() {\n    return `**** **** **** ${this.last4}`;\n  }\n}\n```\n\n```javascript {data-filename=app/models/payment-method-paypal.js}\nimport { attr } from '@ember-data/model';\nimport PaymentMethod from './payment-method'\n\nexport default class PaymentMethodPaypalModel extends PaymentMethod {\n  @attr linkedEmail;\n\n  get obfuscatedIdentifier() {\n    let last5 = this.linkedEmail\n      .split('')\n      .reverse()\n      .slice(0, 5)\n      .reverse()\n      .join('');\n\n    return `••••${last5}`;\n  }\n}\n```\n\nAnd our API might setup these relationships like so:\n\n```json\n{\n  \"data\": {\n    \"id\": \"8675309\",\n    \"type\": \"user\",\n    \"attributes\": {\n      \"name\": \"Anfanie Farmeo\"\n    },\n    \"relationships\": {\n      \"payment-methods\": {\n        \"data\": [\n          {\n            \"id\": \"1\",\n            \"type\": \"payment-method-paypal\"\n          },\n          {\n            \"id\": \"2\",\n            \"type\": \"payment-method-cc\"\n          },\n          {\n            \"id\": \"3\",\n            \"type\": \"payment-method-apple-pay\"\n          }\n        ]\n      }\n    }\n  },\n  \"included\": [\n    {\n      \"id\": \"1\",\n      \"type\": \"payment-method-paypal\",\n      \"attributes\": {\n        \"linked-email\": \"ryan@gosling.io\"\n      }\n    },\n    {\n      \"id\": \"2\",\n      \"type\": \"payment-method-cc\",\n      \"attributes\": {\n        \"last4\": \"1335\"\n      }\n    },\n    {\n      \"id\": \"3\",\n      \"type\": \"payment-method-apple-pay\",\n      \"attributes\": {\n        \"last4\": \"5513\"\n      }\n    }\n  ]\n}\n```\n\n### Readonly Nested Data\n\nSome models may have properties that are deeply nested objects of\nreadonly data. The naïve solution would be to define models for each\nnested object and use `hasMany` and `belongsTo` to recreate the nested\nrelationship. However, since readonly data will never need to be\nupdated and saved this often results in the creation of a great deal\nof code for very little benefit. An alternate approach is to define\nthese relationships using an attribute with no transform\n(`@attr`). This makes it easy to access readonly values in\nother objects and templates without the overhead of defining\nextraneous models.\n\n### Creating Records\n\nLet's assume that we have a `blog-post` and a `comment` model. A single blog post can have several comments linked to it. The correct relationship is shown below:\n\n```javascript {data-filename=app/models/blog-post.js}\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class BlogPostModel extends Model {\n  @hasMany('comment') comments;\n}\n```\n\n```javascript {data-filename=app/models/comment.js}\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class CommentModel extends Model {\n  @belongsTo('blog-post') blogPost;\n}\n```\n\nNow, suppose we want to add comments to an existing blogPost. We can do this in two ways, but for both of them, we first need to look up a blog post that is already loaded in the store, using its id:\n\n```javascript\nlet myBlogPost = this.store.peekRecord('blog-post', 1);\n```\n\nNow we can either set the `belongsTo` relationship in our new comment, or, update the blogPost's `hasMany` relationship. As you might observe, we don't need to set both `hasMany` and `belongsTo` for a record. Ember Data will do that for us.\n\nFirst, let's look at setting the `belongsTo` relationship in our new comment:\n\n```javascript\nlet comment = this.store.createRecord('comment', {\n  blogPost: myBlogPost\n});\ncomment.save();\n```\n\nIn the above snippet, we have referenced `myBlogPost` while creating the record. This will let Ember know that the newly created comment belongs to `myBlogPost`.\nThis will create a new `comment` record and save it to the server. Ember Data will also update `myBlogPost` to include our newly created comment in its `comments` relationship.\n\nThe second way of doing the same thing is to link the two records together by updating the blogPost's `hasMany` relationship as shown below:\n\n```javascript\nlet comment = this.store.createRecord('comment', {});\nlet comments = await myBlogPost.comments;\ncomments.pushObject(comment);\ncomment.save().then(function() {\n  myBlogPost.save();\n});\n```\n\nIn this above case, the new comment's `belongsTo` relationship will be automatically set to the parent blogPost.\n\nAlthough `createRecord` is fairly straightforward, the only thing to watch out for\nis that you cannot assign a promise as a relationship, currently.\n\nFor example, if you want to set the `author` property of a blogPost, this would **not** work\nif the `user` with id isn't already loaded into the store:\n\n```javascript\nthis.store.createRecord('blog-post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum',\n  author: this.store.findRecord('user', 1)\n});\n```\n\nHowever, you can easily set the relationship after the promise has fulfilled:\n\n```javascript\nlet blogPost = this.store.createRecord('blog-post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nthis.store.findRecord('user', 1).then(function(user) {\n  blogPost.author = user;\n});\n```\n\n### Retrieving Related Records\n\nWhen you request data from the server for a model that has relationships with one or more others,\nyou may want to retrieve records corresponding to those related models at the same time.\nFor example, when retrieving a blog post, you may need to access the comments associated\nwith the post as well.\nThe [JSON:API specification allows](http://jsonapi.org/format/#fetching-includes)\nservers to accept a query parameter with the key `include` as a request to\ninclude those related records in the response returned to the client.\nThe value of the parameter should be a comma-separated list of names of the\nrelationships required.\n\nIf you are using an adapter that supports JSON:API, such as Ember's default [`JSONAPIAdapter`](https://api.emberjs.com/ember-data/release/classes/JSONAPIAdapter),\nyou can easily add the `include` parameter to the server requests created by\nthe `findRecord()`, `findAll()`,\n`query()` and `queryRecord()` methods.\n\n`findRecord()` and `findAll()` each take an `options` argument in which you can\nspecify the `include` parameter.\nFor example, given a `post` model that has a `hasMany` relationship with a `comment` model,\nwhen retrieving a specific post we can have the server also return that post's comments\nas follows:\n\n```javascript {data-filename=app/routes/post.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\n\nexport default class PostRoute extends Route {\n  @service store;\n  model(params) {\n    return this.store.findRecord('post', params.post_id, {\n      include: 'comments'\n    });\n  }\n}\n```\n\nThe post's comments would then be available in your template as `model.comments`.\n\nNested relationships can be specified in the `include` parameter as a dot-separated sequence of relationship names.\nSo to request both the post's comments and the authors of those comments the request\nwould look like this:\n\n```javascript {data-filename=app/routes/post.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\n\nexport default class PostRoute extends Route {\n  @service store;\n  model(params) {\n    return this.store.findRecord('post', params.post_id, {\n      include: 'comments,comments.author'\n    });\n  }\n}\n```\n\nThe `query()` and `queryRecord()` methods each take a `query` argument that is\nserialized directly into the URL query string and the `include` parameter may\nform part of that argument.\nFor example:\n\n```javascript {data-filename=app/routes/adele.js}\nimport Route from '@ember/routing/route';\nimport { service } from '@ember/service';\n\nexport default class AdeleRoute extends Route {\n  @service store;\n  model() {\n    // GET to /artists?filter[name]=Adele&include=albums\n    return this.store\n      .query('artist', {\n        filter: { name: 'Adele' },\n        include: 'albums'\n      })\n      .then(function(artists) {\n        return artists.firstObject;\n      });\n  }\n}\n```\n\n### Updating Existing Records\n\nSometimes we want to set relationships on already existing records. We can simply set a `belongsTo` relationship:\n\n```javascript\nlet blogPost = this.store.peekRecord('blog-post', 1);\nlet comment = this.store.peekRecord('comment', 1);\ncomment.blogPost = blogPost;\ncomment.save();\n```\n\nAlternatively, we could update the `hasMany` relationship by pushing a record into the relationship:\n\n```javascript\nlet blogPost = this.store.peekRecord('blog-post', 1);\nlet comment = this.store.peekRecord('comment', 1);\nlet comments = await blogPost.comments;\ncomments.pushObject(comment);\nblogPost.save();\n```\n\n### Removing Relationships\n\nTo remove a `belongsTo` relationship, we can set it to `null`, which will also remove it from the `hasMany` side:\n\n```javascript\nlet comment = this.store.peekRecord('comment', 1);\ncomment.blogPost = null;\ncomment.save();\n```\n\nIt is also possible to remove a record from a `hasMany` relationship:\n\n```javascript\nlet blogPost = this.store.peekRecord('blog-post', 1);\nlet comment = this.store.peekRecord('comment', 1);\nlet comments = await blogPost.comments;\ncomments.removeObject(comment);\nblogPost.save();\n```\n\nAs in the earlier examples, the comment's `belongsTo` relationship will also be cleared by Ember Data.\n\n### Relationships as Promises\n\nWhile working with relationships it is important to remember that they return promises.\n\nFor example, if we were to work on a blogPost's asynchronous comments, we would have to wait until the promise has fulfilled:\n\n```javascript\nlet blogPost = this.store.peekRecord('blog-post', 1);\n\nlet comments = await blogPost.comments;\n// now we can work with the comments\n```\n\nThe same applies to `belongsTo` relationships:\n\n```javascript\nlet comment = this.store.peekRecord('comment', 1);\n\nlet blogPost = await comment.blogPost;\n// the blogPost is available here\n```\n\nHandlebars templates will automatically be updated to reflect a resolved promise. We can display a list of comments in a blogPost like so:\n\n```handlebars\n<ul>\n  {{#each this.blogPost.comments as |comment|}}\n    <li>{{comment.id}}</li>\n  {{/each}}\n</ul>\n```\n\nEmber Data will query the server for the appropriate records and re-render the template once the data is received.","description":"Ember Data includes several built-in relationship types to help you define how your models relate to each other. One-to-One \n\nTo declare a one-to-one relationship between two models, use belongsTo: \n\n```javascript {data-filename=app/models/user.js} import..."}}}