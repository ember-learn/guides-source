{"data":{"type":"contents","id":"models/index","attributes":{"content":"This section of the Guides describes the essential features of Ember\nData, a powerful set of tools\nfor formatting requests, normalizing responses, and efficiently\nmanaging a local cache of data.\n\nEmber.js itself works with any type of back end: REST,\nJSON:API, GraphQL, or anything else.\nTo learn about other ways to handle data and to find extensions,\ncheck out the guide for [making API requests](../in-depth-topics/making-api-requests/),\nlook for plugins on [Ember Observer](https://www.emberobserver.com/), and search\nfor community-made tutorials.\n\n## What are Ember Data models?\n\nIn Ember Data, models are objects that represent the underlying data\nthat your application presents to the user.\nNote that Ember Data models are a different concept than the\n[`model`](../routing/specifying-a-routes-model/) method on Routes,\nalthough they share the same name.\n\nDifferent apps may have very\ndifferent models, depending on what problems they're trying to solve.\nFor example, a photo sharing application might have a `Photo`\nmodel to represent a particular photo, and a `PhotoAlbum` that\nrepresents a group of photos. In contrast, an online shopping app would\nprobably have different models, like `ShoppingCart`, `Invoice`, or\n`LineItem`.\n\nModels tend to be _persistent_. That means the user does not expect\nmodel data to be lost when they close their browser window. To make sure\nno data is lost, if the user makes changes to a model, you need to store\nthe model data somewhere that it will not be lost.\n\nTypically, most models are loaded from and saved to a server that uses a\ndatabase to store data. Usually you will send JSON representations of\nmodels back and forth to an HTTP server that you have written. However,\nEmber makes it easy to use other durable storage, such as saving to the\nuser's hard disk with [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API), or hosted storage solutions that let you\navoid writing and hosting your own servers.\n\nOnce you've loaded your models from storage, components know how to\ntranslate model data into a UI that your user can interact with. For\nmore information about how components get model data, see the\n[Specifying a Route's Model](../routing/specifying-a-routes-model/)\nguide.\n\nAt first, using Ember Data may feel different than the way you're used\nto writing JavaScript applications. Many developers are familiar with\nusing Ajax to fetch raw JSON data from an endpoint, which may appear\neasy at first. Over time, however, complexity leaks out into your\napplication code, making it hard to maintain.\n\nWith Ember Data, managing models as your application grows becomes both\nsimpler _and_ easier.\n\nOnce you have an understanding of Ember Data, you will have a much\nbetter way to manage the complexity of data loading in your application.\nThis will allow your code to evolve and grow, with better maintainability.\n\n## Ember Data flexibility\n\nThanks to its use of the _adapter pattern_, Ember Data can be configured\nto work with many different kinds of backends. There is [an entire ecosystem of adapters](http://emberobserver.com/categories/ember-data-adapters)\nand several [built-in adapters](./customizing-adapters/)\nthat allow your Ember app to talk to different types of servers.\n\nBy default, Ember Data is designed to work out of the box with [JSON:API](http://jsonapi.org).\nJSON:API is a formal specification for building conventional, robust, and performant\nAPIs that allow clients and servers to communicate model data.\n\nJSON:API standardizes how JavaScript applications talk to servers, so\nyou decrease the coupling between your frontend and backend, and have\nmore freedom to change pieces of your stack.\n\nIf you need to integrate your Ember.js app with a server that does not\nhave an [adapter](http://emberobserver.com/categories/ember-data-adapters) available (for example, you hand-rolled an API server\nthat does not adhere to any JSON specification), Ember Data is designed\nto **be configurable** to work with whatever data your server returns.\n\nEmber Data is also designed to work with streaming servers, like those\npowered by WebSockets. You can open a socket to your server and push\nchanges into Ember Data whenever they occur, giving your app a real-time\nuser interface that is always up-to-date.\n\n## The Store and a Single Source of Truth\n\nOne common way of building web applications is to tightly couple user\ninterface elements to data fetching. For example, imagine you are\nwriting the admin section of a blogging app, which has a feature that\nlists the drafts for the currently logged in user.\n\nYou might be tempted to make the component responsible for fetching that\ndata and storing it:\n\n```javascript {data-filename=app/components/list-of-drafts.js}\nimport Component from \"@glimmer/component\";\nimport { tracked } from \"@glimmer/tracking\";\nimport fetch from \"fetch\";\n\nexport default class ListOfDraftsComponent extends Component {\n  @tracked drafts;\n\n  constructor() {\n    super(...arguments);\n\n    fetch(\"/drafts\").then((data) => {\n      this.drafts = data;\n    });\n  }\n}\n```\n\nYou could then show the list of drafts in your component's template like\nthis:\n\n```handlebars {data-filename=app/components/list-of-drafts.hbs}\n<ul>\n  {{#each this.drafts key=\"id\" as |draft|}}\n    <li>{{draft.title}}</li>\n  {{/each}}\n</ul>\n```\n\nThis works great for the `list-of-drafts` component. However, your app\nis likely made up of many different components. On another page you\nmay want a component to display the number of drafts. You may be\ntempted to copy and paste your existing `willRender` code into the new\ncomponent.\n\n```javascript {data-filename=app/components/drafts-button.js}\nimport Component from \"@glimmer/component\";\nimport { tracked } from \"@glimmer/tracking\";\nimport fetch from \"fetch\";\n\nexport default class DraftsButtonComponent extends Component {\n  @tracked drafts;\n\n  constructor() {\n    super(...arguments);\n\n    fetch(\"/drafts\").then((data) => {\n      this.drafts = data;\n    });\n  }\n}\n```\n\n```handlebars {data-filename=app/components/drafts-button.hbs}\n<LinkTo @route=\"drafts\">\n  Drafts ({{this.drafts.length}})\n</LinkTo>\n```\n\nUnfortunately, the app will now make two separate requests for the\nsame information. Not only is the redundant data fetching costly in\nterms of wasted bandwidth and affecting the perceived speed of your\napp, it's easy for the two values to get out-of-sync. You yourself\nhave probably used a web application where the list of items gets out\nof sync with the counter in a toolbar, leading to a frustrating and\ninconsistent experience.\n\nThere is also a _tight coupling_ between your application's UI and the\nnetwork code. If the URL or the format of the JSON payload changes, it\nis likely to break all of your UI components in ways that are hard to\ntrack down.\n\nThe SOLID principles of good design tell us that objects should have a\nsingle responsibility. The responsibility of a component should be\npresenting model data to the user, not fetching the model.\n\nGood Ember apps take a different approach. Ember Data gives you a single\n**store** that is the central repository of models in your application.\nRoutes and their corresponding controllers can ask the store for models, and the store is\nresponsible for knowing how to fetch them.\n\nIt also means that the store can detect that two different components\nare asking for the same model, allowing your app to only fetch the data\nfrom the server once. You can think of the store as a read-through cache\nfor your app's models. Both routes and their corresponding controllers have access to\nthis shared store; when they need to display or modify a model, they\nfirst ask the store for it.\n\n### Injecting the store\n\nEmber Data provides a store service that you can inject into routes, components, services and other classes, that enables you to access the store directly.\n\nTo do this, import the [`service` decorator](https://api.emberjs.com/ember/release/functions/@ember%2Fservice/service) and inject a `store` property into your class. Let's see an example using a route:\n\n```javascript\nimport Route from \"@ember/routing/route\";\nimport { service } from \"@ember/service\";\n\nexport default class BlogPostsIndexRoute extends Route {\n  @service store;\n\n  model() {\n    return this.store.findAll(\"posts\");\n  }\n}\n```\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        You can read more about service injection in the <a href=\"../services/#toc_accessing-services\"><i>Accessing Services</i></a> guide.\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\n## Models\n\nIn Ember Data, each model is represented by a subclass of `Model` that\ndefines the attributes, relationships, and behavior of the data that you\npresent to the user.\n\nModels define the type of data that will be provided by your server. For\nexample, a `Person` model might have a `name` attribute that is a\nstring, and a `birthday` attribute that is a date:\n\n```javascript {data-filename=app/models/person.js}\nimport Model, { attr } from \"@ember-data/model\";\n\nexport default class PersonModel extends Model {\n  @attr(\"string\") name;\n  @attr(\"date\") birthday;\n}\n```\n\nA model also describes its relationships with other objects. For\nexample, an `order` may have many `line-items`, and a\n`line-item` may belong to a particular `order`.\n\n```javascript {data-filename=app/models/order.js}\nimport Model, { hasMany } from \"@ember-data/model\";\n\nexport default class OrderModel extends Model {\n  @hasMany(\"line-item\") lineItems;\n}\n```\n\n```javascript {data-filename=app/models/line-item.js}\nimport Model, { belongsTo } from \"@ember-data/model\";\n\nexport default class LineItemModel extends Model {\n  @belongsTo(\"order\") order;\n}\n```\n\nModels don't have any data themselves, they define the attributes,\nrelationships and behavior of specific instances, which are called\n**records**.\n\n## Records\n\nA **record** is an instance of a model that contains data loaded from a\nserver. Your application can also create new records and save them back\nto the server.\n\nA record is uniquely identified by its model **type** and **ID**.\n\nFor example, if you were writing a contact management app, you might\nhave a `Person` model. An individual record in your app might\nhave a type of `person` and an ID of `1` or `steve-buscemi`.\n\n```javascript\nthis.store.findRecord(\"person\", 1); // => { id: 1, name: 'steve-buscemi' }\n```\n\nAn ID is usually assigned to a record by the server when you save it for\nthe first time, but you can also generate IDs client-side.\n\n## Adapter\n\nAn **adapter** is an object that translates requests from Ember (such as\n\"find the user with an ID of 1\") into requests to a server.\n\nFor example, if your application asks for a `Person` with an ID of\n`1`, how should Ember load it? Over HTTP or a WebSocket? If\nit's HTTP, is the URL `/person/1` or `/resources/people/1`?\n\nThe adapter is responsible for answering all of these questions.\nWhenever your app asks the store for a record that it doesn't have\ncached, it will ask the adapter for it. If you change a record and save\nit, the store will hand the record to the adapter to send the\nappropriate data to your server and confirm that the save was\nsuccessful.\n\nAdapters let you completely change how your API is implemented without\nimpacting your Ember application code.\n\n## Caching\n\nThe store will automatically cache records for you. If a record had already\nbeen loaded, asking for it a second time will always return the same\nobject instance. This minimizes the number of round-trips to the\nserver, and allows your application to render its UI to the user as fast as\npossible.\n\nFor example, the first time your application asks the store for a\n`person` record with an ID of `1`, it will fetch that information from\nyour server.\n\nHowever, the next time your app asks for a `person` with ID `1`, the\nstore will notice that it had already retrieved and cached that\ninformation from the server. Instead of sending another request for the\nsame information, it will give your application the same record it had\nprovided it the first time. This feature—always returning the same\nrecord object, no matter how many times you look it up—is sometimes\ncalled an _identity map_.\n\nUsing an identity map is important because it ensures that changes you\nmake in one part of your UI are propagated to other parts of the UI. It\nalso means that you don't have to manually keep records in sync—you can\nask for a record by ID and not have to worry about whether other parts\nof your application have already asked for and loaded it.\n\nOne downside to returning a cached record is you may find the state of\nthe data has changed since it was first loaded into the store's\nidentity map. In order to prevent this stale data from being a problem\nfor long, Ember Data will automatically make a request in the\nbackground each time a cached record is returned from the store. When\nthe new data comes in, the record is updated, and if there have been\nchanges to the record since the initial render, the template is\nre-rendered with the new information.\n\n## Architecture Overview\n\nThe first time your application asks the store for a record, the store\nsees that it doesn't have a local copy and requests it from your\nadapter. Your adapter will go and retrieve the record from your\npersistence layer; typically, this will be a JSON representation of the\nrecord served from an HTTP server.\n\n![Diagram showing process for finding an unloaded record](/images/guides/models/finding-unloaded-record-step1-diagram.png)\n\nAs illustrated in the diagram above, the adapter cannot always return the\nrequested record immediately. In this case, the adapter must make an\n_asynchronous_ request to the server, and only when that request finishes\nloading can the record be created with its backing data.\n\nBecause of this asynchronicity, the store immediately returns a\n_promise_ from the `findRecord()` method. Similarly, any request that the\nstore makes to the adapter also returns promises.\n\nOnce the request to the server returns with a JSON payload for the\nrequested record, the adapter resolves the promise it returned to the\nstore with the JSON.\n\nThe store then takes that JSON, initializes the record with the\nJSON data, and resolves the promise returned to your application\nwith the newly-loaded record.\n\n![Diagram showing process for finding an unloaded record after the payload has returned from the server](/images/guides/models/finding-unloaded-record-step2-diagram.png)\n\nLet's look at what happens if you request a record that the store\nalready has in its cache.\n\n![Diagram showing process for finding an unloaded record after the payload has returned from the server](/images/guides/models/finding-loaded-record-diagram.png)\n\nIn this case, because the store already knew about the record, it\nreturns a promise that it resolves with the record immediately. It does\nnot need to ask the adapter (and, therefore, the server) for a copy\nsince it already has it saved locally.\n\n---\n\nModels, records, adapters and the store are the core concepts you\nshould understand to get the most out of Ember Data. The following\nsections go into more depth about each of these concepts, and how to\nuse them together.","description":"This section of the Guides describes the essential features of Ember Data, a powerful set of tools for formatting requests, normalizing responses, and efficiently managing a local cache of data. \n\nEmber.js itself works with any type of back end: REST..."}}}