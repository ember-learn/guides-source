{"data":{"type":"contents","id":"models/customizing-serializers","attributes":{"content":"In Ember Data, serializers format the data sent to and received from\nthe backend store. By default, Ember Data serializes data using the\n[JSON:API](http://jsonapi.org/) format. If your backend uses a different\nformat, Ember Data allows you to customize the serializer or use a\ndifferent serializer entirely.\n\nEmber Data ships with 3 serializers. The\n[`JSONAPISerializer`](https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer)\nis the default serializer and works with JSON:API backends. The\n[`JSONSerializer`](https://api.emberjs.com/ember-data/release/classes/JSONSerializer)\nis a simple serializer for working with single JSON object or arrays of records. The\n[`RESTSerializer`](https://api.emberjs.com/ember-data/release/classes/RESTSerializer)\nis a more complex serializer that supports sideloading and was the default\nserializer before 2.0.\n\n## JSONAPISerializer Conventions\n\nWhen requesting a record, the `JSONAPISerializer` expects your server\nto return a JSON representation of the record that conforms to the\nfollowing conventions.\n\n\n### JSON:API Document\n\nThe `JSONAPISerializer` expects the backend to return a JSON:API\nDocument that follows the JSON:API specification and the conventions\nof the examples found in the [JSON:API spec](http://jsonapi.org/format/). This means all\ntype names should be pluralized and attribute and relationship names\nshould be dash-cased. For example, if you request a record from\n`/people/123`, the response should look like this:\n\n```json\n{\n  \"data\": {\n    \"type\": \"people\",\n    \"id\": \"123\",\n    \"attributes\": {\n      \"given-name\": \"Jeff\",\n      \"family-name\": \"Atwood\"\n    }\n  }\n}\n```\n\nA response that contains multiple records may have an array in its\n`data` property.\n\n```json\n{\n  \"data\": [{\n    \"type\": \"people\",\n    \"id\": \"123\",\n    \"attributes\": {\n      \"given-name\": \"Jeff\",\n      \"family-name\": \"Atwood\"\n    }\n  }, {\n    \"type\": \"people\",\n    \"id\": \"124\",\n    \"attributes\": {\n      \"given-name\": \"Yehuda\",\n      \"family-name\": \"Katz\"\n    }\n  }]\n}\n```\n\n### Sideloaded Data\n\nData that is not a part of the primary request but includes linked\nrelationships should be placed in an array under the `included`\nkey. For example, if you request `/articles/1` and the backend also\nreturned any comments associated with that person the response\nshould look like this:\n\n```json\n{\n  \"data\": {\n    \"type\": \"articles\",\n    \"id\": \"1\",\n    \"attributes\": {\n      \"title\": \"JSON:API paints my bikeshed!\"\n    },\n    \"links\": {\n      \"self\": \"http://example.com/articles/1\"\n    },\n    \"relationships\": {\n      \"comments\": {\n        \"data\": [\n          { \"type\": \"comments\", \"id\": \"5\" },\n          { \"type\": \"comments\", \"id\": \"12\" }\n        ]\n      }\n    }\n  },\n  \"included\": [{\n    \"type\": \"comments\",\n    \"id\": \"5\",\n    \"attributes\": {\n      \"body\": \"First!\"\n    },\n    \"links\": {\n      \"self\": \"http://example.com/comments/5\"\n    }\n  }, {\n    \"type\": \"comments\",\n    \"id\": \"12\",\n    \"attributes\": {\n      \"body\": \"I like XML better\"\n    },\n    \"links\": {\n      \"self\": \"http://example.com/comments/12\"\n    }\n  }]\n}\n```\n\n## Customizing Serializers\n\nEmber Data uses the `JSONAPISerializer` by default, but you can\noverride this default by defining a custom serializer. There are two\nways to define a custom serializer. First, you can define a custom\nserializer for your entire application by defining an \"application\"\nserializer.\n\n```javascript {data-filename=app/serializers/application.js}\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class ApplicationSerializer extends JSONAPISerializer {\n}\n```\n\nYou can also define a serializer for a specific model. For example, if\nyou had a `post` model you could also define a `post` serializer:\n\n```javascript {data-filename=app/serializers/post.js}\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class PostSerializer extends JSONAPISerializer {\n}\n```\n\nTo change the format of the data that is sent to the backend store, you can use\nthe [`serialize()`](https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods/serialize?anchor=serialize)\nhook. Let's say that we have this JSON:API response from Ember Data:\n\n```json\n{\n  \"data\": {\n    \"id\": \"1\",\n    \"type\": \"product\",\n    \"attributes\": {\n      \"name\": \"My Product\",\n      \"amount\": 100,\n      \"currency\": \"SEK\"\n    }\n  }\n}\n```\n\nBut our server expects data in this format:\n\n```json\n{\n  \"data\": {\n    \"id\": \"1\",\n    \"type\": \"product\",\n    \"attributes\": {\n      \"name\": \"My Product\",\n      \"cost\": {\n        \"amount\": 100,\n        \"currency\": \"SEK\"\n      }\n    }\n  }\n}\n```\n\nHere's how you can change the data:\n\n```javascript {data-filename=app/serializers/application.js}\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class ApplicationSerializer extends JSONAPISerializer {\n  serialize(snapshot, options) {\n    let json = super.serialize(...arguments);\n\n    json.data.attributes.cost = {\n      amount: json.data.attributes.amount,\n      currency: json.data.attributes.currency\n    };\n\n    delete json.data.attributes.amount;\n    delete json.data.attributes.currency;\n\n    return json;\n  }\n}\n```\n\nSimilarly, if your backend store provides data in a format other than JSON:API,\nyou can use the\n[`normalizeResponse()`](https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods/normalizeResponse?anchor=normalizeResponse)\nhook. Using the same example as above, if the server provides data that looks\nlike:\n\n```json\n{\n  \"data\": {\n    \"id\": \"1\",\n    \"type\": \"product\",\n    \"attributes\": {\n      \"name\": \"My Product\",\n      \"cost\": {\n        \"amount\": 100,\n        \"currency\": \"SEK\"\n      }\n    }\n  }\n}\n```\n\nAnd we need to change it to look like this:\n\n```json\n{\n  \"data\": {\n    \"id\": \"1\",\n    \"type\": \"product\",\n    \"attributes\": {\n      \"name\": \"My Product\",\n      \"amount\": 100,\n      \"currency\": \"SEK\"\n    }\n  }\n}\n```\n\nHere's how we could do it:\n\n```javascript {data-filename=app/serializers/application.js}\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class ApplicationSerializer extends JSONAPISerializer {\n  normalizeResponse(store, primaryModelClass, payload, id, requestType) {\n    payload.data.attributes.amount = payload.data.attributes.cost.amount;\n    payload.data.attributes.currency = payload.data.attributes.cost.currency;\n\n    delete payload.data.attributes.cost;\n\n    return super.normalizeResponse(...arguments);\n  }\n}\n```\n\nTo normalize only a single model, you can use the\n[`normalize()`](https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods/normalize?anchor=normalize)\nhook similarly.\n\nFor more hooks to customize the serializer with, see the [Ember Data serializer\nAPI documentation](https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer).\n\n### IDs\n\nIn order to keep track of unique records in the store Ember Data\nexpects every record to have an `id` property in the payload. Ids\nshould be unique for every unique record of a specific type. If your\nbackend uses a key other than `id` you can use the\nserializer's `primaryKey` property to correctly transform the id\nproperty to `id` when serializing and deserializing data.\n\n```javascript {data-filename=app/serializers/application.js}\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class ApplicationSerializer extends JSONAPISerializer {\n  primaryKey = '_id';\n}\n```\n\n### Attribute Names\n\nIn Ember Data the convention is to camelize attribute names on a\nmodel. For example:\n\n```javascript {data-filename=app/models/person.js}\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PersonModel extends Model {\n  @attr('string') givenName;\n  @attr('string') familyName;\n  @attr('boolean') isPersonOfTheYear;\n}\n```\n\nHowever, the `JSONAPISerializer` expects attributes to be dasherized\nin the document payload returned by your server:\n\n```json\n{\n  \"data\": {\n    \"id\": \"44\",\n    \"type\": \"people\",\n    \"attributes\": {\n      \"given-name\": \"Zaphod\",\n      \"family-name\": \"Beeblebrox\",\n      \"is-person-of-the-year\": true\n    }\n  }\n}\n```\n\nIf the attributes returned by your server use a different convention\nyou can use the serializer's\n[`keyForAttribute()`](https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods/keyForAttribute?anchor=keyForAttribute)\nmethod to convert an attribute name in your model to a key in your JSON\npayload. For example, if your backend returned attributes that are\n`under_scored` instead of `dash-cased` you could override the `keyForAttribute`\nmethod like this.\n\n```javascript {data-filename=app/serializers/application.js}\nimport { underscore } from '@ember/string';\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class ApplicationSerializer extends JSONAPISerializer {\n  keyForAttribute(attr) {\n    return underscore(attr);\n  }\n}\n```\n\nIrregular keys can be mapped with a custom serializer. The `attrs`\nobject can be used to declare a simple mapping between property names\non `Model` records and payload keys in the serialized JSON object\nrepresenting the record. An object with the property key can also be\nused to designate the attribute's key on the response payload.\n\n\nIf the JSON for `person` has a key of `familyNameOfPerson`, and the\ndesired attribute name is simply `familyName`, then create a custom\nSerializer for the model and override the `attrs` property.\n\n```javascript {data-filename=app/models/person.js}\nimport Model, { attr } from '@ember-data/model';\n\nexport default class PersonModel extends Model {\n  @attr('string') familyName;\n}\n```\n\n```javascript {data-filename=app/serializers/person.js}\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class PersonSerializer extends JSONAPISerializer {\n  attrs = {\n    familyName: 'familyNameOfPerson'\n  };\n}\n```\n\n### Relationships\n\nReferences to other records should be done by ID. For example, if you\nhave a model with a `hasMany` relationship:\n\n```javascript {data-filename=app/models/post.js}\nimport Model, { hasMany } from '@ember-data/model';\n\nexport default class PostModel extends Model {\n  @hasMany('comment', { async: true }) comments;\n}\n```\n\nThe JSON should encode the relationship as an array of IDs and types:\n\n```json\n{\n  \"data\": {\n    \"type\": \"posts\",\n    \"id\": \"1\",\n    \"relationships\": {\n      \"comments\": {\n        \"data\": [\n          { \"type\": \"comments\", \"id\": \"1\" },\n          { \"type\": \"comments\", \"id\": \"2\" },\n          { \"type\": \"comments\", \"id\": \"3\" }\n        ]\n      }\n    }\n  }\n}\n```\n\n`Comments` for a `post` can be loaded by `post.get('comments')`. The\nJSON:API adapter will send 3 `GET` requests to `/comments/1/`,\n`/comments/2/` and `/comments/3/`.\n\nAny `belongsTo` relationships in the JSON representation should be the\ndasherized version of the property's name. For example, if you have\na model:\n\n```javascript {data-filename=app/models/comment.js}\nimport Model, { belongsTo } from '@ember-data/model';\n\nexport default class CommentModel extends Model {\n  @belongsTo('post') originalPost\n}\n```\n\nThe JSON should encode the relationship as an ID to another record:\n\n```json\n{\n  \"data\": {\n    \"type\": \"comment\",\n    \"id\": \"1\",\n    \"relationships\": {\n      \"original-post\": {\n        \"data\": { \"type\": \"post\", \"id\": \"5\" },\n      }\n    }\n  }\n}\n```\nIf needed these naming conventions can be overwritten by implementing\nthe\n[`keyForRelationship()`](https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods/keyForRelationship?anchor=keyForRelationship)\nmethod.\n\n```javascript {data-filename=app/serializers/application.js}\nimport JSONAPISerializer from '@ember-data/serializer/json-api';\n\nexport default class ApplicationSerializer extends JSONAPISerializer {\n  keyForRelationship(key, relationship) {\n    return key + 'Ids';\n  }\n}\n```\n\n\n## Creating Custom Transformations\n\nIn some circumstances, the built-in attribute types of `string`,\n`number`, `boolean`, and `date` may be inadequate. For example, a\nserver may return a non-standard date format.\n\nEmber Data can have new JSON transforms\nregistered for use as attributes:\n\n```javascript {data-filename=app/transforms/coordinate-point.js}\nimport Transform from '@ember-data/serializer/transform';\nimport EmberObject from '@ember/object';\n\nexport default class CoordinatePointTransform extends Transform {\n  serialize(value) {\n    return [value.get('x'), value.get('y')];\n  }\n  deserialize(value) {\n    return EmberObject.create({ x: value[0], y: value[1] });\n  }\n}\n```\n\n```javascript {data-filename=app/models/cursor.js}\nimport Model, { attr } from '@ember-data/model';\n\nexport default class Cursor extends Model {\n  @attr('coordinate-point') position;\n}\n```\n\nWhen `coordinatePoint` is received from the API, it is\nexpected to be an array:\n\n```json\n{\n  cursor: {\n    position: [4,9]\n  }\n}\n```\n\nBut once loaded on a model instance, it will behave as an object:\n\n```javascript\nlet cursor = store.findRecord('cursor', 1);\ncursor.get('position.x'); //=> 4\ncursor.get('position.y'); //=> 9\n```\n\nIf `position` is modified and saved, it will pass through the\n`serialize` function in the transform and again be presented as\nan array in JSON.\n\n## JSONSerializer\n\nNot all APIs follow the conventions that the `JSONAPISerializer` uses\nwith a data namespace and sideloaded relationship records. Some\nlegacy APIs may return a simple JSON payload that is just the requested\nresource or an array of serialized records. The `JSONSerializer` is a\nserializer that ships with Ember Data that can be used alongside the\n`RESTAdapter` to serialize these simpler APIs.\n\nTo use it in your application you will need to define a\n`serializer:application` that extends the `JSONSerializer`.\n\n```javascript {data-filename=app/serializers/application.js}\nimport JSONSerializer from '@ember-data/serializer/json';\n\nexport default class ApplicationSerializer extends JSONSerializer {\n  // ...\n}\n```\n\nFor requests that are only expected to return 1 record\n(e.g. `store.findRecord('post', 1)`) the `JSONSerializer` expects the response\nto be a JSON object that looks similar to this:\n\n```json\n{\n  \"id\": \"1\",\n  \"title\": \"Rails is omakase\",\n  \"tag\": \"rails\",\n  \"comments\": [\"1\", \"2\"]\n}\n```\n\nFor requests that are only expected to return 0 or more records\n(e.g. `store.findAll('post')` or `store.query('post', { filter: { status: 'draft' } })`)\nthe `JSONSerializer` expects the response to be a JSON array that\nlooks similar to this:\n\n```json\n[{\n  \"id\": \"1\",\n  \"title\": \"Rails is omakase\",\n  \"tag\": \"rails\",\n  \"comments\": [\"1\", \"2\"]\n}, {\n  \"id\": \"2\",\n  \"title\": \"I'm Running to Reform the W3C's Tag\",\n  \"tag\": \"w3c\",\n  \"comments\": [\"3\"]\n}]\n```\n\nThe `JSONAPISerializer` is built on top of the `JSONSerializer` so they share\nmany of the same hooks for customizing the behavior of the\nserialization process. Be sure to check out the\n[API docs](https://api.emberjs.com/ember-data/release/classes/JSONSerializer)\nfor a full list of methods and properties.\n\n\n## EmbeddedRecordMixin\n\nAlthough Ember Data encourages you to sideload your relationships,\nsometimes when working with legacy APIs you may discover you need to\ndeal with JSON that contains relationships embedded inside other\nrecords. The `EmbeddedRecordsMixin` is meant to help with this problem.\n\nTo set up embedded records, include the mixin when extending a\nserializer then define and configure embedded relationships.\n\nFor example, if your `post` model contained an embedded `author` record\nthat looks similar to this:\n\n\n```json\n{\n  \"id\": \"1\",\n  \"title\": \"Rails is omakase\",\n  \"tag\": \"rails\",\n  \"authors\": [\n    {\n      \"id\": \"2\",\n      \"name\": \"Steve\"\n    }\n  ]\n}\n```\n\nYou would define your relationship like this:\n\n```javascript {data-filename=app/serializers/post.js}\nimport JSONSerializer from '@ember-data/serializer/json';\nimport { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';\n\nexport default class PostSerializer extends JSONSerializer.extend(EmbeddedRecordsMixin) {\n  attrs = {\n    authors: {\n      serialize: 'records',\n      deserialize: 'records'\n    }\n  };\n}\n```\n\nIf you find yourself needing to both serialize and deserialize the\nembedded relationship you can use the shorthand option of `{ embedded:\n'always' }`. The example above could therefore be expressed as such:\n\n```javascript {data-filename=app/serializers/post.js}\nimport JSONSerializer from '@ember-data/serializer/json';\nimport { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';\n\nexport default class PostSerializer extends JSONSerializer.extend(EmbeddedRecordsMixin) {\n  attrs = {\n    authors: { embedded: 'always' }\n  };\n}\n```\n\n\nThe `serialize` and `deserialize` keys support 3 values:\n\n* `records` is used to signal that the entire record is expected\n* `ids` is used to signal that only the id of the record is expected\n* `false` is used to signal that the record is not expected\n\nFor example you may find that you want to read an embedded record when\nextracting a JSON payload but only include the relationship's id when\nserializing the record. This is possible by using the `serialize:\n'ids'` option. You can also opt out of serializing a relationship by\nsetting `serialize: false`.\n\n```javascript {data-filename=app/serializers/post.js}\nimport JSONSerializer from '@ember-data/serializer/json';\nimport { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';\n\nexport default class PostSerializer extends JSONSerializer.extend(EmbeddedRecordsMixin) {\n  attrs = {\n    author: {\n      serialize: false,\n      deserialize: 'records'\n    },\n    comments: {\n      deserialize: 'records',\n      serialize: 'ids'\n    }\n  };\n}\n```\n\n### EmbeddedRecordsMixin Defaults\n\nIf you do not overwrite `attrs` for a specific relationship, the\n`EmbeddedRecordsMixin` will behave in the following way:\n\nbelongsTo: `{ serialize: 'id', deserialize: 'id' }`\nhasMany   `{ serialize: false, deserialize: 'ids' }`\n\n\nThere is an option of not embedding JSON in the serialized payload by\nusing serialize: 'ids'. If you do not want the relationship sent at\nall, you can use `serialize: false`.\n\n## Authoring Serializers\n\nIf you would like to create a custom serializer, it is recommended that you\nstart with the `JSONAPISerializer` or `JSONSerializer` and extend one of\nthose to match your needs.\nHowever, if your payload is extremely different from one of these\nserializers you can create your own by extending the `Serializer`\nbase class.\n\nA serializer has two main roles in Ember Data.\nFirst, it is responsible for taking a response from an adapter and\nserializing it into the normalized JSON format that Ember Data\nunderstands.\nSecondly, it transforms snapshots of records into a payload the\nadapter will send to the server when creating, updating, or deleting a\nrecord.\n\n### Ember Data's Normalized JSON Format\n\nThe normalized JSON format that Ember Data expects is a\n[JSON:API](http://jsonapi.org/) document with a couple of additional\nrestrictions.\n\nFirst, it is important to make sure that the `type` name of a record\nin the normalized JSON object exactly matches the filename of the\nmodel defined for this record type.\nBy convention Model names are singular in Ember Data, however, the\nexample type names shown in the\n[JSON:API spec](http://jsonapi.org/format/) are pluralized.\nThe JSON:API spec itself is agnostic about inflection rules, however,\nEmber Data's own `JSONAPISerializer` assumes types are plural and it\nwill automatically singularize the types.\n\nSecond, attribute and relationship names in the JSON:API document\nshould exactly match the name and casing of the `@attr`,\n`@belongsTo` and `@hasMany`, properties defined on the\nModel.\n\nBy convention these property names are camelCase in Ember Data models.\nAs with the `type` names, this is different from the example attribute\nand relationship names shown in the\n[JSON:API spec](http://jsonapi.org/format/).\nThe examples in the spec use dash-case for attribute and relationship\nnames. However, the spec does not require attribute or relationship\nnames to follow any specific casing convention.\nIf you are using Ember Data's own `JSONAPISerializer` it will assume\nthe attribute and relationship names from your API are dash-case and\nautomatically transform them to camelCase when it creates the\nnormalized JSON object.\n\nOther than these two restrictions, Ember Data's normalized JSON object\nfollows the [JSON:API](http://jsonapi.org/) specification.\n\nExample: given this `post` model.\n\n```javascript {data-filename=app/models/post.js}\nimport Model, { attr, hasMany } from '@ember-data/model';\n\nexport default class Post extends Model {\n  @attr('string') title;\n  @attr('string') tag;\n  @hasMany('comment', { async: false }) comments;\n  @hasMany('post') relatedPosts;\n}\n```\n\nThe normalized JSON object that Ember Data expects a serializer to\nreturn looks like this:\n\n```json\n{\n  data: {\n    id: \"1\",\n    type: \"post\",\n    attributes: {\n      title: \"Rails is omakase\",\n      tag: \"rails\",\n    },\n    relationships: {\n      comments: {\n        data: [{ id: \"1\", type: \"comment\" },\n               { id: \"2\", type: \"comment\" }],\n      },\n      relatedPosts: {\n        links: {\n          related: \"/api/v1/posts/1/related-posts/\"\n        }\n      }\n    }\n}\n```\n\nNote that the type is `\"post\"` to match the post model and the\n`relatedPosts` relationship in the document matches the\n`relatedPosts: hasMany('post')` on the model.\n\n### Normalizing adapter responses\n\nWhen creating a custom serializer you will need to define a\n[normalizeResponse](https://api.emberjs.com/ember-data/release/classes/Serializer/methods/normalizeResponse?anchor=normalizeResponse)\nmethod to transform the response from the adapter into the normalized\nJSON object described above.\n\nThis method receives the `store`, the Model class for the request, the\npayload, the id of the record request (or `null` if there is\nno id associated with the request), and the request type (a string with\nthe possible values of: `'findRecord'`, `'queryRecord'`, `'findAll'`,\n`'findBelongsTo'`, `'findHasMany'`, `'findMany'`, `'query'`,\n`'createRecord'`, `'deleteRecord'`, and `'updateRecord'`) as arguments.\n\nA custom serializer will also need to define a\n[normalize](https://api.emberjs.com/ember-data/release/classes/Serializer/methods/normalize?anchor=normalize)\nmethod.\nThis method is called by `store.normalize(type, payload)` and is often\nused for normalizing requests made outside of Ember Data because they\ndo not fall into the normal CRUD flow that the adapter provides.\n\n### Serializing records\n\nFinally a serializer will need to implement a\n[serialize](https://api.emberjs.com/ember-data/release/classes/Serializer/methods/serialize?anchor=serialize)\nmethod.\nEmber Data will provide a record snapshot and an options hash and this\nmethod should return an object that the adapter will send to the\nserver when creating, updating or deleting a record.\n\n\n## Community Serializers\n\nIf none of the built-in Ember Data Serializers work for your backend,\nbe sure to check out some of the community maintained Ember Data\nAdapters and Serializers.\nA good place to search for them is\n[Ember Observer](http://emberobserver.com/categories/data).","description":"In Ember Data, serializers format the data sent to and received from the backend store. By default, Ember Data serializes data using the JSON:API format. If your backend uses a different format, Ember Data allows you to customize the serializer or use a..."}}}