{"data":{"type":"contents","id":"models/creating-updating-and-deleting-records","attributes":{"content":"## Creating Records\n\nYou can create records by calling the\n[`createRecord()`](https://api.emberjs.com/ember-data/release/classes/Store/methods/createRecord?anchor=createRecord)\nmethod on the store.\n\n```javascript\nstore.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n```\n\nThe store object is available in controllers and routes using `this.store`.\n\n## Updating Records\n\nMaking changes to Ember Data records is as simple as setting the attribute you\nwant to change:\n\n```javascript\nthis.store.findRecord('post', 1).then(function(post) {\n  // ...after the record has loaded\n  post.title = 'A new post';\n});\n```\n\n## Persisting Records\n\nRecords in Ember Data are persisted on a per-instance basis.\nCall [`save()`](https://api.emberjs.com/ember-data/release/classes/Model/methods/save?anchor=save)\non any instance of `Model` and it will make a network request.\n\nEmber Data takes care of tracking the state of each record for\nyou. This allows Ember Data to treat newly created records differently\nfrom existing records when saving.\n\nBy default, Ember Data will `POST` newly created records to their type URL.\n\n```javascript\nlet post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\npost.save(); // => POST to '/posts'\n```\n\nRecords that already exist on the backend are updated using the HTTP `PATCH` verb.\n\n```javascript\nstore.findRecord('post', 1).then(function(post) {\n  post.title; // => \"Rails is Omakase\"\n\n  post.title = 'A new post';\n\n  post.save(); // => PATCH to '/posts/1'\n});\n```\n\nYou can tell if a record has outstanding changes that have not yet been\nsaved by checking its\n[`hasDirtyAttributes`](https://api.emberjs.com/ember-data/release/classes/Model/properties/hasDirtyAttributes?anchor=hasDirtyAttributes)\nproperty. You can also see which parts of\nthe record were changed and what the original value was using the\n[`changedAttributes()`](https://api.emberjs.com/ember-data/release/classes/Model/methods/changedAttributes?anchor=changedAttributes)\nmethod. `changedAttributes` returns an object, whose keys are the changed\nproperties and values are an array of values `[oldValue, newValue]`.\n\n```javascript\nperson.isAdmin; // => false\nperson.hasDirtyAttributes; // => false\nperson.isAdmin = true;\nperson.hasDirtyAttributes; // => true\nperson.changedAttributes(); // => { isAdmin: [false, true] }\n```\n\nAt this point, you can either persist your changes via `save()` or you can roll back your changes using [`rollbackAttributes()`](https://api.emberjs.com/ember-data/release/classes/Model/methods/rollbackAttributes?anchor=rollbackAttributes).\n\n```javascript\nperson.hasDirtyAttributes; // => true\nperson.changedAttributes(); // => { isAdmin: [false, true] }\n\nperson.rollbackAttributes();\n\nperson.hasDirtyAttributes; // => false\nperson.isAdmin; // => false\nperson.changedAttributes(); // => {}\n```\n\n## Handling Validation Errors\n\nIf the backend server returns validation errors after trying to save, they will\nbe available on the `errors` property of your model. Here's how you might display\nthe errors from saving a blog post in your template:\n\n```handlebars\n{{#each this.post.errors.title as |error|}}\n  <div class=\"error\">{{error.message}}</div>\n{{/each}}\n{{#each this.post.errors.body as |error|}}\n  <div class=\"error\">{{error.message}}</div>\n{{/each}}\n```\n\n## Promises\n\n[`save()`](https://api.emberjs.com/ember-data/release/classes/Model/methods/save?anchor=save) returns\na promise, which makes it easy to asynchronously handle success and failure\nscenarios. Here's a common pattern:\n\n```javascript\n// Assumed to have already injected the router and store services\nconst newPost = this.store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\ntry {\n  await newPost.save();\n  this.router.transitionTo('posts.show', newPost.id);\n} catch (error) {\n  // Handle error\n}\n```\n\n## Deleting Records\n\nDeleting records is as straightforward as creating records. Call [`deleteRecord()`](https://api.emberjs.com/ember-data/release/classes/Model/methods/deleteRecord?anchor=deleteRecord)\non any instance of `Model`. This flags the record as `isDeleted`. The\ndeletion can then be persisted using `save()`. Alternatively, you can use\nthe [`destroyRecord`](https://api.emberjs.com/ember-data/release/classes/Model/methods/destroyRecord?anchor=destroyRecord) method to delete and persist at the same time.\n\n```javascript\nlet post = store.peekRecord('post', 1);\npost.deleteRecord();\npost.isDeleted; // => true\npost.save(); // => DELETE to /posts/1\n\n// OR\npost = store.peekRecord('post', 2);\npost.destroyRecord(); // => DELETE to /posts/2\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"Creating Records \n\nYou can create records by calling the createRecord() method on the store. \n\nstore.createRecord('post', { title: 'Rails is Omakase', body: 'Lorem ipsum' });  \n\nThe store object is available in controllers and routes using this.store..."}}}