{"data":{"type":"contents","id":"components/component-state-and-actions","attributes":{"content":"While you can accomplish a lot in Ember using HTML templating, you'll need\nJavaScript to make your application interactive.\n\nLet's start with a small example, a counter component. When the user presses\nthe `+1` button, the count will increase by 1. When the user presses the `-1`\nbutton, the count will decrease by 1.\n\nFirst, let's start with the HTML.\n\n```handlebars {data-filename=\"app/components/counter.hbs\"}\n<p>0</p>\n\n<button type=\"button\">+1</button>\n<button type=\"button\">-1</button>\n```\n\n## Tracked Properties\n\nTo make this work, we will need to stop hard coding the number, and we will need\nto wire up the buttons.\n\n```js {data-filename=\"app/components/counter.js\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n}\n```\n\nThere are a few things going on here, but the most important part is\n`@tracked count = 0`. This line creates a dynamic value called `count`, which\nyou can stick inside of the template instead of hard coding it.\n\n```handlebars {data-filename=\"app/components/counter.hbs\" data-diff=\"-1,+2\"}\n<p>0</p>\n<p>{{this.count}}</p>\n\n<button type=\"button\">+1</button>\n<button type=\"button\">-1</button>\n```\n\nWhen we use `{{this.count}}` in the component template, we're referring to a\nproperty that we defined in the JavaScript class.\n\nThe output looks the same as before, but now the `0` comes from JavaScript, and\nafter some more work, we can change its value with the buttons.\n\n## HTML Modifiers and Actions\n\nNext, we want to wire up the buttons. When the user presses `+1`, we want\n`this.count` to go up by 1. When the user presses `-1`, we want it to go down\nby 1.\n\nTo attach an event handler to an HTML tag, we use the `on` HTML modifier. HTML\nmodifiers are an Ember syntax that allow us to attach logic to a tag.\n\n```handlebars {data-filename=\"app/components/counter.hbs\" data-diff=\"-3,+4,-5,+6\"}\n<p>{{this.count}}</p>\n\n<button type=\"button\">+1</button>\n<button type=\"button\" {{on \"click\" this.increment}}>+1</button>\n<button type=\"button\">-1</button>\n<button type=\"button\" {{on \"click\" this.decrement}}>-1</button>\n```\n\nTo make those event handlers do something, we will need to define _actions_ in\nthe component JavaScript. An action is a JavaScript method that can be used from\na template.\n\n```js {data-filename=\"app/components/counter.js\" data-diff=\"+3,+8,+9,+10,+11,+13,+14,+15,+16\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  @action\n  increment() {\n    this.count = this.count + 1;\n  }\n\n  @action\n  decrement() {\n    this.count = this.count - 1;\n  }\n}\n```\n\nNow, when the `+1` and `-1` buttons get clicked, the number displayed will\nchange.\n\n## Passing Arguments to Actions\n\nOur counter has two different actions, `increment` and `decrement`. But both\nactions are mostly doing the same thing. The only difference is that `increment`\nchanges the count by `+1`, while `decrement` changes it by `-1`.\n\nFirst, let's turn our `increment` and `decrement` methods into a single `change`\nmethod that takes the amount as a parameter.\n\n```js {data-filename=\"app/components/counter.js\" data-diff=\"+8,+9,+10,+11,-12,-13,-14,-15,-17,-18,-19,-20\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  @action\n  change(amount) {\n    this.count = this.count + amount;\n  }\n  @action\n  increment() {\n    this.count = this.count + 1;\n  }\n\n  @action\n  decrement() {\n    this.count = this.count - 1;\n  }\n}\n```\n\nNext, we'll update the template to turn the click handler into a function that\npasses an amount (for example, 1 and -1) in as an argument, using the `fn`\nhelper.\n\n```handlebars {data-filename=\"app/components/counter.hbs\" data-diff=\"-3,+4,-5,+6\"}\n<p>{{this.count}}</p>\n\n<button type=\"button\" {{on \"click\" this.increment}}>+1</button>\n<button type=\"button\" {{on \"click\" (fn this.change 1)}}>+1</button>\n<button type=\"button\" {{on \"click\" this.decrement}}>-1</button>\n<button type=\"button\" {{on \"click\" (fn this.change -1)}}>-1</button>\n```\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        An event handler takes a function as its second argument. When there are\n        no arguments to the function, you can pass it directly, just like in\n        JavaScript. Otherwise, you can build a function inline by using the\n        <code>fn</code> syntax.\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\n## Computed Values\n\nLet's say we want to add a button to our counter that allows us to double the\ncurrent count. Every time we press the button, the current count doubles.\n\nBased on what we've already learned, we'll need:\n\n- A `multiple`, a piece of state that represents the number to multiply the\n  `count` by\n- An action to double the `multiple`\n- A button in the template that calls the action\n\nBut we'll also need a way to multiply the `count` by the `multiple` and show it\nin the template.\n\nLet's start with what we know already. We'll add the `multiple` tracked property\nand an action called `double` that doubles the `multiple`.\n\n```js {data-filename=\"app/components/counter.js\" data-diff=\"+7,+9,+10,+11,+12\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n  @tracked multiple = 1;\n\n  @action\n  double() {\n    this.multiple = this.multiple * 2;\n  }\n\n  @action\n  change(amount) {\n    this.count = this.count + amount;\n  }\n}\n```\n\nThen, we'll update the template to call the `double` action. We'll also add\n`this.multiple` to our output to help us confirm that our button is working.\n\n```handlebars {data-filename=\"app/components/counter.hbs\" data-diff=\"+2,+7\"}\n<p>{{this.count}}</p>\n<p>× {{this.multiple}}</p>\n\n<button type=\"button\" {{on \"click\" (fn this.change 1)}}>+1</button>\n<button type=\"button\" {{on \"click\" (fn this.change -1)}}>-1</button>\n\n<button type=\"button\" {{on \"click\" this.double}}>Double It</button>\n```\n\nTo get the multiplied number into the template, we'll use a\n[JavaScript getter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get).\n\n```js {data-filename=\"app/components/counter.js\" data-diff=\"+9,+10,+11\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n  @tracked multiple = 1;\n\n  get total() {\n    return this.count * this.multiple;\n  }\n\n  @action\n  double() {\n    this.multiple = this.multiple * 2;\n  }\n\n  @action\n  change(amount) {\n    this.count = this.count + amount;\n  }\n}\n```\n\n**The getter does not need any special annotations.** As long as you've marked\nthe properties that can change with `@tracked`, you can use JavaScript to\ncompute new values from those properties.\n\nWe can now update the template to use the `total` property:\n\n```handlebars {data-filename=\"app/components/counter.hbs\" data-diff=\"+3\"}\n<p>{{this.count}}</p>\n<p>× {{this.multiple}}</p>\n<p>= {{this.total}}</p>\n\n<button type=\"button\" {{on \"click\" (fn this.change 1)}}>+1</button>\n<button type=\"button\" {{on \"click\" (fn this.change -1)}}>-1</button>\n\n<button type=\"button\" {{on \"click\" this.double}}>Double It</button>\n```\n\nAnd we're all done! If we try to click the plus, minus, or double buttons in any\norder, we can watch as these three outputs stay up-to-date perfectly.\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        <p>\n          You might have been tempted to make <code>total</code> a <code>@tracked</code> property and update it in\n          the <code>double</code> and <code>change</code> actions. But this kind of \"push-based\" approach creates a\n          lot of bugs. What happens if you create a new way to update <code>multiple</code> or <code>amount</code>\n          properties and forget to update <code>total</code> at the same time?\n        </p>\n        <p>\n          When you use getters and functions to <em>derive</em> the state you need, you're taking advantage of\n          the benefits of <strong>declarative</strong> programming. In declarative programming, you describe\n          <em>what</em> you need, not <em>how</em> to get it, which reduces the number of places where you can\n          make mistakes.\n        </p>\n        <p>Making a <code>total</code> getter that computed the total from the <code>amount</code> and\n        <code>multiple</code> properties was more <strong>declarative</strong> than setting <code>total</code>\n        in all of the places that could have affected it. If you had changed <code>total</code> directly, you\n        would have taken the <em>\"imperative\" approach</em>).</p>\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\n## Combining Arguments and State\n\nInstead of allowing the component itself to be responsible for the multiple,\nlet's allow it to be passed in.\n\n```handlebars {data-filename=\"app/components/double-it.hbs\"}\n<Counter @multiple={{this.multiple}} />\n\n<button type=\"button\" {{on \"click\" this.double}}>Double It</button>\n```\n\n```js {data-filename=\"app/components/double-it.js\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class DoubleItComponent extends Component {\n  @tracked multiple = 1;\n\n  @action\n  double() {\n    this.multiple = this.multiple * 2;\n  }\n}\n```\n\nIn the `Counter` component, instead of tracking the `multiple` internally, we\ntake it as an argument. In the template, we refer to the argument as\n`@multiple`.\n\n```handlebars {data-filename=\"app/components/counter.hbs\"}\n<p>{{this.count}}</p>\n<p>× {{@multiple}}</p>\n<p>= {{this.total}}</p>\n\n<button type=\"button\" {{on \"click\" (fn this.change 1)}}>+1</button>\n<button type=\"button\" {{on \"click\" (fn this.change -1)}}>-1</button>\n```\n\nIn templates, we refer to arguments by prefixing them with the `@` sign (in this\ncase `@multiple`). In order to compute `this.total`, we'll need to refer to the\n`multiple` argument from JavaScript.\n\nWe refer to a component's argument from JavaScript by prefixing them with\n`this.args.`.\n\nIn JavaScript, we refer to it as `this.args.multiple`.\n\n```js {data-filename=\"app/components/counter.js\" data-diff=\"-7,-10,+11\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n  @tracked multiple = 1;\n\n  get total() {\n    return this.count * this.multiple;\n    return this.count * this.args.multiple;\n  }\n\n  @action\n  change(amount) {\n    this.count = this.count + amount;\n  }\n}\n```\n\nThe `total` is now computed by multiplying a piece of _local state_\n(`this.count`) with an argument (`this.args.multiple`). You can mix and match\nlocal state and arguments however you wish, which allows you to easily break up\na component into smaller pieces.\n\n## Combining Arguments and Actions\n\nWe can also pass actions down to components via their arguments, which allows\nchild components to communicate with their parents and notify them of changes\nto state. For instance, if we wanted to add back the doubling button we had\npreviously, we could using an action passed down via arguments.\n\n```handlebars {data-filename=\"app/components/counter.hbs\"}\n<p>{{this.count}}</p>\n<p>× {{@multiple}}</p>\n<p>= {{this.total}}</p>\n\n<button type=\"button\" {{on \"click\" (fn this.change 1)}}>+1</button>\n<button type=\"button\" {{on \"click\" (fn this.change -1)}}>-1</button>\n\n<button type=\"button\" {{on \"click\" this.double}}>Double It</button>\n```\n\n```js {data-filename=\"app/components/counter.js\" data-diff=\"+9,+17,+18,+19,+20\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CounterComponent extends Component {\n  @tracked count = 0;\n\n  get total() {\n    return this.count * this.args.multiple;\n  }\n\n  @action\n  change(amount) {\n    this.count = this.count + amount;\n  }\n\n  @action\n  double() {\n    this.args.updateMultiple(this.args.multiple * 2);\n  }\n}\n```\n\nNow, the Counter calls the `updateMultiple` argument (which we expect to be a\nfunction) with the new value for `multiple`, and the parent component can update\nthe multiple.\n\n```handlebars {data-filename=\"app/components/double-it.hbs\"}\n<Counter @multiple={{this.multiple}} @updateMultiple={{this.updateMultiple}} />\n```\n\n```js {data-filename=\"app/components/double-it.js\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class DoubleItComponent extends Component {\n  @tracked multiple = 1;\n\n  @action\n  updateMultiple(newMultiple) {\n    this.multiple = newMultiple;\n  }\n}\n```\n\n## Learn more\n\nYou will frequently create components in an app. Establishing patterns early can help reduce bugs and unforeseen issues. Learn more from the chapter [Patterns for Components](../../in-depth-topics/patterns-for-components/).\n\nActions are JavaScript methods that you can call from a template. Find out how you can use actions with recommended patterns from the chapter [Patterns for Actions](../../in-depth-topics/patterns-for-actions/).\n\n<!-- eof - needed for pages that end in a code block  -->","description":"While you can accomplish a lot in Ember using HTML templating, you'll need JavaScript to make your application interactive. \n\nLet's start with a small example, a counter component. When the user presses the +1 button, the count will increase by 1. When the..."}}}