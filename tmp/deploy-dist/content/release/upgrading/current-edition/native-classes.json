{"data":{"type":"contents","id":"upgrading/current-edition/native-classes","attributes":{"content":"Native classes are a feature of JavaScript. They are officially supported in\nEmber Octane for use with:\n\n- Components (except classic components)\n- Ember Data Models\n- Routes\n- Controllers\n- Services\n- Helpers\n- General utility classes\n\nThe [`ember-native-class-codemod`](https://github.com/ember-codemods/ember-native-class-codemod) will help you convert your existing code to Native Classes.\n\nFor developers who are not already familiar with native classes, check out\n[Ember's native class guide](../../../in-depth-topics/native-classes-in-depth/),\nwhich provides a thorough breakdown of native class functionality and usage.\nThis section of the upgrade guide will focus on the differences between classic\nEmber classes and native classes. You can also reference the [Octane vs. Classic\nCheatsheet](https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/) as a quick reference for these differences.\n\n## Benefits of Native Classes\n\nFor existing Ember users, Native Classes might seem a bit strange, but for\ndevelopers coming from general JavaScript backgrounds or other frameworks, it\nmight be hard for them to imagine Ember any other way.\n\nBefore classes were available in JavaScript, Ember developers still got to use\nsome class-like features thanks to `@ember/object`. Now that classes are\navailable in JavaScript, we can do away with some of the `@ember/object` quirks.\n\n## Native Classes for classic component\n\nThe only class that is _not_ supported out of the box is the _classic Ember component_ class,\ni.e. one imported from `@ember/component`. However, you can instead use\nexternal addons like [ember-decorators](https://ember-decorators.github.io/ember-decorators)\nif you want to convert these to native classes, and refer to their documentation\nas a guide.\n\n### `constructor` instead of `init`\n\nWhen using native classes, you should use `constructor` instead of the `init`\nfunction:\n\n```js\n// Before\nimport Controller from '@ember/controller';\nimport { service } from '@ember/service';\n\nexport default Controller.extend({\n  store: service(),\n\n  init() {\n    this._super(...arguments);\n\n    this.featureFlags = this.store.findAll('feature-flag');\n  },\n});\n```\n\n```js\n// After\nimport Controller from '@ember/controller';\nimport { service } from '@ember/service';\n\nexport default class ApplicationController extends Controller {\n  @service store;\n\n  constructor() {\n    super(...arguments);\n\n    this.featureFlags = this.store.findAll('feature-flag');\n  }\n}\n```\n\nThe `init` hook still exists on many existing classes, and runs _after_\n`constructor`, so you can generally convert to native class syntax without\nrewriting your `init` methods. However, in the future `init` will be removed,\nso you should eventually transition to `constructor`.\n\nIt's important to note that only _explicit_ injections are available during\nclass construction (e.g. injections added using `@service`). If you still rely\non _implicit_ injections, like Ember Data automatically injecting the `store`\nservice, you will need to add it explicitly instead:\n\n```js\nimport Controller from '@ember/controller';\n\nexport default class ApplicationController extends Controller {\n  constructor() {\n    super(...arguments);\n\n    this.featureFlags = this.store.findAll('feature-flag');\n    // Error: store is undefined, so this will break\n  }\n}\n```\n\nAdding explicit injections in general is a highly recommended practice.\n\n### Fields vs. Properties\n\nNative classes have _fields_ instead of properties:\n\n```js\n// Before\nimport Controller from '@ember/controller';\n\nexport default Controller.extend({\n  title: 'hello-world.app',\n});\n```\n\n```js\n// After\nimport Controller from '@ember/controller';\n\nexport default class ApplicationController extends Controller {\n  title = 'hello-world.app';\n}\n```\n\nFields are syntactic sugar for assigning the value in the constructor, like so:\n\n```js\nimport Controller from '@ember/controller';\n\nexport default class ApplicationController extends Controller {\n  constructor() {\n    super(...arguments);\n    this.title = 'hello-world.app';\n  }\n}\n```\n\nThis means that the field created is assigned for every _instance_, instead of\nonce on the prototype like properties. This has a few important implications:\n\n1. It is now _safe_ to assign objects to fields! You can assign an array or an\n   object to your field, and it won't be shared between instances of the class:\n\n   ```js\n   import Component from '@glimmer/component';\n\n   export default class ShoppingListComponent extends Component {\n     // This is completely ok!\n     items = ['milk', 'potatoes'];\n   }\n   ```\n\n2. Performance can be a concern with fields, since they eagerly create new\n   values for _every_ instance of the component. This is generally not a\n   problem, but is something to be aware of.\n\n3. If you are mixing native and classic class definitions, then class fields\n   from a parent class can override class properties:\n\n   ```js\n   import Controller from '@ember/controller';\n\n   class BaseController extends Controller {\n     title = 'default';\n   }\n\n   export default BaseController.extend({\n     // this title property will be overridden by the\n     // class field in the parent class\n     title: 'My Title',\n   });\n   ```\n\nOther than that, fields can generally safely replace properties.\n\n### Getters and Setters\n\nGetters and setters can be defined directly on native classes:\n\n```js\nexport default class Image {\n  width = 0;\n  height = 0;\n\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\n```\n\nIt's important to note that these are _not_ the same as computed properties,\nthey don't have caching by default or have dependencies, and they rerun\nevery time they are used. In order to have getters and setters _rerender_ when\nvalues have changed, you must either decorate them with the `@computed`\ndecorator, or use _tracked properties_.\n\nClassic classes didn't have an equivalent for native getters and setters until\nrecently, but you can define them now with the standard JavaScript getter syntax:\n\n```js\nexport default EmberObject.extend({\n  width: 0,\n  height: 0,\n\n  get aspectRatio() {\n    return this.width / this.height;\n  },\n});\n```\n\n### Decorators\n\nDecorators are a new concept in _JavaScript_, but if you've never seen them\nbefore, don't worry, they've been used in Ember for _years_. `computed()` is in\nfact a type of decorator:\n\n```js\nimport EmberObject, { computed } from '@ember/object';\n\nexport default EmberObject.extend({\n  width: 0,\n  height: 0,\n\n  aspectRatio: computed('width', 'height', {\n    get() {\n      return this.width / this.height;\n    },\n  }),\n});\n```\n\nThe native decorator version functions the same, just with a slightly different\nsyntax:\n\n```js\nimport { computed } from '@ember/object';\n\nexport default class Image {\n  width = 0;\n  height = 0;\n\n  @computed('width', 'height')\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\n```\n\nNotice that you don't need to pass in the `get` function to the decorator\nitself. Instead, the decorator gets _applied_ to the getter function, modifying it\nin place. Existing computed properties and computed property macros, including\ncustom ones you've defined, can be used with this new syntax:\n\n```js\nimport { computed } from '@ember/object';\nimport { alias } from '@ember/object/computed';\n\nfunction join(...keys) {\n  return computed(...keys, {\n    get() {\n      return keys.map(key => this[key]).join(' ');\n    },\n  });\n}\n\n// Before\nconst ClassicPerson = EmberObject.extend({\n  nickname: 'Tom',\n  title: 'Prof.',\n  name: 'Tomster',\n\n  fullName: join('title', 'name'),\n  displayName: alias('nickname'),\n});\n\n// After\nclass Person {\n  nickName = 'Tom';\n  title = 'Prof.';\n  name = 'Tomster';\n\n  @join('title', 'name') fullName;\n  @alias('nickname') displayName;\n}\n```\n\nOther decorators exist, including `@tracked` which will be discussed later on,\nand the `@action` decorator. The `@action` decorator replaces the `actions` hash\non routes, controllers, and components:\n\n```js\n// Before\nimport Controller from '@ember/controller';\n\nexport default Controller.extend({\n  actions: {\n    helloWorld() {\n      console.log('Hello, world!');\n    },\n  },\n});\n```\n\n```js\n// After\nimport Controller from '@ember/controller';\nimport { action } from '@ember/object';\n\nexport default class ApplicationController extends Controller {\n  @action\n  helloWorld() {\n    console.log('Hello, world!');\n  }\n}\n```\n\nThe action decorator also _binds_ actions, so you can refer to them directly in\ntemplates without the `{{action}}` helper:\n\n```handlebars\n{{!-- Before --}}\n<OtherComponentHere @update={{action 'helloWorld'}} />\n```\n\n```handlebars\n{{!-- After --}}\n<OtherComponentHere @update={{this.helloWorld}} />\n```\n\n### `super`\n\nIn native classes, there is a dedicated `super` keyword that replaces the\n`_super()` method:\n\n```js\n// Before\nconst Person = EmberObject.extend();\n\nconst Firefighter = Person.extend({\n  init() {\n    this._super(...arguments);\n    this.name = 'Rob Jackson';\n  },\n\n  saveKitten() {\n    this._super(...arguments);\n    console.log('kitten saved!');\n  }\n});\n\n// After\nclass Person {}\n\nclass Firefighter extends Person {\n  constructor() {\n    super();\n    this.name = 'Rob Jackson';\n  }\n\n  saveKitten() {\n    if (super.saveKitten) {\n      super.saveKitten(...arguments);\n    }\n\n    console.log('kitten saved!');\n  }\n}\n```\n\nAs you can see, it functions a little bit differently that the `_super()`\nmethod. When used in a constructor, you call it directly like a function. You\n_must_ do this before using `this` in the constructor, otherwise it's a syntax\nerror. However, when used in any other method, you must _explicitly_ specify\nthe function you are calling on the parent class.\n\nAnother difference is that unlike `_super()`, if the method doesn't exist on the\nparent class then an error will be thrown. In most cases, the method should\nexist or not, and you shouldn't need to guard it one way or the other.\n\n### `static`\n\nIn classic classes, if you wanted to add values to the _class_ itself, you had\nto use the `reopenClass` method:\n\n```js\nconst Vehicle = EmberObject.extend({\n  init() {\n    this._super();\n    this.id = Vehicle.count;\n    Vehicle.incrementCount();\n  },\n});\n\nVehicle.reopenClass({\n  count: 0,\n  incrementCount() {\n    this.count++;\n  },\n});\n```\n\nIn native classes this can be done with the `static` keyword instead:\n\n```js\nclass Vehicle {\n  static count = 0;\n  static incrementCount() {\n    this.count++;\n  }\n\n  constructor() {\n    this.id = Vehicle.count;\n    Vehicle.incrementCount();\n  }\n}\n```\n\nThe `static` keyword can be applied to all class elements.\n\n### Mixins\n\nNative class syntax does not directly have an equivalent for the Ember mixin\nsystem. If you want to continue using mixins as you convert, you can do so by\nmixing classic class extension syntax with native class syntax:\n\n```js\nexport default class Vehicle extends EmberObject.extend(MotorMixin) {\n  // ...\n}\n```\n\nIn addition, some new framework classes, such as Glimmer components, do _not_\nsupport Ember mixins at all. In the future, mixins will be removed from the\nframework, and will not be replaced directly. For apps that use mixins, the\nrecommended path is to refactor the mixins to other patterns, including:\n\n* Pure native classes, sharing functionality via class inheritance.\n* Utility functions which can be imported and used in multiple classes.\n* Services which can be injected into multiple classes, sharing functionality\n  and state between them.\n\n## Cheatsheet\n\nThis cheatsheet is a quick reference for the best practices and differences in\nnative and classic classes. Remember, you should _prefer_ using native class\nsyntax and _not_ extending from `EmberObject` at all in your apps.\n\n### Definitions\n\n**Native**\n\n- Use `class` when defining a class, and `class ... extends` when extending a\n  class.\n\n    ```js\n    class Person {}\n\n    class Actress extends Person {}\n    ```\n\n- Always give your class a name, e.g. ✅ `class MyClass {}` and not 🛑 `class {}`\n\n**Classic**\n\n- Use the [`extend`][1] static method to define a class, with\n  [`EmberObject`][2] as the root base class.\n\n    ```js\n    const Person = EmberObject.extend({});\n\n    const Actress = Person.extend({});\n    ```\n\n[1]: https://api.emberjs.com/ember/release/functions/@ember%2Fobject/extend\n[2]: https://api.emberjs.com/ember/release/classes/EmberObject\n\n### Instantiation\n\n**Native**\n\n- Use the `new` keyword to create instances of the class\n\n    ```js\n    class Person {}\n\n    let jen = new Person();\n    ```\n\n- Arguments passed when using `new` will be accessible in the `constructor` of\n  the class:\n\n    ```js\n    class Person {\n      constructor(name) {\n        this.name = name;\n      }\n    }\n\n    let jen = new Person('Jen Weber');\n    console.log(jen.name); // Jen Weber\n    ```\n\n- Prefer the `constructor` function, unless the class extends `EmberObject`,\n  in which case prefer `init`.\n\n**Classic**\n\n- Use the [`create`][3] static method to create instances of the class:\n\n    ```js\n    const Person = EmberObject.extend({});\n\n    let jen = Person.create();\n    ```\n\n- You can pass an object of values to `create`, and they'll be assigned to the\n  instance:\n\n    ```js\n    const Person = EmberObject.extend({});\n\n    let jen = Person.create({ name: 'Jen Weber' });\n    console.log(jen.name); // Jen Weber\n    ```\n\n- Use the `init` method instead of the `constructor`.\n\n[3]: https://api.emberjs.com/ember/release/functions/@ember%2Fobject/create\n\n### Methods\n\nMostly the same between native and classic:\n\n**Native**\n\n```js\nclass Person {\n  helloWorld() {\n    console.log('Hello, world!');\n  }\n}\n```\n\n**Classic**\n\n```js\nconst Person = EmberObject.extend({\n  helloWorld() {\n    console.log('Hello, world!');\n  },\n});\n```\n\n### Properties and Fields\n\n**Native**\n\n- Native classes have _fields_. Fields are created and assigned for every\n  instance:\n\n    ```js\n    class Person {\n      name = 'Chad Hietala';\n    }\n    ```\n\n- It is okay to assign objects and arrays in class fields:\n\n    ```js\n    // ok ✅\n    class Person {\n      shoppingList = [];\n    }\n    ```\n\n- Avoid using class state in field definitions, use the constructor instead:\n\n    ```js\n    // bad 🛑\n    class Image {\n      width = 0;\n      height = 0;\n\n      aspectRatio = this.width / this.height;\n    }\n\n    // good ✅\n    class Image {\n      constructor() {\n        this.aspectRatio = this.width / this.height;\n      }\n\n      width = 0;\n      height = 0;\n    }\n    ```\n\n- Fields are assigned before any constructor code is run, so you can access\n  their values in the `constructor` function.\n\n**Classic**\n\n- Classic classes have _properties_. Properties are created and assigned once to\n  the _prototype_ of the class, and are shared between every instance:\n\n    ```js\n    const Person = EmberObject.extend({\n      name: 'Chad Hietala',\n    });\n    ```\n\n- It is _not_ okay to assign objects or arrays as properties, because they are\n  shared between instances:\n\n    ```js\n    // not ok 🛑\n    const Person = EmberObject.extend({\n      shoppingList: [],\n    });\n    ```\n\n### Accessors\n\nThese are also mostly the same between native and classic classes.\n\n- Accessors can be defined with the `get` and `set` keywords:\n\n    ```js\n    class Person {\n      _name = 'Mel Sumner';\n\n      get name() {\n        return this._name;\n      }\n\n      set name(newName) {\n        this._name = newName;\n      }\n    }\n    ```\n\n- Getters run every time the property is read, setters run every time the\n  property is set.\n- Getters should not mutate state, and should be idempotent (they return the\n  same value every time if nothing else has changed).\n\n### Decorators\n\n**Native**\n\n- Decorators are _modifiers_ that change the behavior of a field, method, or\n  class.\n- Native decorators are functions that get applied using the `@` symbol:\n\n    ```js\n    import { tracked } from '@glimmer/tracking';\n\n    class Person {\n      @tracked name = 'Ed Faulkner';\n    }\n    ```\n\n- Native decorators can be applied to class fields, methods, accessors, or\n  classes themselves. Generally, specific decorators are only meant to be\n  applied to one or two of these types of things.\n- Decorators can also receive arguments, and some decorators must receive them.\n- Every decorator is unique! See the documentation for each decorator to see how\n  it should be used.\n\n**Classic**\n\n- Classic decorators are assigned like properties in classic class definitions:\n\n    ```js\n    import EmberObject from '@ember/object';\n    import { tracked } from '@glimmer/tracking';\n\n    const Person = EmberObject.extend({\n      name: tracked({ value: 'Ed Faulkner' }),\n    });\n    ```\n\n- Only specific decorators provided by Ember can be applied this way in classic\n  classes.\n\n### Static Elements\n\n**Native**\n\n- Adding the `static` keyword to a class element definition puts it on the\n  _class_ itself, instead of instances:\n\n    ```js\n    class Person {\n      static name = 'Ed Faulkner';\n    }\n\n    console.log(Person.name); // Ed Faulkner\n\n    let person = new Person();\n\n    console.log(person.name); // undefined\n    ```\n\n**Classic**\n\n- Use `reopenClass` to add static elements to the constructor:\n\n    ```js\n    const Person = EmberObject.extend();\n\n    Person.reopenClass({\n      name: 'Ed Faulkner',\n    });\n    ```\n\n### Super\n\n**Native**\n\n- Use the `super` keyword\n- In constructors, use the keyword by itself (this is required). Generally pass\n  any arguments along as well:\n\n    ```js\n    class TodoComponent extends Component {\n      constructor() {\n        super(...arguments);\n\n        // setup the component...\n      }\n    }\n    ```\n\n- In all other cases, specify the _method_ you want to call when using `super`:\n\n    ```js\n    class Vehicle {\n      moveType = 'moving';\n\n      move() {\n        console.log(`${this.moveType}!`);\n      }\n    }\n\n    class Aircraft extends Vehicle {\n      moveType = 'flying';\n\n      fly() {\n        super.move();\n      }\n    }\n\n    let airbus = new Aircraft();\n    airbus.fly(); // flying!\n    ```\n\n- If the method does not exist on the parent class, it will throw an error.\n\n**Classic**\n\n- Use the `_super()` function to call the super method with the same name as the\n  current method that is executing:\n\n    ```js\n    const Vehicle = EmberObject.extend({\n      move() {\n        console.log(`moving!`);\n      },\n    });\n\n    const Aircraft = Vehicle.extend({\n      move() {\n        this._super();\n        console.log('flying!');\n      },\n    });\n\n    let airbus = new Aircraft();\n    airbus.move(); // moving! flying!\n    ```\n\n- Calling `_super()` is _required_ for `init` to function properly. It should\n  generally be done before you do anything else in `init`.\n- It will _not_ error if the method does not exist on the parent class.\n\n### Extending Classic Classes with Native Syntax\n\n- It is possible to extend classic classes with native syntax, and to toggle\n  back and forth between the two:\n\n    ```js\n    class Vehicle extends EmberObject {\n      move() {\n        // ...\n      }\n    }\n\n    const Aircraft = Vehicle.extend({\n      fly() {\n        // ...\n      },\n    });\n\n    class Helicopter extends Aircraft {\n      hover() {\n        // ...\n      }\n    }\n\n    let blackHawk = Helicopter.create();\n    ```\n\n- Use `init` instead of `constructor`\n- Use `create` instead of `new`\n- Otherwise, when using native class syntax, native class rules and behaviors\n  apply, and when using classic class syntax, classic class rules apply.","description":"Native classes are a feature of JavaScript. They are officially supported in Ember Octane for use with: \n\n- Components (except classic components)\n- Ember Data Models\n- Routes\n- Controllers\n- Services\n- Helpers\n- General utility classes \n\nThe..."}}}