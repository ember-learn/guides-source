{"data":{"type":"contents","id":"testing/testing-components","attributes":{"content":"Components can be tested easily with a rendering test.\nLet's see how this plays out in a specific example:\n\nLet's assume we have a component with a `style` property that is updated whenever the value of the `name` property changes.\nThe `style` attribute of the component is bound to its `style` property.\n\n> You can follow along by generating your own component with `ember generate\n> component pretty-color`.\n\n```javascript {data-filename=\"app/components/pretty-color.js\"}\nimport Component from '@glimmer/component';\n\nexport default class PrettyColorComponent extends Component {\n  get style() {\n    return `color: ${this.args.name}`;\n  }\n}\n```\n\n```handlebars {data-filename=\"app/components/pretty-color.hbs\"}\n<div style={{this.style}}>\n  Pretty Color: {{@name}}\n</div>\n```\n\nThe `module` from QUnit will scope your tests into groups of tests which can be configured and run independently.\nMake sure to call the `setupRenderingTest` function together with the `hooks` parameter first in your new module.\nThis will do the necessary setup for testing your component for you,\nincluding setting up a way to access the rendered DOM of your component later on in the test,\nand cleaning up once your tests in this module are finished.\n\n```javascript {data-filename=\"tests/integration/components/pretty-color-test.js\"}\nimport { module } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\n\nmodule('Integration | Component | pretty-color', function(hooks) {\n  setupRenderingTest(hooks);\n\n});\n```\n\nInside of your `module` and after setting up the test, we can now start to create our first test case.\nHere, we can use the `QUnit.test` helper and we can give it a descriptive name:\n\n```javascript {data-filename=\"tests/integration/components/pretty-color-test.js\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\n\nmodule('Integration | Component | pretty-color', function(hooks) {\n  setupRenderingTest(hooks);\n\n  test('should change colors', async function(assert) {\n\n\n  });\n});\n```\n\nAlso note how the callback function passed to the test helper is marked with the keyword `async`.\nThe [ECMAScript 2017 feature async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) allows us to write asynchronous code in an easy-to-read,\nseemingly synchronous manner.\nWe can better see what this means, once we start writing out our first test case:\n\n```javascript {data-filename=\"tests/integration/components/pretty-color-test.js\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\nimport { render } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\n\nmodule('Integration | Component | pretty-color', function(hooks) {\n  setupRenderingTest(hooks);\n\n  test('should change colors', async function(assert) {\n    assert.expect(1);\n\n    // set the outer context to red\n    this.set('colorValue', 'red');\n\n    await render(hbs`<PrettyColor @name={{this.colorValue}} />`);\n\n    assert.equal(this.element.querySelector('div').getAttribute('style'), 'color: red', 'starts as red');\n  });\n});\n```\n\nEach test can use the `render()` function imported from the `@ember/test-helpers` package to create a new instance of the component by declaring the component in template syntax,\nas we would in our application.\nAlso notice, the keyword `await` in front of the call to `render`.\nIt allows the test which we marked as `async` earlier to wait for any asynchronous behavior to complete before executing the rest of the code below.\nIn this case our first assertion will correctly execute after the component has fully rendered.\n\nNext we can test that changing the component's `name` property updates the\ncomponent's `style` attribute and is reflected in the rendered HTML:\n\n```javascript {data-filename=\"tests/integration/components/pretty-color-test.js\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\nimport { render } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\n\nmodule('Integration | Component | pretty-color', function(hooks) {\n  setupRenderingTest(hooks);\n\n  test('it renders', async function(assert) {\n    assert.expect(2);\n\n    // set the outer context to red\n    this.set('colorValue', 'red');\n\n    await render(hbs`<PrettyColor @name={{this.colorValue}} />`);\n\n    assert.equal(this.element.querySelector('div').getAttribute('style'), 'color: red', 'starts as red');\n\n    this.set('colorValue', 'blue');\n\n    assert.equal(this.element.querySelector('div').getAttribute('style'), 'color: blue', 'updates to blue');  });\n});\n```\n\nWe might also test this component to ensure that the content of its template is being rendered properly:\n\n```javascript {data-filename=\"tests/integration/components/pretty-color-test.js\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\nimport { render } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\n\nmodule('Integration | Component | pretty-color', function(hooks) {\n  setupRenderingTest(hooks);\n\n  test('it renders', async function(assert) {\n    assert.expect(2);\n\n    this.set('colorValue', 'orange');\n\n    await render(hbs`<PrettyColor @name={{this.colorValue}} />`);\n\n    assert.equal(this.element.textContent.trim(), 'Pretty Color: orange', 'text starts as orange');\n\n    this.set('colorValue', 'green');\n\n    assert.equal(this.element.textContent.trim(), 'Pretty Color: green', 'text switches to green');\n  });\n});\n```\n\n### Testing User Interaction\n\nComponents are a great way to create powerful, interactive, and self-contained custom HTML elements.\nIt is important to test the component's methods _and_ the user's interaction with the component.\n\nImagine you have the following component that changes its title when a button is clicked on:\n\n> You can follow along by generating your own component with `ember generate\n> component magic-title`.\n\n```javascript {data-filename=\"app/components/magic-title.js\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class MagicTitleComponent extends Component {\n  @tracked title = 'Hello World';\n\n  @action\n  updateTitle() {\n    this.title = 'This is Magic';\n  }\n}\n```\n\n```handlebars {data-filename=\"app/components/magic-title.hbs\"}\n<h2>{{this.title}}</h2>\n\n<button type=\"button\" class=\"title-button\" {{on \"click\" this.updateTitle}}>\n  Update Title\n</button>\n```\n\nAnd our test might look like this:\n\n```javascript {data-filename=\"tests/integration/components/magic-title-test.js\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\nimport { click, render } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\n\nmodule('Integration | Component | magic-title', function(hooks) {\n  setupRenderingTest(hooks);\n\n  test('should update title on button click', async function(assert) {\n    assert.expect(2);\n\n    await render(hbs`<MagicTitle />`);\n\n    assert.equal(this.element.querySelector('h2').textContent.trim(), 'Hello World', 'initial text is hello world');\n\n    // Click on the button\n    await click('.title-button');\n\n    assert.equal(this.element.querySelector('h2').textContent.trim(), 'This is Magic', 'title changes after click');\n  });\n});\n```\n\nNote how we make use of the `click` helper from [`ember-test-helpers`](https://github.com/emberjs/ember-test-helpers) to interact with the component DOM to trigger the `updateTitle` action.\nYou can find many other helpful helpers for simulating user interaction in rendering tests in the [API documentation of ember-test-helpers](https://github.com/emberjs/ember-test-helpers/blob/master/API.md).\n\n### Testing Actions\n\nComponents starting in Ember 2 utilize closure actions.\nClosure actions allow components to directly invoke functions provided by outer components.\n\nFor example, imagine you have a comment form component that invokes a `submitComment` action when the form is submitted,\npassing along the form's data:\n\n> You can follow along by generating your own component with `ember generate\n> component comment-form`.\n\n```javascript {data-filename=\"app/components/comment-form.js\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class CommentFormComponent extends Component {\n  @tracked comment = '';\n\n  @action\n  submitComment() {\n    this.args.submitComment({ comment: this.comment });\n  }\n}\n```\n\n```handlebars {data-filename=\"app/components/comment-form.hbs\"}\n<form {{on \"submit\" this.submitComment}}>\n  <label for=\"comment\">Comment:</label>\n  <Textarea id=\"comment\" @value={{this.comment}} />\n  <input class=\"comment-input\" type=\"submit\" value=\"Submit\"/>\n</form>\n```\n\nHere's an example test that asserts that the specified `externalAction` function is invoked when the component's internal `submitComment` action is triggered by making use of a test double (dummy function).\n`assert.expect(1)` at the top of the test makes sure that the assertion inside the\nexternal action is called:\n\n```javascript {data-filename=\"tests/integration/components/comment-form-test.js\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\nimport { click, fillIn, render } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\n\nmodule('Integration | Component | comment-form', function(hooks) {\n  setupRenderingTest(hooks);\n\n  test('should trigger external action on form submit', async function(assert) {\n    assert.expect(1);\n\n    // test double for the external action\n    this.set('externalAction', (actual) => {\n      let expected = { comment: 'You are not a wizard!' };\n      assert.deepEqual(actual, expected, 'submitted value is passed to external action');\n    });\n\n    await render(hbs`<CommentForm @submitComment={{this.externalAction}} />`);\n\n    // fill out the form and force an onchange\n    await fillIn('textarea', 'You are not a wizard!');\n\n    // click the button to submit the form\n    await click('.comment-input');\n  });\n});\n```\n\n### Stubbing Services\n\nIn cases where components have dependencies on Ember services,\nit is possible to stub these dependencies for rendering tests.\nYou stub non-Ember services by using the built-in `register()` function to register your stub service in place of the default.\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\nIf you are thinking of stubbing the router service in a unit or integration test, consider writing an acceptance test instead. Acceptance tests let you navigate through many routes in your app, and the router does not need to be stubbed in them. If you choose to stub the router, you will need to stub multiple methods.\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\nImagine you have the following component that uses a location service to display the city and country of your current location:\n\n> You can follow along by generating your own component with `ember generate\n> component location-indicator`.\n\n```javascript {data-filename=\"app/components/location-indicator.js\"}\nimport Component from '@glimmer/component';\nimport { service } from '@ember/service';\n\nexport default class LocationIndicatorComponent extends Component {\n  @service location;\n\n  // when the coordinates change, call the location service to get the current city and country\n  get city() {\n    return this.location.getCurrentCity();\n  }\n\n  get country() {\n    return this.location.getCurrentCountry();\n  }\n}\n```\n\n```handlebars {data-filename=\"app/components/location-indicator.hbs\"}\nYou currently are located in {{this.city}}, {{this.country}}\n```\n\nTo stub the location service in your test, create a local stub object that extends `Service` from `@ember/service`,\nand register the stub as the service your tests need in the beforeEach function.\nIn this case we initially force location to \"New York\".\n\n```javascript {data-filename=\"tests/integration/components/location-indicator-test.js\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\nimport { render } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\nimport Service from '@ember/service';\n\n// Stub location service\nclass LocationStub extends Service {\n  city = 'New York';\n  country = 'USA';\n  currentLocation = {\n    x: 1234,\n    y: 5678\n  };\n\n  getCurrentCity() {\n    return this.city;\n  }\n\n  getCurrentCountry() {\n    return this.country;\n  }\n}\n\nmodule('Integration | Component | location-indicator', function(hooks) {\n  setupRenderingTest(hooks);\n\n  hooks.beforeEach(function(assert) {\n    this.owner.register('service:location-service', LocationStub);\n  });\n});\n```\n\nOnce the stub service is registered,\nthe test needs to check that the stub data from the service is reflected in the component output.\n\n```javascript {data-filename=\"tests/integration/components/location-indicator-test.js\" data-diff=\"+30,+31,+32,+33,+34,+35\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\nimport { render } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\nimport Service from '@ember/service';\n\n// Stub location service\nclass LocationStub extends Service {\n  city = 'New York';\n  country = 'USA';\n  currentLocation = {\n    x: 1234,\n    y: 5678\n  };\n\n  getCurrentCity() {\n    return this.city;\n  }\n  \n  getCurrentCountry() {\n    return this.country;\n  }\n}\n\nmodule('Integration | Component | location-indicator', function(hooks) {\n  setupRenderingTest(hooks);\n\n  hooks.beforeEach(function(assert) {\n    this.owner.register('service:location-service', LocationStub);\n  });\n\n  test('should reveal current location', async function(assert) {\n    await render(hbs`<LocationIndicator />`);\n    assert.equal(this.element.textContent.trim(),\n     'You currently are located in New York, USA');\n  });\n});\n```\n\nIn the next example, we'll add another test that validates that the display changes when we modify the values on the service.\n\n```javascript {data-filename=\"tests/integration/components/location-indicator-test.js\" data-diff=\"+36,+37,+38,+39,+40,+41,+42,+43,+44,+45,+46,+47,+48,+49,+50\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\nimport { render } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\nimport Service from '@ember/service';\n\n// Stub location service\nclass LocationStub extends Service {\n  city = 'New York';\n  country = 'USA';\n  currentLocation = {\n    x: 1234,\n    y: 5678\n  };\n\n  getCurrentCity() {\n    return this.city;\n  }\n  \n  getCurrentCountry() {\n    return this.country;\n  }\n}\n\nmodule('Integration | Component | location-indicator', function(hooks) {\n  setupRenderingTest(hooks);\n\n  hooks.beforeEach(function(assert) {\n    this.owner.register('service:location-service', LocationStub);\n  });\n\n  test('should reveal current location', async function(assert) {\n    await render(hbs`<LocationIndicator />`);\n    assert.equal(this.element.textContent.trim(),\n     'You currently are located in New York, USA');\n  });\n\n  test('should change displayed location when current location changes', async function (assert) {\n    await render(hbs`<LocationIndicator />`);\n\n    assert.equal(this.element.textContent.trim(),\n     'You currently are located in New York, USA', 'origin location should display');\n\n    this.locationService = this.owner.lookup('service:location-service');\n    this.set('locationService.city', 'Beijing');\n    this.set('locationService.country', 'China');\n    this.set('locationService.currentLocation', { x: 11111, y: 222222 });\n\n    assert.equal(this.element.textContent.trim(),\n     'You currently are located in Beijing, China', 'location display should change');\n  });\n});\n```\n\n### Waiting on Asynchronous Behavior\n\nOften, interacting with a component will cause asynchronous behavior to occur, such as HTTP requests, or timers.\nThe module `@ember/test-helpers` provides you with several [useful helpers](https://github.com/emberjs/ember-test-helpers/blob/master/API.md) that will allow you to wait for any asynchronous behavior to complete that is triggered by a DOM interaction induced by those.\nTo use them in your tests, you can `await` any of them to make sure that subsequent assertions are executed once the asynchronous behavior has fully settled:\n\n```javascript\nawait click('button.submit-button'); // clicks a button and waits for any async behavior initiated by the click to settle\nassert.equal(this.element.querySelector('.form-message').textContent, 'Your details have been submitted successfully.');\n```\n\nNearly all of the helpers for DOM interaction from `@ember/test-helpers` return a call to `settled` - a function\nthat ensures that any Promises, operations in Ember's `run` loop, timers or network requests have already resolved.\nThe `settled` function itself returns a Promise that resolves once all async operations have come to an end.\n\nYou can use `settled` as a helper in your tests directly and `await` it for all async behavior to settle deliberately.\n\nImagine you have a typeahead component that uses [`Ember.run.debounce`](https://api.emberjs.com/ember/release/classes/@ember%2Frunloop/methods/debounce?anchor=debounce) to limit requests to the server, and you want to verify that results are displayed after typing a character.\n\n> You can follow along by generating your own component with `ember generate\n> component delayed-typeahead`.\n\n```javascript {data-filename=\"app/components/delayed-typeahead.js\"}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\nimport { debounce } from '@ember/runloop';\n\nexport default class DelayedTypeaheadComponent extends Component {\n  @tracked searchValue = '';\n\n  @action\n  handleTyping() {\n    // The fetchResults function is passed into the component from its parent\n    debounce(this, this.args.fetchResults, this.searchValue, 250);\n  }\n};\n```\n\n```handlebars {data-filename=\"app/components/delayed-typeahead.hbs\"}\n<label for=\"search\">Search</label>\n<Input id=\"search\" @value={{this.searchValue}} {{on 'keyup' this.handleTyping}} />\n<ul>\n  {{#each @results as |result|}}\n    <li class=\"result\">{{result.name}}</li>\n  {{/each}}\n</ul>\n```\n\nIn your test, use the `settled` helper to wait until your debounce timer is up and then assert that the page is rendered appropriately.\n\n```javascript {data-filename=\"tests/integration/components/delayed-typeahead-test.js\"}\nimport { module, test } from 'qunit';\nimport { setupRenderingTest } from 'ember-qunit';\nimport { render, settled } from '@ember/test-helpers';\nimport { hbs } from 'ember-cli-htmlbars';\n\nmodule('Integration | Component | delayed-typeahead', function(hooks) {\n  setupRenderingTest(hooks);\n\n  const stubResults = [\n    { name: 'result 1' },\n    { name: 'result 2' }\n  ];\n\n  test('should render results after typing a term', async function(assert) {\n    assert.expect(2);\n\n    this.set('results', []);\n    this.set('fetchResults', (value) => {\n      assert.equal(value, 'test', 'fetch closure action called with search value');\n      this.set('results', stubResults);\n    });\n\n    await render(hbs`<DelayedTypeahead @fetchResults={{this.fetchResults}} @results={{this.results}} />`);\n    this.element.querySelector('input').value = 'test';\n    this.element.querySelector('input').dispatchEvent(new Event('keyup'));\n\n    await settled();\n\n    assert.equal(this.element.querySelectorAll('.result').length, 2, 'two results rendered');\n  });\n});\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"Components can be tested easily with a rendering test. Let's see how this plays out in a specific example: \n\nLet's assume we have a component with a style property that is updated whenever the value of the name property changes. The style attribute of the..."}}}