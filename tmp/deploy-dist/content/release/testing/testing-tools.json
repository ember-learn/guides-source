{"data":{"type":"contents","id":"testing/testing-tools","attributes":{"content":"Ember comes with great testing tools out of the box and popular addons which you can use as your testing game evolves.\n\nIn this section, we will go through various tools, that you can use while building an Ember app.\n\n## What Tools Can Help Me?\n\n### QUnit, QUnit DOM\n\nEvery Ember app comes with [QUnit](http://qunitjs.com/) and [QUnit DOM](https://github.com/simplabs/qunit-dom). QUnit is a testing framework, and QUnit DOM is a library that helps you **write tests that are concise and readable**.\n\nTo see the power of QUnit DOM, consider this code snippet. It checks whether our button component shows the right label and the right attributes.\n\n```javascript {data-filename=tests/integration/components/simple-button-test.js}\n/*\n  For simplicity, the import, module, and setup statements\n  are omitted here. Our component accepts two arguments,\n  label (string) and isDisabled (boolean).\n*/\ntest(\"should show label\", async function (assert) {\n  await render(hbs`\n    <SimpleButton\n      @label=\"Hello world!\"\n    />\n  `);\n  let button = this.element.querySelector(\"button\");\n\n  // QUnit\n  assert.strictEqual(button.textContent.trim(), \"Hello world!\");\n\n  // QUnit DOM\n  assert.dom(button).hasText(\"Hello world!\");\n});\n\ntest(\"should allow disabling the button\", async function (assert) {\n  await render(hbs`\n    <SimpleButton\n      @label=\"Hello world!\"\n      @isDisabled={{true}}\n    />\n  `);\n  let button = this.element.querySelector(\"button\");\n\n  // QUnit\n  assert.strictEqual(button.disabled, true);\n  assert.ok(button.classList.contains(\"is-disabled\"));\n\n  // QUnit DOM\n  assert.dom(button).hasAttribute(\"disabled\");\n  assert.dom(button).hasClass(\"is-disabled\");\n});\n```\n\n### Mocha, Chai DOM\n\n[Mocha](https://mochajs.org/) is another testing framework. If you are more familiar with Mocha, you can install [ember-mocha](https://github.com/emberjs/ember-mocha) and [Chai DOM](https://www.chaijs.com/plugins/chai-dom/) instead.\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        All examples in this guide follow QUnit. Rest assured, the best practices for testing that we present in this guide are independent of your choice of testing framework. Keep in mind, the setup functions from <a href=\"https://github.com/emberjs/ember-qunit\" target=\"_blank\" rel=\"noopener noreferrer\">ember-qunit</a>—<code>setupTest</code>, <code>setupRenderingTest</code>, and <code>setupApplicationTest</code>—need to be replaced with those from <a href=\"https://github.com/emberjs/ember-mocha\" target=\"_blank\" rel=\"noopener noreferrer\">ember-mocha</a>.\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\n### Ember CLI\n\nWhen you use [Ember CLI](https://ember-cli.com/generators-and-blueprints) to generate an Ember \"object\" (e.g. component, model, service), it will create a test file with a setup that correctly addresses your testing framework and the [type of test that you should write](./test-types).\n\nYou can also use Ember CLI to create the test file separately from the object. For example, if you enter the following lines in the terminal:\n\n```bash\nember g model-test student\nember g component-test student\nember g acceptance-test students\n```\n\nyou get a unit test for the `student` model, a rendering test (integration test) for the `student` component, and an application test (acceptance test) that can be used to check the `students` route and its subroutes.\n\n### Ember Test Selectors\n\nYou want to be able to grab DOM elements in your tests. Since Ember is just JavaScript, you can use [`querySelector`](https://developer.mozilla.org/docs/Web/API/Element/querySelector) and [`querySelectorAll`](https://developer.mozilla.org/docs/Web/API/Element/querySelectorAll) to do so. These methods require you to pass a **selector**, a string that identifies the element(s) that you want.\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Tomster says...</div>\n      <div class=\"cta-note-message\">\n        While you can use CSS classes as selectors, a best practice for testing is to <strong>separate the concerns between styling and testing</strong>. Class names and DOM structure change over time—for the better—by you, your team, and addon developers. If you rely on CSS classes, your tests will break and need a significant rewrite.\n      </div>\n    </div>\n    <img src=\"/images/mascots/tomster.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\n[Ember Test Selectors](https://github.com/simplabs/ember-test-selectors) is an addon that helps you **write tests that are more resilient to DOM changes**. You use `data-test-*` attributes to mark the elements that will be used in your tests. The addon works with QUnit DOM and helpers from [@ember/test-helpers](https://github.com/emberjs/ember-test-helpers/). It also removes the `data-test-*` attributes in the production build.\n\nConsider the example of a button component again. This time, our component can display a Material icon in addition to the label.\n\n```handlebars {data-filename=app/components/simple-button.hbs}\n<button data-test-button={{@label}} type=\"button\">\n  {{#if @icon}}\n    <i data-test-icon aria-hidden=\"true\" class=\"material-icons\">\n      {{@icon}}\n    </i>\n  {{/if}}\n\n  <span data-test-label>{{@label}}</span>\n</button>\n```\n\n```javascript {data-filename=tests/integration/components/simple-button-test.js}\ntest(\"should show icon and label\", async function (assert) {\n  await render(hbs`\n    <SimpleButton\n      @icon=\"face\"\n      @label=\"Hello world!\"\n    />\n  `);\n\n  // Bad\n  assert.strictEqual(\n    this.element.querySelector(\".material-icons\").textContent.trim(),\n    \"face\",\n    \"The user sees the correct icon.\"\n  );\n\n  assert.strictEqual(\n    this.element.querySelector(\"span\").textContent.trim(),\n    \"Hello world!\",\n    \"The user sees the correct label.\"\n  );\n\n  // Good\n  assert.strictEqual(\n    this.element.querySelector(\"[data-test-icon]\").textContent.trim(),\n    \"face\",\n    \"The user sees the correct icon.\"\n  );\n\n  assert.strictEqual(\n    this.element.querySelector(\"[data-test-label]\").textContent.trim(),\n    \"Hello world!\",\n    \"The user sees the correct label.\"\n  );\n\n  // Great!\n  assert\n    .dom(\"[data-test-icon]\")\n    .hasText(\"face\", \"The user sees the correct icon.\");\n\n  assert\n    .dom(\"[data-test-label]\")\n    .hasText(\"Hello world!\", \"The user sees the correct label.\");\n});\n```\n\n### Ember CLI Mirage\n\nIf your application receives and sends data, you want to show that you can take these actions successfully. You also want to prove that you can handle the error states correctly.\n\n[Ember CLI Mirage](https://www.ember-cli-mirage.com/) is an addon that allows you to create a mock server. You can also use it to test your app against various server states. To learn more about using Mirage in tests, we encourage you to [visit the official website](https://www.ember-cli-mirage.com/docs/testing/acceptance-tests).\n\n### Ember Exam\n\nYou want your tests to finish fast. A fast run means you get to try out a different solution and iterate many more times.\n\n[Ember Exam](https://github.com/ember-cli/ember-exam) is an addon that allows you to parallelize the run. If you have many rendering and application tests, this can dramatically speed up your testing.\n\nEmber Exam also lets you randomize how the tests are run. Why would you want to do so? When you don't properly set up and tear down a test, you can create dependencies among tests. Randomizing the order helps you catch these inadvertent bugs.\n\n### Percy\n\nLast but not least, [Percy](https://percy.io/) is a **visual regression testing** tool that helps you catch accidental style changes. You can try it out for free and pay for additional service.\n\nWhile we don't recommend this practice in general, you might also use Percy in lieu of application tests to capture complex workflows.\n\n## Summary\n\nEmber provides easy paths to integrate QUnit and Mocha, also it supports a variety of addons and debugging tools to improve your developer experience in testing.\n\nIn the next section, we will study 3 types of tests that Ember supports—unit, rendering, and application tests. We will look at each type and when you might use one over another.","description":"Ember comes with great testing tools out of the box and popular addons which you can use as your testing game evolves. \n\nIn this section, we will go through various tools, that you can use while building an Ember app. What Tools Can Help Me? QUnit, QUnit..."}}}