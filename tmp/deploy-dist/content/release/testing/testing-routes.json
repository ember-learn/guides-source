{"data":{"type":"contents","id":"testing/testing-routes","attributes":{"content":"_Container testing methods and computed properties follow previous patterns shown\nin [Testing Basics](../unit-testing-basics/) because Ember.Route extends Ember.Object._\n\nTesting routes can be done both via application tests or container tests. Application tests\nwill likely provide better coverage for routes because routes are typically used\nto perform transitions and load data, both of which are tested more easily in\nfull context rather than isolation.\n\nThat being said, sometimes it is important to test your routes in a smaller scope. For example,\nlet's say we'd like to have an alert that can be triggered from anywhere within\nour application. The alert function `displayAlert` should be put into the\n`ApplicationRoute` because all actions and events bubble up to it from\nsub-routes and controllers.\n\n> By default, Ember CLI does not generate a file for its application route.  To\n> extend the behavior of the ember application route we will run the command\n> `ember generate route application`.  Ember CLI does however generate an application\n> template, so when asked whether we want to overwrite `app/templates/application.hbs`\n> we will answer 'n'.\n\n```javascript {data-filename=app/routes/application.js}\nimport Route from '@ember/route';\nimport { action } from '@ember/object';\n\nexport default class ApplicationRoute extends Route {\n  @action\n  displayAlert(text) {\n    this._displayAlert(text);\n  }\n\n  _displayAlert(text) {\n    alert(text);\n  }\n}\n```\n\nIn this route we've [separated our concerns](http://en.wikipedia.org/wiki/Separation_of_concerns):\nThe action `displayAlert` contains the code that is called when the action is\nreceived, and the private function `_displayAlert` performs the work. While not\nnecessarily obvious here because of the small size of the functions, separating\ncode into smaller chunks (or \"concerns\") allows it to be more readily isolated\nfor testing, which in turn allows you to catch bugs more easily.\n\nHere is an example of test this route in an isolated test case:\n\n```javascript {data-filename=tests/unit/routes/application-test.js}\nimport { module, test } from 'qunit';\nimport { setupTest } from 'ember-qunit';\n\nlet originalAlert;\n\nmodule('Unit | Route | application', function(hooks) {\n  setupTest(hooks);\n\n  hooks.beforeEach(function(assert) {\n    originalAlert = window.alert; // store a reference to window.alert\n  });\n\n  hooks.afterEach(function(assert) {\n    window.alert = originalAlert; // restore window.alert\n  });\n\n  test('should display an alert', function(assert) {\n    assert.expect(2);\n\n    // get the route instance\n    let route = this.owner.lookup('route:application');\n\n    // stub window.alert to perform a qunit test\n    const expectedTextFoo = 'foo';\n    window.alert = (text) => {\n      assert.equal(text, expectedTextFoo, `expect alert to display ${expectedTextFoo}`);\n    };\n\n    // call the _displayAlert function which triggers the qunit test above\n    route._displayAlert(expectedTextFoo);\n\n    // set up a second stub to perform a test with the actual action\n    const expectedTextBar = 'bar';\n    window.alert = (text) => {\n      assert.equal(text, expectedTextBar, `expected alert to display ${expectedTextBar}`);\n    };\n\n    // Now use the routes send method to test the actual action\n    route.send('displayAlert', expectedTextBar);\n  });\n});\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"Container testing methods and computed properties follow previous patterns shown in Testing Basics because Ember.Route extends Ember.Object. \n\nTesting routes can be done both via application tests or container tests. Application tests will likely provide..."}}}