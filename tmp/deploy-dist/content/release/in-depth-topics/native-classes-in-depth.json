{"data":{"type":"contents","id":"in-depth-topics/native-classes-in-depth","attributes":{"content":"Native classes were first added to JavaScript in ES2015 (also known as ES6).\nThey are defined using the `class` keyword, and look like this:\n\n```js\nclass Person {\n  helloWorld() {\n    console.log('Hello, world!');\n  }\n}\n```\n\nThis guide will go over the basics of classes, along with two new features that\nare still in development in JavaScript: [class fields][5] and [decorators][6].\nWe use these features in Ember because they are very useful and make writing\nclass code much easier, and they have made it far enough along the process of\nbeing added to JavaScript to depend on in production applications.\n\n[5]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Field_declarations\n[6]: https://github.com/tc39/proposal-decorators\n\n## Defining Classes\n\nClasses are defined using the `class` keyword:\n\n```js\nclass Person {}\n```\n\nOnce defined, a class exists like a variable does in the current scope:\n\n```js\nfunction definePerson() {\n  class Person {}\n  console.log(Person);\n}\n\ndefinePerson(); // class Person {}\nconsole.log(Person); // Error: Person is not defined\n```\n\nYou can choose not to give your class a name, making it an _anonymous_ class.\nFor instance, you could do a default export like this, but it is not\nrecommended:\n\n```js\n// Not recommended ðŸ›‘\nexport default class {}\n```\n\nThe reasons being:\n\n1. Giving your class a name makes it easier to search for in general, and is\n   better for code editors and documentation tools.\n2. Giving your class a name gives it a name in the debugger, making your life\n   easier later on.\n\nYou can create a new _instance_ of the class using the `new` keyword:\n\n```js\nlet tom = new Person();\n```\n\nInstances are like Plain Old JavaScript Objects (POJOs) in many ways. You can\nassign values to them however you like, and generally treat them the same:\n\n```js\nlet tom = new Person();\nlet yehuda = {};\n\ntom.name = 'Tom Dale';\nyehuda.name = 'Yehuda Katz';\n\nconsole.log(tom); // Person {name: \"Tom Dale\"}\nconsole.log(yehuda); // {name: \"Yehuda Katz\"}\n```\n\nThe difference is that instances of classes _inherit_ elements that are defined\nin the class definition. For instance, we can define a _method_ on the person\nclass, and then call it from the instance:\n\n```js\nclass Person {\n  helloWorld() {\n    console.log(`${this.name} says: Hello, world!`);\n  }\n}\n\nlet tom = new Person();\ntom.name = 'Tom Dale';\ntom.helloWorld(); // Tom Dale says: Hello, world!\n```\n\nThis allows you to define different _kinds_ of objects, which have their own\nmethods, properties, fields, and more. This is essentially Object Oriented\nProgramming - you define different types of objects that handle different\nproblems and concerns, keeping your code organized.\n\n> _Note: Object Oriented Programming is a fundamental part of JavaScript, but it's not the only part -\n> JavaScript is a multi-paradigm language, and supports Object Oriented Programming patterns along with\n> Functional Programming, Event Driven programming, and imperative\n> programming. You may see strong adherents to different styles both inside and\n> outside of the Ember ecosystem, and that's OK! JavaScript is flexible, and\n> allows you to choose the patterns that work well for you, so don't feel like\n> all of your code needs to be written in a class, and likewise, don't feel like\n> everything needs to be a function._\n\nThere are 4 major types of elements that can be defined in a class:\n\n- The `constructor` function\n- Methods\n- Fields\n- Accessors, also known as getters and setters\n\nAlong with two types of modifiers that can be applied to methods, accessors,\nand fields:\n\n- `static`\n- Decorators\n\n### Constructor\n\nThe `constructor` method is a special method in classes. It's run when you\ncreate a new instance of the class, and can be used to setup the class:\n\n```js\nclass Person {\n  constructor() {\n    this.name = 'Tom Dale';\n  }\n}\n\nlet tom = new Person();\nconsole.log(tom.name); // 'Tom Dale'\n```\n\nYou can also pass arguments to the `constructor` when creating instances with\n`new`:\n\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet tom = new Person('Tom Dale');\nconsole.log(tom.name); // 'Tom Dale'\n```\n\nThe `constructor` can't be called in any other way. It doesn't exist on the\nclass or instances:\n\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet tom = new Person('Tom Dale');\nconsole.log(tom.constructor()); // Error: undefined is not a function\n```\n\n### Methods\n\nMethods are functions that are defined on the class, and usable by instances:\n\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  helloWorld() {\n    console.log(`${this.name} says: Hello, world!`);\n  }\n}\n\nlet stefan = new Person('Stefan Penner');\nstefan.helloWorld(); // Stefan Penner says: Hello, world!\n```\n\nLike functions declared on objects, they can access the instance using `this`,\nso they can store and access variables on the instance.\n\nMethods do _not_ exist on the class itself by default:\n\n```js\nclass Person {\n  helloWorld() {\n    console.log('Hello, world!');\n  }\n}\n\nPerson.helloWorld(); // Error: undefined is not a function\n```\n\nThey exist on the class's _prototype_, and are only readily callable by\ninstances. However, they can be added to the class directly using the `static`\nkeyword, which is described in more detail below.\n\n> _Note: if you don't know what a \"prototype\" is, don't worry - it's how\n> JavaScript does inheritance. Most of the details of prototypes are made\n> simpler by native class syntax, and while it's useful to know, you don't need\n> to dig into them to continue learning Ember or to be productive. If you are\n> curious about them, you can check out the [MDN docs for more details][4]._\n\n[4]: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\n\n### Fields\n\nClass fields allow you to assign properties to an instance of the class on\nconstruction. You can define a field like this:\n\n```js\nclass Person {\n  name = 'Yehuda Katz';\n}\n```\n\nThis is the very similar to defining the `Person` class with a constructor like\nthis:\n\n```js\nclass Person {\n  constructor() {\n    this.name = 'Yehuda Katz';\n  }\n}\n```\n\nClass fields are somewhat like object properties, but they have some key\ndifferences. They are created and assigned to every instance of the class,\nmeaning that instance gets a _unique_ version of the field. This doesn't matter\nif the field is a primitive, like a string or a number, but does matter if it's\nan object or an array:\n\n```js\nclass Person {\n  friends = [];\n}\n\nlet tom = new Person();\nlet yehuda = new Person();\n\ntom.friends === yehuda.friends;\n// false, they're different arrays\n```\n\nFields can also access the class instance using `this` when they are being\nassigned:\n\n```js\nclass Child {\n  constructor(parent) {\n    this.parent = parent;\n  }\n}\n\nclass Parent {\n  child = new Child(this);\n}\n```\n\nHowever, relying on state should generally be avoided in field initializers,\nsince it can make your classes brittle and error prone, especially when\nrefactoring:\n\n```js\n// Avoid this ðŸ›‘\nclass Person {\n  title = 'Prof.';\n  name = 'Tomster';\n\n  fullName = `${this.title} ${this.name}`;\n}\n\n// because it breaks if you change the order\nclass Person {\n  fullName = `${this.title} ${this.name}`;\n\n  title = 'Prof.';\n  name = 'Tomster';\n}\n\nlet yehuda = new Person();\nconsole.log(yehuda.fullName); // undefined undefined\n\n// This is ok, works no matter what the order is âœ…\nclass Person {\n  constructor() {\n    this.fullName = `${this.title} ${this.name}`;\n  }\n\n  title = 'Prof.';\n  name = 'Tomster';\n}\n```\n\nFields are assigned before any code in the `constructor` method is run, which is\nwhy we can rely on them being assigned correctly by the time it runs. As with\nmethods, fields do _not_ exist on the class itself, nor do they exist on the\nclass's prototype, they only exist on the _instance_ of the class. However, they\ncan be added to the class directly using the `static` keyword, which is\ndescribed in more detail below.\n\n### Accessors\n\nAccessors, also known as getters/setters, allow you to define a special function\nthat is _accessed_ like a property. For example:\n\n```js\nclass Person {\n  get name() {\n    return 'Melanie Sumner';\n  }\n}\n\nlet melanie = new Person();\nconsole.log(melanie.name); // 'Melanie Sumner'\n```\n\nEven though `get name` is a method, we can treat it like a normal property.\nHowever, if we try to set the name property to a new value, we get an error:\n\n```js\nmelanie.name = 'Melanie Sumner';\n// Cannot set property name of #<Person> which has only a getter\n```\n\nWe need to add a _setter_ in order to be able to set it. Generally, the setter\nfunction stores the value somewhere, and the getter function retrieves it:\n\n```js\nclass Person {\n  _name = 'Melanie Sumner';\n\n  get name() {\n    return this._name;\n  }\n\n  set name(newName) {\n    this._name = newName;\n  }\n}\n\nlet melanie = new Person();\nconsole.log(melanie.name); // 'Melanie Sumner'\nconsole.log(melanie._name); // 'Melanie Sumner'\n\nmelanie.name = 'Melanie Autumn';\nconsole.log(melanie.name); // 'Melanie Autumn'\nconsole.log(melanie._name); // 'Melanie Autumn'\n```\n\nGetters can also be used on their own to calculate values dynamically:\n\n```js\nclass Person {\n  title = 'Dr.';\n  name = 'Zoey';\n\n  get fullName() {\n    return `${this.title} ${this.name}`;\n  }\n}\n```\n\nThese values are recalculated every time the property is accessed:\n\n```js\nclass Counter {\n  _count = 0;\n\n  get count() {\n    return this._count++;\n  }\n}\n\nlet counter = new Counter();\nconsole.log(counter.count); // 0\nconsole.log(counter.count); // 1\nconsole.log(counter.count); // 2\n```\n\nThis is why getters should generally _avoid_ mutating state on the instance, and\nyou should be aware of their performance cost since they'll rerun the code every\ntime.\n\nLike methods, accessors do _not_ exist on the class itself, and instead are on\nthe class prototype. As such, they are only readily accessible on _instances_ of\nthe class. However, they can be added to the class directly using the `static`\nkeyword, which is described in more detail below.\n\n### `static`\n\nAs we mentioned above, for all intents and purposes the methods, fields, and\naccessors are only usable on _instances_ of the class. However, sometimes you\nmay want to place them _directly_ on the class, for instance if you want to\nshare some state between all instances of the class. You can do this by adding\nthe `static` keyword in front of the definition:\n\n```js\nclass Vehicle {\n  constructor() {\n    Vehicle.incrementCount();\n  }\n\n  static incrementCount() {\n    this.count++;\n  }\n\n  static count = 0;\n}\n\nconsole.log(Vehicle.count); // 0\n\nlet car = new Vehicle();\n\nconsole.log(Vehicle.count); // 1\n```\n\nStatic class elements are _not_ available on instances, and are only available\ndirectly on the class itself.\n\n```js\nclass Alert {\n  static helloWorld() {\n    return 'Hello, world!';\n  }\n}\n\nconsole.log(Alert.helloWorld()); // Hello, world!\n\nlet alert = new Alert();\n\nconsole.log(alert.helloWorld()); // Error: undefined is not a function\n```\n\n### Decorators\n\nDecorators are user defined modifiers that can be applied to a class or class\nelement such as a field or method to change its behavior. For instance, you\ncould create a `@cache` decorator that caches the return value of a getter the\nfirst time it is calculated:\n\n```js\nimport { cache } from 'my-cache-decorator';\n\nclass Counter {\n  _count = 0;\n\n  @cache\n  get count() {\n    return this._count++;\n  }\n}\n\nlet counter = new Counter();\n\nconsole.log(counter.count); // 0\nconsole.log(counter.count); // 0\n```\n\nDecorators are _normal_ JavaScript functions that get applied with a special\nsyntax, which is why you import them like any other function, but you use the\n`@` symbol when applying them. Decorators come in a variety of flavors, and some\ncan be applied to classes directly as well:\n\n```js\n@observable\nclass Person {}\n```\n\nSome decorators can also receive arguments:\n\n```js\nclass Person {\n  fullName = 'Matthew Beale';\n\n  @alias('fullName') name;\n}\n\nlet matt = new Person();\nconsole.log(matt.name); // Matthew Beale\n```\n\nEmber provides [a number of decorators](https://api.emberjs.com/ember/release/modules/@ember%2Fobject#functions), such as the [`@tracked` decorator](https://api.emberjs.com/ember/release/functions/@glimmer%2Ftracking/tracked), that\nwill be described in greater detail later on in the guides.\n\n> Note: Decorators are still being actively developed in JavaScript, which means\n> that there may be small changes in the future. The decorators provided by\n> Ember should remain stable through these changes, but it is recommended that\n> you exercise caution if using any external decorator libraries which may not\n> have the same stability guarantees.\n\n### Using injection\n\nInstances can also make use of injection if they are embedded into the application container. To achieve this, you need to call [`setOwner`](https://api.emberjs.com/ember/3.27/functions/@ember%2Fapplication/setOwner) on the instance and supply the container. You can access the container by calling [`getOwner`](https://api.emberjs.com/ember/3.27/functions/@ember%2Fapplication/getOwner) on any framework object (components, services, routes, etc.).\n\n```js\nimport { service } from '@ember/service';\nimport { getOwner, setOwner } from '@ember/application';\n \nclass Item {\n  @service('shopping-cart') cart;\n\n  function addToCart() {\n    this.cart.add(this);\n  }\n}\n\n// On any framework object...\nlet item = new Item();\nsetOwner(item, getOwner(this));\nitem.addToCart();\n```\n\nAlternatively, you can call `setOwner` in the class constructor and simply supply the caller as an argument to the constructor.\n```js\nimport { service } from '@ember/service';\nimport { getOwner, setOwner } from '@ember/application';\n\nclass Item {\n  @service('shopping-cart') cart;\n\n  constructor(context) {\n    setOwner(this, getOwner(context));\n  }\n\n  function addToCart() {\n    this.cart.add(this);\n  }\n}\n\n// On any framework object...\nlet item = new Item(this);\nitem.addToCart();\n```\n\n## Extending Classes\n\nYou can create classes that extend existing classes, inheriting all of their\nelements, using the `extends` keyword:\n\n```js\nclass Vehicle {\n  move() {\n    console.log('moving!');\n  }\n}\n\nclass Aircraft extends Vehicle {\n  fly() {\n    console.log('flying!');\n  }\n}\n\nlet airbus = new Aircraft();\nairbus.move(); // moving!\nairbus.fly(); // flying!\n```\n\nStatic class elements are also inherited this way:\n\n```js\nclass Vehicle {\n  static count = 0;\n}\n\nclass Aircraft extends Vehicle {\n  static id = 1;\n}\n\nconsole.log(Aircraft.count); // 0\nconsole.log(Aircraft.id); // 1\n```\n\nDefining subclasses is otherwise the same as defining a base class in most ways,\nwith the exception of the `constructor` function where you _must_ use the\n`super` keyword (discussed in more detail below). Class elements that are\nredefined by the child class will be _overridden_, and their values will be fully\nreplaced on the child:\n\n```js\nclass Vehicle {\n  move() {\n    console.log('moving');\n  }\n}\n\nclass Aircraft extends Vehicle {\n  move() {\n    console.log('flying!');\n  }\n}\n\nlet airbus = new Aircraft();\nairbus.move(); // flying!\n```\n\nHowever, child classes can use the `super` keyword to access the parent, and use\nits methods and accessors. Class fields are always overwritten on the instance,\nso the values on the parent class cannot be accessed by the child if they are\nredefined.\n\n### `constructor` in extends\n\nWhen extending a class, if you define a `constructor` function you _must_ call\n`super` in the constructor, and you must do it _before_ you access the class\nwith `this`. This will call the parent class's constructor, ensuring that the\nclass is setup properly:\n\n```js\nclass Vehicle {\n  constructor() {\n    console.log('vehicle made!');\n  }\n}\n\nclass Aircraft extends Vehicle {\n  constructor() {\n    super();\n    console.log('aircraft made!');\n  }\n}\n\nlet airbus = new Aircraft();\n// vehicle made!\n// aircraft made!\n```\n\nIn general, it's a good idea to pass along any arguments to the parent class in\nthe call to `super`, since they'll probably be necessary for setting up the\nclass.\n\n```js\nclass TodoComponent extends Component {\n  constructor() {\n    super(...arguments);\n\n    // setup the component...\n  }\n}\n```\n\n### Using `super`\n\n`super` must be used in subclass constructors, but it can also be used in other\nclass methods or accessors. When being used in any other method, you must\nexplicitly specify the method you're calling on the super class:\n\n```js\nclass Vehicle {\n  move() {\n    console.log(`moving!`);\n  }\n}\n\nclass Aircraft extends Vehicle {\n  move() {\n    super.move();\n    console.log('flying!');\n  }\n}\n\nlet airbus = new Aircraft();\nairbus.move(); // moving! flying!\n```\n\nYou can also call _different_ methods on the super class if you want, allowing\nyou to change behaviors or alias methods:\n\n```js\nclass Vehicle {\n  moveType = 'moving';\n\n  move() {\n    console.log(`${this.moveType}!`);\n  }\n}\n\nclass Aircraft extends Vehicle {\n  moveType = 'flying';\n\n  fly() {\n    super.move();\n  }\n}\n\nlet airbus = new Aircraft();\nairbus.fly(); // flying!\n```\n\nIf the method does not exist on the parent class, it will throw an error:\n\n```js\nclass Vehicle {\n  moveType = 'moving';\n\n  move() {\n    console.log(`${this.moveType}!`);\n  }\n}\n\nclass Aircraft extends Vehicle {\n  moveType = 'flying';\n\n  fly() {\n    super.fly();\n  }\n}\n\nlet airbus = new Aircraft();\nairbus.fly(); // Error: undefined is not a function\n```\n\nIn certain cases, you will want to pass arguments to the super method before or\nafter overriding. This allows the super class method to continue operating as it\nnormally would.\n\nOne common example is when overriding the\n[`normalizeResponse()`](https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods/normalizeResponse?anchor=normalizeResponse)\nhook in one of Ember Data's serializers.\n\nA handy shortcut for this is to use a \"spread operator\", like `...arguments`:\n\n```javascript\nnormalizeResponse(store, primaryModelClass, payload, id, requestType)  {\n  // Customize my JSON payload for Ember-Data\n  return super.normalizeResponse(...arguments);\n}\n```\n\nThe above example returns the original arguments (after your customizations)\nback to the parent class, so it can continue with its normal operations.","description":"Native classes were first added to JavaScript in ES2015 (also known as ES6). They are defined using the class keyword, and look like this: \n\nclass Person { helloWorld() { console.log('Hello, world!'); } }  \n\nThis guide will go over the basics of classes..."}}}