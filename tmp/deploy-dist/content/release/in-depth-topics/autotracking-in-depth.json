{"data":{"type":"contents","id":"in-depth-topics/autotracking-in-depth","attributes":{"content":"Autotracking is how Ember's _reactivity_ model works - how it decides what to\nrerender, and when. This guide covers tracking in more depth, including how it\ncan be used in various types of classes, and how it interacts with arrays and\nPOJOs.\n\n## Autotracking Basics\n\nWhen Ember first renders a component, it renders the initial _state_ of that\ncomponent - the state of the instance, and state of the arguments that are\npassed to it:\n\n```handlebars {data-filename=app/components/hello.hbs}\n{{this.greeting}}, {{@name}}!\n```\n\n```js {data-filename=app/components/hello.js}\nimport Component from '@glimmer/component';\n\nexport default class HelloComponent extends Component {\n  language = 'en';\n\n  get greeting() {\n    switch (this.language) {\n      case 'en':\n        return 'Hello';\n      case 'de':\n        return 'Hallo';\n      case 'es':\n        return 'Hola';\n    }\n  }\n}\n```\n\n```handlebars {data-filename=app/templates/application.hbs}\n<Hello @name=\"Jen Weber\">\n```\n\nWhen Ember renders this template, we get:\n\n```html\nHello, Jen Weber!\n```\n\nBy default, Ember assumes that none of the values that are rendered will ever\nchange. In some cases this is clearly true - for instance, the punctuation in\nthe template will always be the same, so Ember doesn't need to do anything to\nupdate it. These are static, state-less parts of the template. In other cases,\nlike `this.greeting` or `@name` argument, that's less clear. It appears\n`language` might be something we want to update, and if we do, then `greeting`\nshould probably change, right? At the least, we should _check_ to see if it\nshould change.\n\nIn order to tell Ember a value might change, we need to mark it as _trackable_.\nTrackable values are values that:\n\n1. Can change over their componentâ€™s lifetime and\n2. Should cause Ember to rerender if and when they change\n\nWe can do this by marking the field with the `@tracked` decorator:\n\n```js {data-filename=app/components/hello.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nexport default class HelloComponent extends Component {\n  @tracked language = 'en';\n\n  get greeting() {\n    switch (this.language) {\n      case 'en':\n        return 'Hello';\n      case 'de':\n        return 'Hallo';\n      case 'es':\n        return 'Hola';\n    }\n  }\n}\n```\n\nWhen Ember renders a value like `{{this.greeting}}` in the template, it takes\nnote of any tracked properties that it encounters, in this case `language`. If\nthese values change in the future, it schedules a rerender, and then updates\n_only_ the values that could have changed. This means that when `language`\nchanges, only the `Hello` text in the browser will rerender - Ember leaves the\n`, Jen Weber!` portion completely alone!\n\nArguments, like `{{@name}}`, are automatically tracked, so if they change and\nare used somewhere in your component, the component will update accordingly.\n\n## Updating Tracked Properties\n\nTracked properties can be updated like any other property, using standard\nJavaScript syntax. For instance, we could update a tracked property via an\naction, as in this example component.\n\n```handlebars {data-filename=app/components/hello.hbs}\n{{this.greeting}}, {{@name}}!\n\n<select {{on \"change\" this.updateLanguage}}>\n  <option value=\"en\">English</option>\n  <option value=\"de\">German</option>\n  <option value=\"sp\">Spanish</option>\n</select>\n```\n\n```js {data-filename=app/components/hello.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class HelloComponent extends Component {\n  @tracked language = 'en';\n\n  get greeting() {\n    switch (this.language) {\n      case 'en':\n        return 'Hello';\n      case 'de':\n        return 'Hallo';\n      case 'es':\n        return 'Hola';\n    }\n  }\n\n  @action\n  updateLanguage(event) {\n    this.language = event.target.value;\n  }\n}\n```\n\nNow, whenever we change the value of the `select`, it'll call the action method,\nwhich will set the value of `language`. Since `language` is marked as tracked,\nand was used in rendering `greeting`, Ember will know that `greeting` needs to\nbe re-rendered in the template, and will update.\n\nAnother way that a tracked property could be updated is asynchronously, if\nyou're sending a request to the server. For instance, maybe we would want to\nload the user's preferred language:\n\n```js\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class HelloComponent extends Component {\n  constructor() {\n    super(...arguments);\n\n    fetch('/api/preferences')\n      .then(r => r.json()) // convert the response to a JS object\n      .then(response => {\n        this.language = response.preferredLanguage;\n      });\n  }\n\n  @tracked language = 'en';\n\n  get greeting() {\n    switch (this.language) {\n      case 'en':\n        return 'Hello';\n      case 'de':\n        return 'Hallo';\n      case 'es':\n        return 'Hola';\n    }\n  }\n}\n```\n\nThis will also trigger a rerender. No matter where the update occurs, updating\na tracked property will let Ember know to rerender any affected portion of the\napp.\n\n### Tracking Through Methods\n\nSo far we've only shown tracked properties working through getters, but tracking\nworks through _methods_ or _functions_ as well:\n\n```js\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class HelloComponent extends Component {\n  @tracked language = 'en';\n  @tracked supportedLanguages = ['en', 'de', 'es'];\n\n  isSupported(language) {\n    return this.supportedLanguages.includes(language);\n  }\n\n  get greeting() {\n    if (!this.isSupported(this.language)) {\n      return 'Unsupported Language';\n    }\n\n    switch (this.language) {\n      case 'en':\n        return 'Hello';\n      case 'de':\n        return 'Hallo';\n      case 'es':\n        return 'Hola';\n    }\n  }\n}\n```\n\nif `supportedLanguages` changes here, `greeting` will update as well! This\ncode could likely be refactored to use getters, but in cases where a function or\nmethod makes more sense, tracked properties will still work.\n\n### Tracked Properties in Custom Classes\n\nTracked properties can also be applied to your own custom classes, and used\nwithin your components and routes:\n\n```js {data-filename=src/utils/person.js}\nexport default class Person {\n  @tracked title;\n  @tracked name;\n\n  constructor(title, name) {\n    this.title = title;\n    this.name = name;\n  }\n\n  get fullName() {\n    return `${this.title} ${this.name}`;\n  }\n}\n```\n\n```js {data-filename=app/routes/application.js}\nimport Route from '@ember/routing/route';\nimport Person from '../../../../utils/person';\n\nexport default class ApplicationRoute extends Route {\n  model() {\n    return new Person('Dr.', 'Zoey');\n  }\n}\n```\n\n```js {data-filename=app/controllers/application.js}\nimport Controller from '@ember/controller';\nimport { action } from '@ember/object';\n\nexport default class ApplicationController extends Controller {\n  @action\n  updateName(title, name) {\n    this.model.title = title;\n    this.model.name = name;\n  }\n}\n```\n\n```handlebars {data-filename=app/templates/application.hbs}\n{{@model.fullName}}\n\n<button type=\"button\" {{on \"click\" (fn this.updateName 'Prof.' 'Tomster')}}>\n  Update Name\n</button>\n```\n\nAs long as the properties are tracked, and accessed when rendering the template\ndirectly or indirectly, everything should update as expected\n\n### Plain Old JavaScript Objects (POJOs)\n\nGenerally, you should try to create classes with their tracked properties\nenumerated and decorated with `@tracked`, instead of relying on dynamically\ncreated POJOs. In some cases however, if your usage of properties on POJOs is\ntoo dynamic, you may not be able to enumerate every single property that could\nbe tracked. There could be a prohibitive number of possible properties, or there\ncould be no way to know them in advance. In this case, it's recommended that you\n_reset_ the value wherever it is updated:\n\n```js\nclass SimpleCache {\n  @tracked _cache = {};\n\n  set(key, value) {\n    this._cache[key] = value;\n\n    // trigger an update\n    this._cache = this._cache;\n  }\n\n  get(key) {\n    return this._cache[key];\n  }\n}\n```\n\nTriggering an update like this will cause any getters that used the `cache` to\nrecalculate. Note that we can use the `get` method to access the cache, and it\nwill still push the `_cache` tracked property.\n\n#### Arrays\n\nArrays are another example of a type of object where you can't enumerate every\npossible value - after all, there are an infinite number of integers (though you\n_may_ run out of bits in your computer at some point!). Instead, you can\ncontinue to use `EmberArray`, which will continue to work with tracking and will\ncause any dependencies that use it to invalidate correctly.\n\n```js\nimport { A } from '@ember/array';\n\nclass ShoppingList {\n  items = A([]);\n\n  addItem(item) {\n    this.items.pushObject(item);\n  }\n}\n```\n\n## Caching of tracked properties\n\nIn contrast to computed properties from pre-Octane, tracked properties are not\ncached. A tracked property can also be recomputed even though its dependencies\nhaven't changed. The following example shows this behavior:\n\n```js\nimport { tracked } from '@glimmer/tracking';\n\nlet count = 0;\n\nclass Photo {\n  @tracked width = 600;\n  @tracked height = 400;\n\n  get aspectRatio() {\n    count++;\n    return this.width / this.height;\n  }\n}\n\nlet photo = new Photo();\n\nconsole.log(photo.aspectRatio); // 1.5\nconsole.log(count); // 1\nconsole.log(photo.aspectRatio); // 1.5\nconsole.log(count); // 2\n\nphoto.width = 800;\n\nconsole.log(photo.aspectRatio); // 2\nconsole.log(count); // 3\n```\n\nFrom the value of `count`, we see that `aspectRatio` was calculated 3 times.\n\nRecomputing is fine in most cases. If the computation that happens in the\ngetter is very expensive, however, you will want to cache the value and\nretrieve it when the dependencies haven't changed. You want to recompute only\nif a dependency has been updated.\n\nEmber's [cache API](https://github.com/ember-polyfills/ember-cache-primitive-polyfill) lets\nyou cache a getter in 2 steps:\n\n1. Pass a function that is costly to compute to `createCache`.\n1. In the getter, call the function with `getValue` and return its value.\n\nWith these steps in mind, let's introduce caching to `aspectRatio`:\n\n```js\nimport { tracked } from '@glimmer/tracking';\nimport { createCache, getValue } from '@glimmer/tracking/primitives/cache';\n\nlet count = 0;\n\nclass Photo {\n  @tracked width = 600;\n  @tracked height = 400;\n\n  // `#` indicates a private field on the class\n  #aspectRatioCache = createCache(() => {\n    count++;\n    return this.width / this.height;\n  });\n\n  get aspectRatio() {\n    return getValue(this.#aspectRatioCache);\n  }\n}\n\nlet photo = new Photo();\n\nconsole.log(photo.aspectRatio); // 1.5\nconsole.log(count); // 1\nconsole.log(photo.aspectRatio); // 1.5\nconsole.log(count); // 1\n\nphoto.width = 800;\n\nconsole.log(photo.aspectRatio); // 2\nconsole.log(count); // 2\n```\n\nFrom the value of `count`, we see that, this time, `aspectRatio` was calculated\nonly twice.\n\nThe cache API was released in Ember 3.22. If you want to leverage this API between versions 3.13 and 3.21, you can install [ember-cache-primitive-polyfill](https://github.com/ember-polyfills/ember-cache-primitive-polyfill) to your project.\n\n<!-- eof - needed for pages that end in a code block  -->","description":"Autotracking is how Ember's reactivity model works - how it decides what to rerender, and when. This guide covers tracking in more depth, including how it can be used in various types of classes, and how it interacts with arrays and POJOs. Autotracking..."}}}