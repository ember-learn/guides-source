{"data":{"type":"contents","id":"in-depth-topics/patterns-for-actions","attributes":{"content":"Actions are the primary method for updating state in an Ember application, and\nas such they have lots of uses and patterns. This guide covers some of the more\ncommon action patterns that can be used in Ember.\n\n## Action Fundamentals\n\nImagine we're building an application where users can have accounts. We need to\nbuild the UI for users to delete their account. Because we don't want users to\naccidentally delete their accounts, we'll build a button that requires the user\nto confirm in order to trigger some action.\n\nWe'll call this the `ButtonWithConfirmation` component. We can start off with a\nnormal component definition, like we've seen before:\n\n```handlebars {data-filename=app/components/button-with-confirmation.hbs}\n<button type=\"button\">{{@text}}</button>\n\n{{#if this.isConfirming}}\n  <div class=\"confirm-dialog\">\n    <button type=\"button\" class=\"confirm-submit\">\n      OK\n    </button>\n    <button type=\"button\" class=\"confirm-cancel\">\n      Cancel\n    </button>\n  </div>\n{{/if}}\n```\n\n```js {data-filename=app/components/button-with-confirmation.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\n\nexport default class ButtonWithConfirmationComponent extends Component {\n  @tracked isConfirming = false;\n}\n```\n\nNow we have a button that can receive some text as an argument, with a modal\nconfirmation that will show conditionally based on its `isConfirming`\nproperty. You'll notice this property is decorated with the `@tracked`\ndecorator - this is known as a _tracked property_, and indicates to Ember that\nthe field will change in value over the lifetime of the component. You can learn\nmore about tracked properties in the [Autotracking In-Depth](../autotracking-in-depth/)\nguide.\n\nNext, we need to hook up the button to toggle that property. We'll\ndo this with an _action_:\n\n```js {data-filename=app/components/button-with-confirmation.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class ButtonWithConfirmationComponent extends Component {\n  @tracked isConfirming = false;\n\n  @action\n  launchConfirmDialog() {\n    this.isConfirming = true;\n  }\n}\n```\n\n```handlebars\n<button type=\"button\" {{on \"click\" this.launchConfirmDialog}}>\n  {{@text}}\n</button>\n\n{{#if this.isConfirming}}\n  <div class=\"confirm-dialog\">\n    <button type=\"button\" class=\"confirm-submit\">\n      OK\n    </button>\n    <button type=\"button\" class=\"confirm-cancel\">\n      Cancel\n    </button>\n  </div>\n{{/if}}\n```\n\nNow if we click the button, it will show the confirmation dialog - our first\ninteractive component! We'll also want the modal to close when we click either\nof the modal buttons, so we can add a couple more actions to handle that:\n\n```js {data-filename=app/components/button-with-confirmation.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class ButtonWithConfirmationComponent extends Component {\n  @tracked isConfirming = false;\n\n  @action\n  launchConfirmDialog() {\n    this.isConfirming = true;\n  }\n\n  @action\n  submitConfirm() {\n    this.isConfirming = false;\n  }\n\n  @action\n  cancelConfirm() {\n    this.isConfirming = false;\n  }\n}\n```\n\n```handlebars\n<button type=\"button\" {{on \"click\" this.launchConfirmDialog}}>\n  {{@text}}\n</button>\n\n{{#if this.isConfirming}}\n  <div class=\"confirm-dialog\">\n    <button\n      type=\"button\"\n      class=\"confirm-submit\"\n      {{on \"click\" this.submitConfirm}}\n    >\n      OK\n    </button>\n    <button\n      type=\"submit\"\n      class=\"confirm-cancel\"\n      {{on \"click\" this.cancelConfirm}}\n    >\n      Cancel\n    </button>\n  </div>\n{{/if}}\n```\n\nNow we can open and close the modal dialog at will! Next, we'll setup the\ncomponent to send its _own_ events when the user clicks the \"OK\" and \"Cancel\"\nbuttons.\n\n## Exposing Actions as Public API\n\nLet's create a parent component, the `UserProfile` component, where the user can\ndelete their profile:\n\n```handlebars {data-filename=app/components/user-profile.hbs}\n<ButtonWithConfirmation\n  @text=\"Click OK to delete your account.\"\n/>\n```\n\nFirst we'll define what we want to happen when the user clicks the button and\nthen confirms. In the first case, we'll find the user's account and delete it.\n\nWe'll implement an action on the parent component called\n`deleteAccount()` that, when called, gets a hypothetical `login`\n[service](../../services/) and calls the service's `deleteUser()`\nmethod. We'll go over services later on - for now, think of it as an API\nthat manages the user's login and information.\n\n```javascript {data-filename=app/components/user-profile.js}\nimport Component from '@glimmer/component';\nimport { service } from '@ember/service';\nimport { action } from '@ember/object';\n\nexport default class UserProfileComponent extends Component {\n  @service login;\n\n  @action\n  deleteAccount() {\n    this.login.deleteUser();\n  }\n}\n```\n\nNow we've implemented our action, but we have not told Ember when we want this\naction to be triggered. In order to trigger the action when the user clicks \"OK\"\nin the `ButtonWithConfirmation` component, we'll need to pass the action _down_\nto it as an argument:\n\n```handlebars {data-filename=app/components/user-profile.hbs}\n<ButtonWithConfirmation\n  @text=\"Click OK to delete your account.\"\n  @onConfirm={{this.deleteAccount}}\n/>\n```\n\nNext, in the child component we will implement the logic to confirm that the\nuser wants to take the action they indicated by clicking the button:\n\n```javascript {data-filename=app/components/button-with-confirmation.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class ButtonWithConfirmationComponent extends Component {\n  @tracked isConfirming = false;\n\n  @action\n  launchConfirmDialog() {\n    this.isConfirming = true;\n  }\n\n  @action\n  submitConfirm() {\n    if (this.args.onConfirm) {\n      this.args.onConfirm();\n    }\n\n    this.isConfirming = false;\n  }\n\n  @action\n  cancelConfirm() {\n    this.isConfirming = false;\n  }\n}\n```\n\nNow, when we click on the confirm button, the `submitConfirm` action will also\ncall the `deleteAccount` action, which was passed down as an argument to\nthe confirmation button component. In this way, the `@onConfirm` argument is\nlike an event which our `ButtonWithConfirmation` component triggers.\n\n## Handling Action Completion\n\nOften actions perform asynchronous tasks, such as making an ajax request to a\nserver. Since actions are functions that can be passed in by a parent component,\nthey are able to return values when called. The most common scenario is for an\naction to return a promise so that the component can handle the action's\ncompletion.\n\nIn our `ButtonWithConfirmation` component we want to leave the confirmation\nmodal open until we know that the operation has completed successfully. This is\naccomplished by expecting a promise to be returned from `onConfirm`. Upon\nresolution of the promise, we set a property used to indicate the visibility of\nthe confirmation modal. We can use an `async` function to handle that promise:\n\n```javascript {data-filename=app/components/button-with-confirmation.js}\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\n\nexport default class ButtonWithConfirmationComponent extends Component {\n  @tracked isConfirming = false;\n\n  @action\n  launchConfirmDialog() {\n    this.isConfirming = true;\n  }\n\n  @action\n  async submitConfirm() {\n    if (this.args.onConfirm) {\n      await this.args.onConfirm();\n    }\n\n    this.isConfirming = false;\n  }\n\n  @action\n  cancelConfirm() {\n    this.isConfirming = false;\n  }\n}\n```\n\n## Passing Arguments\n\nSometimes the parent component invoking an action has some context needed for\nthe action that the child component doesn't. Consider, for example, the case\nwhere the `ButtonWithConfirmation` component we've defined is used within\n`SendMessage`. The `sendMessage` action that we pass to the child component may\nexpect a message type parameter to be provided as an argument:\n\n```javascript {data-filename=app/components/send-message.js}\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class SendMessageComponent extends Component {\n  @action\n  async sendMessage(messageType) {\n    // send message here and return a promise\n  }\n}\n```\n\nHowever, the `ButtonWithConfirmation` component invoking the action doesn't know\nor care what type of message it's collecting. In cases like this, the parent\ntemplate can provide the required parameter when the action is passed to the\nchild. For example, if we want to use the button to send a message of type\n`\"info\"`:\n\n```handlebars {data-filename=app/components/send-message.hbs}\n<ButtonWithConfirmation\n  @text=\"Click to send your message.\"\n  @onConfirm={{fn this.sendMessage \"info\"}}\n/>\n```\n\nWithin `ButtonWithConfirmation`, the code in the `submitConfirm` action does not\nchange. It will still invoke `onConfirm` without explicit arguments:\n\n```javascript {data-filename=app/components/button-with-confirmation.js}\nawait this.args.onConfirm();\n```\n\nHowever the expression `{{fn this.sendMessage \"info\"}}` used in passing the\naction to the component creates a closure and partially applies the given parameter to the new function. So now when the action is invoked, that parameter will automatically be passed as its argument,\neffectively calling `sendMessage(\"info\")`, despite the argument not appearing in\nthe calling code.\n\nSo far in our example, the action we have passed to `ButtonWithConfirmation` is\na function that accepts one argument, `messageType`. Suppose we want to extend\nthis by allowing `sendMessage` to take a second argument, the actual text of the\nmessage the user is sending:\n\n```javascript {data-filename=app/components/send-message.js}\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class SendMessageComponent extends Component {\n  @action\n  async sendMessage(messageType, messageText) {\n    // send message here and return a promise\n  }\n}\n```\n\nWe want to arrange for the action to be invoked from within\n`ButtonWithConfirmation` with both arguments. We've seen already that if we\nprovide a `messageType` value to the `fn` helper when we insert\n`ButtonWithConfirmation` into its parent `SendMessage` template, that value will\nbe passed to the `sendMessage` action as its first argument automatically when\ninvoked as `onConfirm`. If we subsequently pass a single additional argument to\n`onConfirm` explicitly, that argument will be passed to `sendMessage` as its\nsecond argument (This ability to provide arguments to a function one at a time\nis known as [partial application](https://en.wikipedia.org/wiki/Partial_application)).\n\nIn our case, the explicit argument that we pass to `onConfirm` will be the\nrequired `messageText`. However, remember that internally our\n`ButtonWithConfirmation` component does not know or care that it is being used\nin a messaging application. Therefore within the component's JavaScript file, we\nwill use a property `confirmValue` to represent that argument and pass it to\n`onConfirm` as shown here:\n\n```javascript {data-filename=app/components/button-with-confirmation.js}\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class ButtonWithConfirmationComponent extends Component {\n  @action\n  async submitConfirm() {\n    if (this.args.onConfirm) {\n      // call `onConfirm` with a second argument\n      await this.args.onConfirm(this.confirmValue);\n    }\n\n    this.isConfirming = false;\n  }\n\n  //...\n}\n```\n\nIn order for `confirmValue` to take on the value of the message text, we'll bind\nthe property to the value of a user input field that will appear when the button\nis clicked. To accomplish this, we'll first modify the component so that it can\nbe used in block form and we will pass `confirmValue` as a\n[block parameter](../../components/block-content/) within the confirm dialog\nelement:\n\n```handlebars {data-filename=app/components/button-with-confirmation.hbs}\n<button type=\"button\" {{on \"click\" this.launchConfirmDialog}}>\n  {{this.text}}\n</button>\n\n{{#if this.isConfirming}}\n  <div class=\"confirm-dialog\">\n    {{yield this.confirmValue}}\n\n    <button type=\"button\"\n      class=\"confirm-submit\"\n      {{on \"click\" this.submitConfirm}}\n    >\n      OK\n    </button>\n    <button type=\"button\"\n      class=\"confirm-cancel\"\n      {{on \"click\" this.cancelConfirm}}\n    >\n      Cancel\n    </button>\n  </div>\n{{/if}}\n```\n\nWith this modification, we can now use the component in `SendMessage` to wrap a\ntext input element whose `value` attribute is set to `confirmValue`:\n\n```handlebars {data-filename=app/components/send-message.hbs}\n<ButtonWithConfirmation\n  @text=\"Click to send your message.\"\n  @onConfirm={{fn this.sendMessage \"info\"}}\nas |confirmValue|>\n  <Input @value={{confirmValue}} />\n</ButtonWithConfirmation>\n```\n\nWhen the user enters their message into the input field, the message text will\nnow be available to the component as `confirmValue`. Then, once they click the\n\"OK\" button, the `submitConfirm` action will be triggered, calling `onConfirm`\nwith the provided `confirmValue`, thus invoking the `sendMessage` action in\n`SendMessage` with both the `messageType` and `messageText` arguments.\n\n## Invoking Actions Directly on Component Collaborators\n\nActions can be invoked on objects other than the component directly from the\ntemplate. For example, in our `SendMessage` component we might include a service\nthat processes the `sendMessage` logic.\n\n```javascript {data-filename=app/components/send-message.js}\nimport Component from '@glimmer/component';\nimport { service } from '@ember/service';\n\nexport default class SendMessageComponent extends Component {\n  @service messaging;\n\n  // component implementation\n}\n```\n\nWe can tell the action to invoke the `sendMessage` action directly on the\nmessaging service.\n\n```handlebars {data-filename=app/components/send-message.hbs}\n<ButtonWithConfirmation\n  @text=\"Click to send your message.\"\n  @onConfirm={{fn this.messaging.sendMessage \"info\"}}\nas |confirmValue|>\n  <Input @value={{confirmValue}} />\n</ButtonWithConfirmation>\n```\n\nThe interesting part is that the action from the service just works, because\nit's auto-bound to that service.\n\n```javascript {data-filename=app/services/messaging.js}\nimport Service from '@ember/service';\nimport { action } from '@ember/object';\n\nexport default class Messaging extends Service {\n  @action\n  async sendMessage(messageType, text) {\n    // handle message send and return a promise\n  }\n}\n```\n\n## Destructuring Objects Passed as Action Arguments\n\nA component will often not know what information a parent needs to process an\naction, and will just pass all the information it has. For example, our\n`UserProfile` component is going to notify its parent,\n`SystemPreferencesEditor`, that a user's account was deleted, and passes along\nwith it the full user profile object.\n\n```javascript {data-filename=app/components/user-profile.js}\nimport Component from '@glimmer/component';\nimport { service } from '@ember/service';\nimport { action } from '@ember/object';\n\nexport default class UserProfileComponent extends Component {\n  @service login;\n\n  @action\n  async deleteAccount() {\n    await this.login.deleteUser();\n\n    this.args.didDelete(this.login.currentUserObj);\n  }\n}\n```\n\nAll our `SystemPreferencesEditor` component really needs to process a user\ndeletion is an account ID. For this case, the `fn` helper provides the value\nvia partial application to allow a parent component to dig into the passed\nobject to pull out only what it needs.\n\n```handlebars {data-filename=app/components/system-preferences-editor.hbs}\n<UserProfile @didDelete={{fn this.userDeleted this.login.currentUser.id}} />\n```\n\nNow when the `SystemPreferencesEditor` handles the delete action, it receives\nonly the user's account `id` string.\n\n```javascript {data-filename=app/components/system-preferences-editor.js}\nimport Component from '@glimmer/component';\nimport { action } from '@ember/object';\n\nexport default class SystemPreferencesEditorComponent extends Component {\n  @action\n  userDeleted(idStr /* , native clickEvent */) {\n    // respond to deletion\n  }\n}\n```\n\n## Calling Actions Up Multiple Component Layers\n\nWhen your components go multiple template layers deep, it is common to need to\nhandle an action several layers up the tree.\n\n<!-- Note about prop drilling / anti-patterns?-->\n\nParent components can pass actions to child components through templates alone without\nadding JavaScript code to those child components.\n\nFor example, say we want to move account deletion from the `UserProfile`\ncomponent to its parent `SystemPreferencesEditor`.\n\nFirst we would move the `deleteUser` action from `user-profile.js` to\nthe parent `system-preferences-editor.js`.\n\n```javascript {data-filename=app/components/system-preferences-editor.js}\nimport Component from '@glimmer/component';\nimport { service } from '@ember/service';\nimport { action } from '@ember/object';\n\nexport default class SystemPreferencesEditorComponent extends Component {\n  @service login;\n\n  @action\n  deleteUser(idStr) {\n    return this.login.deleteUserAccount(idStr);\n  }\n}\n```\n\nThen our `SystemPreferencesEditor` template passes its local `deleteUser`\naction into the `UserProfile` as that component's `deleteCurrentUser` argument.\n\n```handlebars {data-filename=app/components/system-preferences-editor.hbs}\n<UserProfile\n  @deleteCurrentUser={{fn this.deleteUser this.login.currentUser.id}}\n/>\n```\n\nThe `deleteUser` action is prepended with `this.`, since\n`SystemPreferencesEditor` is where the action is defined now. If the action\nwas passed from a parent, then it might have looked like `@deleteUser` instead.\n\nIn our `user-profile.hbs` template we change our action to call\n`deleteCurrentUser` as passed above.\n\n```handlebars {data-filename=app/components/user-profile.hbs}\n<ButtonWithConfirmation\n  @text=\"Click OK to delete your account.\"\n  @onConfirm={{@deleteCurrentUser}}\n/>\n```\n\nNote that `deleteCurrentUser` is now prepended with `@` as opposed to `this.`\n[previously](#toc_passing-the-action-to-the-component).\n\nNow when you confirm deletion, the action goes straight to the\n`SystemPreferencesEditor` to be handled in its local context.","description":"Actions are the primary method for updating state in an Ember application, and as such they have lots of uses and patterns. This guide covers some of the more common action patterns that can be used in Ember. Action Fundamentals \n\nImagine we're building an..."}}}