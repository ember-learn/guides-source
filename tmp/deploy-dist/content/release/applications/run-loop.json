{"data":{"type":"contents","id":"applications/run-loop","attributes":{"content":"**Note:**\n* _For basic Ember app development scenarios, you don't need to understand the run loop or use it directly. All common paths are paved nicely for you and don't require working with the run loop._\n* _However, the run loop will be helpful to understand the internals of Ember and to assist in customized performance tuning by manually batching costly work._\n\nEmber's internals and most of the code you will write in your applications takes place in a run loop.\nThe run loop is used to batch, and order (or reorder) work in a way that is most effective and efficient.\n\nIt does so by scheduling work on specific queues.\nThese queues have a priority, and are processed to completion in priority order.\n\nThe most common case for using the run loop is integrating with a non-Ember API\nthat includes some sort of asynchronous callback.\nFor example:\n\n- DOM update and event callbacks\n- `setTimeout` and `setInterval` callbacks\n- `postMessage` and `messageChannel` event handlers\n- fetch or ajax callbacks\n- WebSocket callbacks\n\n## Why is the run loop useful?\n\nVery often, batching similar work has benefits.\nWeb browsers do something quite similar by batching changes to the DOM.\n\nConsider the following HTML snippet:\n\n```html\n<div id=\"foo\"></div>\n<div id=\"bar\"></div>\n<div id=\"baz\"></div>\n```\n\nand executing the following code:\n\n```javascript\nfoo.style.height = '500px' // write\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\n\nbar.style.height = '400px' // write\nbar.offsetHeight // read (recalculate style, layout, expensive!)\n\nbaz.style.height = '200px' // write\nbaz.offsetHeight // read (recalculate style, layout, expensive!)\n```\n\nIn this example, the sequence of code forced the browser to recalculate style, and relayout after each step.\nHowever, if we were able to batch similar jobs together,\nthe browser would have only needed to recalculate the style and layout once.\n\n```javascript\nfoo.style.height = '500px' // write\nbar.style.height = '400px' // write\nbaz.style.height = '200px' // write\n\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\nbar.offsetHeight // read (fast since style and layout are already known)\nbaz.offsetHeight // read (fast since style and layout are already known)\n```\n\nInterestingly, this pattern holds true for many other types of work.\nEssentially, batching similar work allows for better pipelining, and further optimization.\n\nLet's look at a similar example that is optimized in Ember, starting with an `Image` class:\n\n```javascript\nimport { tracked } from '@glimmer/tracking';\n\nclass Image {\n  @tracked width;\n  @tracked height;\n\n  constructor({ width, height }) {\n    this.width = width ?? null;\n    this.height = height ?? null;\n  }\n\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\n```\n\nand a template to display its attributes:\n\n```handlebars\n{{this.width}}\n{{this.aspectRatio}}\n```\n\nIf we execute the following code without the run loop:\n\n```javascript\nlet profilePhoto = new Image({ width: 250, height: 500 });\nprofilePhoto.width = 300;\n// profilePhoto.width and profilePhoto.aspectRatio are updated\n\nprofilePhoto.height = 300;\n// profilePhoto.height and profilePhoto.aspectRatio are updated\n```\n\nWe see that the browser will rerender the template twice.\n\nHowever, if we have the run loop in the above code,\nthe browser will only rerender the template once the attributes have all been set.\n\n```javascript\nlet profilePhoto = new Image({ width: 250, height: 500 });\nprofilePhoto.width = 600;\nprofilePhoto.height = 600;\nprofilePhoto.width = 300;\nprofilePhoto.height = 300;\n```\n\nIn the above example with the run loop, since the user's attributes end up at the same values as before execution,\nthe template will not even rerender!\n\nIt is of course possible to optimize these scenarios on a case-by-case basis,\nbut getting them for free is much nicer.\nUsing the run loop, we can apply these classes of optimizations not only for each scenario, but holistically app-wide.\n\n## How does the Run Loop work in Ember?\n\nAs mentioned earlier, we schedule work (in the form of function invocations) on queues,\nand these queues are processed to completion in priority order.\n\nWhat are the queues, and what is their priority order?\n\n1. `actions`\n2. `routerTransitions`\n3. `render`\n4. `afterRender`\n5. `destroy`\n\nHere, in this list, the \"actions\" queue has a higher priority than the \"render\" or \"destroy\" queue.\n\n## What happens in these queues?\n\n* The `actions` queue is the general work queue and will typically contain scheduled tasks e.g. promises.\n* The `routerTransitions` queue contains transition jobs in the router.\n* The `render` queue contains jobs meant for rendering, these will typically update the DOM.\n* The `afterRender` queue contains jobs meant to be run after all previously scheduled render tasks are complete.\nThis is often good for 3rd-party DOM manipulation libraries,\nthat should only be run after an entire tree of DOM has been updated.\n* The `destroy` queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.\n\n## In what order are jobs executed on the queues?\nThe algorithm works this way:\n\n1. Let the highest priority queue with pending jobs be: `CURRENT_QUEUE`,\nif there are no queues with pending jobs the run loop is complete\n2. Let a new temporary queue be defined as `WORK_QUEUE`\n3. Move jobs from `CURRENT_QUEUE` into `WORK_QUEUE`\n4. Process all the jobs sequentially in `WORK_QUEUE`\n5. Return to Step 1\n\n## An example of the internals\n\nRather than writing the higher level app code that internally invokes the various run loop scheduling functions,\nwe have stripped away the covers, and shown the raw run-loop interactions.\n\nWorking with this API directly is not common in most Ember apps,\nbut understanding this example will help you to understand the run-loops algorithm,\nwhich will make you a better Ember developer.\n\n<iframe src=\"https://s3.amazonaws.com/emberjs.com/run-loop-guide/index.html\" width=\"678\" height=\"410\" style=\"border:1px solid rgb(170, 170, 170);margin-bottom:1.5em;\"></iframe>\n\n## How do I tell Ember to start a run loop?\n\nYou should begin a run loop when the callback fires.\n\nThe `Ember.run` method can be used to create a run loop.\nIn this example, `Ember.run` is used to handle an online\nevent (browser gains internet access) and run some Ember code.\n\n```javascript\nwindow.addEventListener('online', () => {\n  Ember.run(() => {  // begin loop\n    // Code that results in jobs being scheduled goes here\n  }); // end loop, jobs are flushed and executed\n});\n```\n\n\n\n## What happens if I forget to start a run loop in an async handler?\n\nAs mentioned above, you should wrap any non-Ember async callbacks in `Ember.run`.\nIf you don't, Ember will try to approximate a beginning and end for you.\nConsider the following callback:\n\n```javascript\nwindow.addEventListener('online', () => {\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', () => {\n    // Do more things\n  });\n});\n```\n\nThe run loop API calls that _schedule_ work, i.e. [`run.schedule`](https://api.emberjs.com/ember/release/classes/@ember%2Frunloop/methods/schedule?anchor=schedule),\n[`run.scheduleOnce`](https://api.emberjs.com/ember/release/classes/@ember%2Frunloop/methods/scheduleOnce?anchor=scheduleOnce),\n[`run.once`](https://api.emberjs.com/ember/release/classes/@ember%2Frunloop/methods/once?anchor=once) have the property that they will approximate a run loop for you if one does not already exist.\nThese automatically created run loops we call _autoruns_.\n\nHere is some pseudocode to describe what happens using the example above:\n\n```javascript\nwindow.addEventListener('online', () => {\n  // 1. autoruns do not change the execution of arbitrary code in a callback.\n  //    This code is still run when this callback is executed and will not be\n  //    scheduled on an autorun.\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', () => {\n    // 2. schedule notices that there is no currently available run loop so it\n    //    creates one. It schedules it to close and flush queues on the next\n    //    turn of the JS event loop.\n    if (! Ember.run.hasOpenRunLoop()) {\n      Ember.run.begin();\n      nextTick(() => {\n        Ember.run.end()\n      }, 0);\n    }\n\n    // 3. There is now a run loop available so schedule adds its item to the\n    //    given queue\n    Ember.run.schedule('actions', () => {\n      // Do more things\n    });\n\n  });\n\n  // 4. This schedule sees the autorun created by schedule above as an available\n  //    run loop and adds its item to the given queue.\n  Ember.run.schedule('afterRender', () => {\n    // Do yet more things\n  });\n});\n```\n\n## Where can I find more information?\n\nCheck out the [Ember.run](https://api.emberjs.com/ember/release/classes/@ember%2Frunloop) API documentation,\nas well as the [Backburner library](https://github.com/ebryn/backburner.js/) that powers the run loop.","description":"Note: \n\n- For basic Ember app development scenarios, you don't need to understand the run loop or use it directly. All common paths are paved nicely for you and don't require working with the run loop.\n- However, the run loop will be helpful to understand..."}}}