{"data":{"type":"contents","id":"applications/dependency-injection","attributes":{"content":"Ember applications utilize the [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection)\n(\"DI\") design pattern to declare and instantiate classes of objects and dependencies between them.\n\nGenerally, [Services](../../services/) are Ember's primary method for sharing\nstate via dependency injection. In most cases, you shouldn't need to learn about\nhow to work with Ember's DI system directly, or how to manually register and\nsetup dependencies. However, there are times when it may be necessary. This\nguide covers the details of the system, and how to use it when needed.\n\n## Overview\n\nApplications and application instances each serve a role in Ember's DI implementation.\n\nAn [`Application`](https://api.emberjs.com/ember/release/classes/Application) serves as a \"registry\" for dependency declarations.\nFactories (i.e. classes) are registered with an application,\nas well as rules about \"injecting\" dependencies that are applied when objects are instantiated.\n\nAn [`ApplicationInstance`](https://api.emberjs.com/ember/release/classes/ApplicationInstance) serves as the \"owner\" for objects that are instantiated from registered factories.\nApplication instances provide a means to \"look up\" (i.e. instantiate and / or retrieve) objects.\n\n> _Note: Although an `Application` serves as the primary registry for an app,\n> each `ApplicationInstance` can also serve as a registry.\n> Instance-level registrations are useful for providing instance-level customizations,\n> such as A/B testing of a feature._\n\n## Factory Registrations\n\nA factory can represent any part of your application, like a _route_, _template_, or custom class.\nEvery factory is registered with a particular key.\nFor example, the index template is registered with the key `template:index`,\nand the application route is registered with the key `route:application`.\n\nRegistration keys have two segments split by a colon (`:`).\nThe first segment is the framework factory type, and the second is the name of the particular factory.\nHence, the `index` template has the key `template:index`.\nEmber has several built-in factory types, such as `service`, `route`, `template`, and `component`.\n\n<div class=\"cta\">\n  <div class=\"cta-note\">\n    <div class=\"cta-note-body\">\n      <div class=\"cta-note-heading\">Zoey says...</div>\n      <div class=\"cta-note-message\">\n        <p>\n          You might ask, how can I find the name of a factory?\n        </p>\n        <p>\n          Factories are kebab-cased and directories are followed by a forward slash. For example, a controller <code>app/controllers/users/primary-teachers</code> is registered as <code>controller:users/primary-teachers</code>.\n        </p>\n      </div>\n    </div>\n    <img src=\"/images/mascots/zoey.png\" role=\"presentation\" alt=\"\">\n  </div>\n</div>\n\nYou can create your own factory type by simply registering a factory with the new type.\nFor example, to create a `user` type,\nyou'd simply register your factory with `application.register('user:user-to-register')`.\n\nFactory registrations must be performed either in application\nor application instance initializers (with the former being much more common).\n\nFor example, an application initializer could register a `Logger` factory with the key `logger:main`:\n\n```javascript {data-filename=app/initializers/logger.js}\nimport EmberObject from '@ember/object';\n\nexport function initialize(application) {\n  let Logger = EmberObject.extend({\n    log(m) {\n      console.log(m);\n    }\n  });\n\n  application.register('logger:main', Logger);\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n```\n\n### Registering Already Instantiated Objects\n\nBy default, Ember will attempt to instantiate a registered factory when it is looked up.\nWhen registering an already instantiated object instead of a class,\nuse the `instantiate: false` option to avoid attempts to re-instantiate it during lookups.\n\nIn the following example, the `logger` is a plain JavaScript object that should\nbe returned \"as is\" when it's looked up:\n\n```javascript {data-filename=app/initializers/logger.js}\nexport function initialize(application) {\n  let logger = {\n    log(m) {\n      console.log(m);\n    }\n  };\n\n  application.register('logger:main', logger, { instantiate: false });\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n```\n\n### Registering Singletons vs. Non-Singletons\n\nBy default, registrations are treated as \"singletons\".\nThis simply means that an instance will be created when it is first looked up,\nand this same instance will be cached and returned from subsequent lookups.\n\nWhen you want fresh objects to be created for every lookup,\nregister your factories as non-singletons using the `singleton: false` option.\n\nIn the following example, the `Message` class is registered as a non-singleton:\n\n```javascript {data-filename=app/initializers/notification.js}\nimport EmberObject from '@ember/object';\n\nexport function initialize(application) {\n  let Message = EmberObject.extend({\n    text: ''\n  });\n\n  application.register('notification:message', Message, { singleton: false });\n}\n\nexport default {\n  name: 'notification',\n  initialize: initialize\n};\n```\n\n## Factory Injections\n\nOnce a factory is registered, it can be \"injected\" where it is needed.\n\nFactories can be injected into whole \"types\" of factories with _type injections_. For example:\n\n```javascript {data-filename=app/initializers/logger.js}\nimport EmberObject from '@ember/object';\n\nexport function initialize(application) {\n  let Logger = EmberObject.extend({\n    log(m) {\n      console.log(m);\n    }\n  });\n\n  application.register('logger:main', Logger);\n  application.inject('route', 'logger', 'logger:main');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n```\n\nAs a result of this type injection,\nall factories of the type `route` will be instantiated with the property `logger` injected.\nThe value of `logger` will come from the factory named `logger:main`.\n\nRoutes in this example application can now access the injected logger:\n\n```javascript {data-filename=app/routes/index.js}\nimport Route from '@ember/routing/route';\n\nexport default class IndexRoute extends Route {\n  activate() {\n    // The logger property is injected into all routes\n    this.logger.log('Entered the index route!');\n  }\n}\n```\n\nInjections can also be made on a specific factory by using its full key:\n\n```javascript\napplication.inject('route:index', 'logger', 'logger:main');\n```\n\nIn this case, the logger will only be injected on the index route.\n\nInjections can be made into any class that requires instantiation.\nThis includes all of Ember's major framework classes, such as components, helpers, routes, and the router.\n\n### Ad Hoc Injections\n\nDependency injections can also be declared directly on Ember classes using `inject`.\nCurrently, `inject` supports injecting controllers (via `import { inject } from '@ember/controller';`)\nand services (via `import { inject } from '@ember/service';`).\n\nThe following code injects the `shopping-cart` service on the `cart-contents` component as the property `cart`:\n\n```javascript {data-filename=app/components/cart-contents.js}\nimport Component from '@glimmer/component';\nimport { service } from '@ember/service';\n\nexport default class CartContentComponent extends Component {\n  @service('shopping-cart') cart;\n}\n```\n\nIf you'd like to inject a service with the same name as the property,\nsimply leave off the service name (the dasherized version of the name will be used):\n\n```javascript {data-filename=app/components/cart-contents.js}\nimport Component from '@glimmer/component';\nimport { service } from '@ember/service';\n\nexport default class CartContentComponent extends Component {\n  @service shoppingCart;\n}\n```\n\n## Factory Instance Lookups\n\nTo fetch an instantiated factory from the running application you can call the\n[`lookup`](https://api.emberjs.com/ember/release/classes/ApplicationInstance/methods/lookup?anchor=lookup) method on an application instance. This method takes a string\nto identify a factory and returns the appropriate object.\n\n```javascript\napplicationInstance.lookup('factory-type:factory-name');\n```\n\nThe application instance is passed to Ember's instance initializer hooks and it\nis added as the \"owner\" of each object that was instantiated by the application\ninstance.\n\n### Using an Application Instance Within an Instance Initializer\n\nInstance initializers receive an application instance as an argument, providing\nan opportunity to look up an instance of a registered factory.\n\n```javascript {data-filename=app/instance-initializers/logger.js}\nexport function initialize(applicationInstance) {\n  let logger = applicationInstance.lookup('logger:main');\n\n  logger.log('Hello from the instance initializer!');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n```\n\n### Getting an Application Instance from a Factory Instance\n\n[`Ember.getOwner`](https://api.emberjs.com/ember/release/classes/@ember%2Fapplication/methods/getOwner?anchor=getOwner) will retrieve the application instance that \"owns\" an\nobject. This means that framework objects like components, helpers, and routes\ncan use [`Ember.getOwner`](https://api.emberjs.com/ember/release/classes/@ember%2Fapplication/methods/getOwner?anchor=getOwner) to perform lookups through their application\ninstance at runtime.\n\nFor example, this component plays songs with different audio services based\non a song's `audioType`.\n\n```javascript {data-filename=app/components/play-audio.js}\nimport Component from '@glimmer/component';\nimport { getOwner } from '@ember/application';\n\n// Usage:\n//\n// <PlayAudio @song=this.song />\n//\nexport default class PlayAudioComponent extends Component {\n  get audioService() {\n    if (!this.args.song) {\n      return null;\n    }\n\n    let applicationInstance = getOwner(this);\n    let { audioType } = this.args.song;\n\n    return applicationInstance.lookup(`service:audio-${audioType}`);\n  }\n\n  click() {\n    let player = this.audioService;\n    player.play(this.args.song.file);\n  }\n}\n```\n\n<!-- eof - needed for pages that end in a code block  -->","description":"Ember applications utilize the dependency injection (\"DI\") design pattern to declare and instantiate classes of objects and dependencies between them. \n\nGenerally, Services are Ember's primary method for sharing state via dependency injection. In most cases..."}}}